- https://www.inflearn.com/course/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B3%B5%EB%A3%A1%EC%B1%85-%EC%A0%84%EA%B3%B5%EA%B0%95%EC%9D%98#curriculum
- 주니온 박사님 강의 중 Chapter 6에 대한 정리

# Chapter 6. Synchronization Tools 

## 여러 프로세스(또는 스레드)에서 공유하는 데이터의 무결성 
- 동시 실행(Concurrent)
  - 프로세스는 명령 스트림의 모든 지점에서 interrupt될 수 있다.
  - 프로세싱 코어가 다른 프로세스에 할당될 수 있다. 
- 병렬 실행(Parallel)
  - 두 개 이상의 명령 스트림(다른 프로세스를 나타냄)
  - 별도의 프로세싱 코어에서 동시에 실행된다.

## Race Condition

여러 프로세스(또는 스레드)가 동시에 동일한(또는 공유된) 데이터에 액세스하고 조작하면 실행 결과는 매번 달라질 수 있다.

### 해결책
- 한 번에 하나의 프로세스만 공유 데이터를 조작할 수 있어야 한다.
- 그를 보장하기 위해서는 프로세스가 어떤 방식으로든 동기화되어야 한다. (synchronize)

## 임계 영역 문제
- 한 프로세스가 크리티컬 섹션에서 실행되는 경우, 다른 프로세스는 해당 섹션에서 실행할 수 없게 만들자.
- 데이터를 협력적으로 공유하기 위해 프로세스의 작업을 동기화한다.

### 섹션 분리
- 엔트리 섹션: 크리티컬 섹션에 들어갈 수 있는 권한을 요청할 수 있다.
- 엔트리 섹션은 엔트리 섹션을 따른다.
- 종료 섹션은 임계 섹션을 따른다.
- 나머지 섹션

### 해결책을 위한 요구사항
- Mutual Exclusion
- Progress: (avoid deadlock)
- Bounded Waiting: (avoid starvation)

### 싱글 코어 환경에서의 솔루션
- 공유 변수가 수정되는 동안 인터럽트가 발생하지 않도록 방지한다.
- 다른 명령이 실행되지 않으므로 공유 데이터를 예기치 않게 수정할 수 없다.
- 하지만 멀티프로세서 환경에서는 불가능하다.

## 두 가지 일반적인 접근 방식
- 비선점 커널
  - 커널 모드 프로세스는 커널 모드를 종료하거나, 차단하거나, 자발적으로 CPU를 산출할 때까지 실행된다.
  - 기본적으로 커널 데이터 구조의 race condition에서 자유롭다.
- 선점 커널을 사용하면 프로세스가 커널 모드에서 실행 중일 때 선점될 수 있다.
  - 본질적으로 설계하기가 어렵지만 반응형이다.

## 크리티컬 섹션 문제에 대한 소프트웨어 솔루션
- 데커 알고리즘
- 아이젠버그와 맥과이어의 알고리즘
- 피터슨 알고리즘
  - 고전적인 소프트웨어 솔루션.
  - 제대로 작동한다는 보장은 없다,

### 피터슨 알고리즘
- 중요한 섹션과 나머지 섹션 간에 번갈아 실행하는 두 프로세스로 제한된다.
- 본인의 차례일 때 flag 값을 활용하여 구분한다.
- 단, 아키텍처가 로드 및 저장과 같은 기본적인 기계어 명령을 수행하는 경우 Peterson의 솔루션이 올바르게 작동한다는 보장은 없다.
  - 개념적으로 완벽하긴 하다.
  - 상호 배제가 유지된다.
  - 진행 요구 사항이 충족된다. (데드록 없음)
  - 제한 대기 요건이 충족된다. (starvation 없음)

## 하드웨어 기반 솔루션
보다 추상적인 메커니즘의 기초를 형성하는 데 사용될 수 있다.

- 메모리 베리어(장벽)
- 하드웨어 설명서
- 원자적 변수

### 원자성
- 원자적 명령: 방해(uninterruptible)가 불가능한 작동 단위다.

# CSP 해결

CSP를 해결하기 위한 고급 소프트웨어 도구:
- Mutex Locks: 동기화를 위한 가장 간단한 도구
- 세마포어: 보다 강력하고 편리하며 효과적인 도구
- 모니터: 뮤텍스와 세마포의 단점을 극복
- Liveness: 프로세스가 진행될 수 있도록 보장

## Mutex Lock
- mutex: **mut**ual **ex**clusion.
- 크리티컬 섹션(critical section)을 보호하고 교착 상태를 방지한다.
- 프로세스는 크리티컬 섹션에 들어가기 전에 락을 얻어야 한다. 
  - 크리티컬 섹션을 벗어나면 락이 해제된다.

### Busy waiting
- 크리티컬 섹션에 진입하려는 다른 프로세스는 acquire() 호출에서 루프를 돌아야 한다.
- Busy waiting은 단일 CPU 코어가 많은 프로세스 간에 공유되는 실제 멀티프로그래밍 시스템에서 문제 상황으로 간주된다.
  - 일부 다른 프로세스가 생산적으로 사용하기 위해 CPU 사이클을 낭비하기 때문.

### Spinlock
- Busy waiting 방법을 사용하는 뮤텍스 잠금 유형이다.
- 락이 사용 가능해질 때까지 기다리는 동안 프로세스가 회전한다.
  - 그러나 스핀락은 잠금을 기다리는 컨텍스트 전환이 필요하지 않다는 장점이 있다.
- 컨텍스트 전환에는 상당한 시간이 걸릴 수 있다.
  - 다중 코어 시스템의 특정 상황에서는 스핀락이 적절한 방법이다.

## 세마포어
초기화와는 별도로 두 가지 표준 원자 연산(`wait()`과 `signal()` 또는 `P()`와 `V()`)을 통해서만 액세스되는 정수 변수다.
