# 8. Deadlocks

deadlock 이란?

- 모든 프로세스가 대기 상태에서 기다리고 있을때
- 세트의 다른 프로세스에 의해서만 발생할 수 있는 이벤트
- 쓰레드가 대기 상태에서 다른상태로 변경할수 없을때
- 리소스가 다른 스레드에 있어서 점령되어 있을때

시스템을 고려해보자

- 리소스타입을 고려해보자.
- 같은  인스턴스 →  cpu cycles files, i/o device 같은 경우 리소스타입이 중요 갯수는 중요하지 않음
- 위는  rqeust - use - Release의 단계를 거치는데   use가 크리티컬 섹션이다.

데드락의 필수 4가지 조건

1. Mutual Exclusion( 상호배제)
- 마지막 리소스가 상태를 잡고 공유하지 않는 경우
2. Hold and Wait( 점유 대기)
- 쓰레드가 어떤 자원을 점유한상태에서 대기를 해야만 일어난다.
3. No preemption(선점 불가)
- 자원이 선점이 불가능 할때
4. Circular Wait(원형대기)
- 데드락걸린 경우에는 무조건적으로 원형대기가 일어나고 있다.

### Resource-Allocation Graph(자원 할당 그래프)

- 데드락을 이해하기 위한 그래프

V == Vertieces

E == Edges

-노드의 두가지 종류

T = active Thread

R = Resource types

- 중간로직이 이해가 안가서 나중에 추가 정리하겠습니다

중요한 점은..

사이클이 없으면 데드락은 발생하지 않는다.

사이클이 있으면..? RAG 그래프의  사이클 디텍션을 잘 해야한다..

데드락에 대한 데처.

1. 무시하기
2. 발생하지 않게 방지하거나 회피
- 방지는 거의 불가능하다.
- 회피 →   Bankers algorithm
3. 데드락 발생 감지, 복구.

### Deadlock prevention

4가지 필수 요소 하나라도 되지 않게 막아보자!

**Mutual Exclusion**

모든 리소스를 공유 할수 있게 하자! → 불가능.. 어떻게 모든것을 공유할수 있어… mutex lock,eg 이런것은 공유되지 않음

**Hold and Wait**

공유하기 전 모든것을 버린후에 다시 점유를 한다. → 실용성 측면에서 불가능

**No preemption**

강제로 점유를 하자.사용중이라면 뺏어버리자. → 그럼 동작되고 있던 프로세스가 망가질수 있다.

**Circular Wait**

리소스마다 번호를 부여한다. → 요청을 할때 사용중인 번호 다음번후로만 요청을 하게 한다. 
단점 : starvation(기아상태)발생이 높아진다.
