# 4장 좋은 단위 테스트의 4대 요소

## 1. 좋은 단위 테스트의 4대 요소

- 회귀 방지
- 리팩터링 내성
- 빠른 피드백
- 유지 보수성

### 회귀 방지

> 코드를 수정한 후 기능이 의도한 대로 작동하지 않는 경우를 방지
> 

회귀는 최악은 아니지만 회귀에 대해 효과적으로 보호하기 위한 개발이 필요하다

회귀 방지 지표에 대한 테스트 점수를 평가하기 위한 사항

- 테스트 중 실행되는 코드의 양
    - 실행되는 코드가 많을수록 테스트에게 회귀가 나타날 가능성 높음
- 코드 복잡도
- 코드의 도메인 유의성
    - 단순한 코드를 테스트하는 것은 가치가 없고 중요한 비즈니스 로직만 테스트

회귀 방지 지표를 극대화하려면 테스트가 가능한 한 많은 코드를 실행해야 합니다.

### 리팩터링 내성

> 테스트를 실패로 바꾸지 않고 기본 애플리케이션 코드를 리팩터링할 수 있는 척도
> 

리팩터링 내성 지표에서는 거짓 양성이 적을수록 좋습니다.

### 거짓 양성

> 기반 코드를 수정하면 실제로 기능이 의도한 대로 작동하지만  테스트가 실패로 되는 상황
> 

**거짓 양성의 문제점**

- 테스트가 타당한 이유 없이 실패하면, 코드에 대한 능력과 의지가 희석됨
- 테스트 스위트에 대한 신뢰가 떨어지며, 믿을 수 없게 됨
- 컴파일 오류를 내지 않는 좋지 않은 거짓 양성은 정말정말 위험하다!

거지양성은 테스트와 테스트 대상 시스템(SUT)의 구현 세부 사항의 결합이 많아질 때 발생하기 때문에 해당 구현 세부사항에서 테스트를 분리해야 합니다.

→ 테스트는 SUT가 제공하는 최종 결과를 검증하는지 확인하고 나머지는 무시해야 한다.

### 리팩터링 내성 높이기

````aside
💡 테스트를 구성하기에 가장 좋은 방법 = 문제 영역에 대해 이야기하는 것
````

SUT의 구현 세부사항과 테스트 간의 결합도를 낮추는 것!!

즉, 코드의 내부 작업과 테스트 사이를 멀리 떨어뜨리고 최종 결과를 목표로 하는 것이 중요하다.

## 2. 회귀 방지와 리팩터링간의 본질적인 관계

- 회귀 방지 = 프로젝트 시작된 직후 필요
- 리팩터링 내성 = 프로젝트 시작 시 바로 필요 X

두 가지 특성은 시간이 흐르면서 프로젝트에 영향을 다르게 미치는 경향이 있다.

### 테스트 정확도 극대화

![Untitled](https://user-images.githubusercontent.com/37995685/193239592-747479ac-4997-4e80-b1f4-28c672d2550a.png)

- 참 음성: 작동 기능과 통과 테스트의 조합
    - 테스트 통과 + 기능 작동
    - 테스트 실패 + 기능 고장
- 거짓 음성
    - 테스트 통과 + 기능 고장
- 거짓 양성
    - 테스트 고장 + 기능 작동

```aside
💡 테스트 정확도 = 신호(발견되 버그수)/소음(허위 경보 발생 수)
```

회귀 방지와 리팩터링 내성은 테스트 스위트의 정확도를 극대화하는 것을 목표로 한다.

- 테스트가 버그 있음을 얼마나 잘 나타내는가 → 거짓음성(회귀 방지 영역) 제외
- 테스트가 버그 없음을 얼마나 잘 나타내는가 → 거짓 양성(리팩터링 내성 영역) 제외

### 거짓 양성과 거짓 음성

![Untitled 1](https://user-images.githubusercontent.com/37995685/193239651-0280e6f0-776a-427f-9e30-a207111eafbb.png)

프로젝트가 성장함에 따라 거짓 양성은 테스트에 큰 영향을 미치게 된다.

→ 정기적으로 리팩터링을 해야하므로 리팩터링 내성도 점점 중요해진다!!

회귀 방지는 프로젝트 성장을 유지하는데 도움이 되지만, 매우 정확한 테스트를 구축하기에 충분하지 않으므로 거짓 양성, 거짓 음성 둘 다 주의해야 한다

## 3. 세 번째 요소와 네 번째 요소: 빠른 피드백과 유지 보수성

### 빠른 피드백

단위 테스트의 필수 속성이다!!

테스트 속도가 빠를수록 테스트 스위트에서 많은 테스트를 수행하고 자주 실행 가능하다.

→ 피드백 루프를 줄여서, 버그를 수정하는 비용을 거의 0까지 줄일 수 있다.

### 유지 보수성 지표

두 가지 주요 요소로 구성되며 유지비를 평가한다.

- 테스트가 얼마나 이해하기 어려운가
    - 테스트의 크기가 작아야 좋다.
    - 테스트 코드를 일급 시민으로 취급하고 제품 코드만큼 생각하자!!
- 테스트가 얼마나 실행하기 어려운가
    - 프로세스 외부 종손성 등 의존성의 문제에서 벗어나야 한다.

## 4. 이상적인 테스트를 찾아서

- 회귀 방지
- 리팩터링 내성
- 빠른 피드백
- 유지 보수성

→ 네 가지 특성 중, 어떤 특성이라도 0이 되면 전체가 0이 된다!!! 즉 ,네 특성 다 가치가 있으려면 테스트는 네 특성 모두에서 점수를 내야 한다.

하지만,,, 특성을 정확하게 측정하는 것은 불가능하기에, 가치 추정치를 제시하여 테스트 스위트에 테스트를 계속 둘지 여부를 결정할 수 있다.

````aside
💡 테스트 코드를 포함한 모든 코드는 책임이다. 
   최소한으로 필요한 가치로 임계치를 상담히 높게 설정하고 이 임계치를 충족하는 테스트만 테스트 스위트에 남겨라
````

### 이상적인 테스트

이상적인 테스트 = 네 가지 특성 모두에서 최대 점수를 받는 테스트

회귀 방지, 리팩터링 내성, 빠른 피드백 

→ 이 세가지는 상호 배타적으로 네 가지 특성에서 최대 점수를 받는 것은 불가능하다.

### 극단적인 사례 1: 엔드 투 엔드 테스트

엔드 투 엔드 테스트의 장점

- 많은 코드를 테스트하므로 회귀 방지를 훌륭히 해낸다
- 거짓 양성 면역이 돼 리팩터링 내성 우수하다
- 어떤 특정 구현도 강요하지 않는다 → 구현 세부사항을 최대한 제거했다

하지만, 큰 단점이 있다. 바로 느린속도!!

엔드 투 엔드 테스트는 회귀 오류와 거짓 양성에 대한 보호는 좋지만, 빠른 피드백 지표는 실패한다.

### 극단적인 사례 2: 간단한 테스트

간단한 테스트의 장점

- 매우 빠르게 실행되고 빠른 피드백을 제공한다
- 거짓 양성이 생길 가능서이 낮아 리팩터링 내성도 우수하다

하지만, 기반 코드에 실수할 여지가 많지 않아 회귀를 나타내지 않는다.

심지어는 동어 반복 테스트(간단한 테스트의 이름만 바꾸는..)를 야기한다.

간단한 테스트는 우수한 리팩터링 내성과 빠른 피드백을 제공하지만 회귀 방지가 없다.

### 극단적인 사례 3: 깨지기 쉬운 테스트

깨지기 쉬운 테스트란?

실행이 빠르고 회귀를 잡을 가능성이 높지만 거짓 양성이 많은 테스트! → 리팩터링을 견디지 못한다.

```csharp
Fact]
public void GetById_executes_correct_SQL_code()
{
	var sut = new UserRepostiry();
	User user = sut.GetById(5);

	Assert.Equal(
		"SELECT * FROM dbo.[User] WHERE UserID = 5", // 만약 이 부분은 변경하면?
		sut.LastExcutedSqlStatement 
	);
}
//→ 다른 SQL문으로 변형해도 결과가 같지만 테스트는 깨질 수 있다..!!
```

깨지기 쉬운 테스트는 빠르게 실행되고 회귀 방지를 훌륭히 해내지만, 리팩터링 내성은 없다.

### 이상적인 테스트를 찾아서: 결론

![Untitled 2](https://user-images.githubusercontent.com/37995685/193239688-03db42cb-0e7e-4600-96cb-d52698bd138d.png)

위와 같이 나머지 특성 한 가지를 희생해야 하기에 전략적인 희생이 필요하다.

→ 3가지 다 조금씩 희생은 좋은 방법이 아니다.

리팩터링 내성을 포기할 수 없기에, 버그를 잘 찾아내는지(회귀 방지)와 얼마나 빠른지(빠른 피드백) 사이의 절충이 필요하다!

**리팩터링 내성을 포기할 수 없는 이유**

테스트가 이 특성을 갖고 있는지 여부는 이진 선택으로 테스트에 리팩터링 내성이 있거나 없거나 둘 중 하나이다.

````aside
💡 테스트 스위트를 탄탄하게 만들려면 테스트의 불안정성(거짓 양성)을 제거하는 것이 최 우선 과제
````

### CAP 정리

> 분산 데이터 저장소가 다음 세 가지 보증 모두를 동시에 제공할 수 없음을 나타내는 지표
> 
- 일관성: 모든 읽기가 가장 최근의 쓰기 또는 오류를 수신하는 것
- 가용성: 모든 요청이 응답을 수신하는 것
- 분할 내성: 네트워크 분할(연결 끊김)에도 시스템이 계속 작동함 (타협 불가..)

→ 해당 CAP 정리에서도 일관성과 가용성 간의 절충이 귀결된다.

## 5. 테스트 자동화

### 테스트 피라미드

> 테스트 스위트에서 테스트 유형 간의 일정한 비율을 일컫는 개념
> 
- 단위 테스트
- 통합 테스트
- 엔드 투 엔드 테스트

![Untitled 3](https://user-images.githubusercontent.com/37995685/193239731-9cf14193-ad47-4404-8ac2-92db5aea60dc.png)

- 층의 넓이: 테스트가 얼마나 보편적인지(수가 많은지) 나타냄
- 층의 높이: 최종 사용자의 동작을 어마나 유사하게 흉내 내는지 나타냄

피라미드 테스트 유형에 따라 회귀 방지, 빠른 피드백 선택

- 상단의 테스트: 회귀 방지에 유리
- 하단의 테스트: 실행 속도를 강조

→ 어떤 계층도 리팩터링 내성 포기XX

해당 비율을 각 팀과 프로젝트 마다 다를 것~~

### 엔드 투 엔드 테스트가 적은 이유

엔드 투 엔드 테스트는 빠른 피드백 지료에서 낮은 점수를 받고 유지보수성이 결여된다.

가장 중요한 기능에 적용할 때, 단위 테스트나 통합 테스트와 동일한 수준으로 보호할 때만 최소한으로 사용해야 한다.

+ 보통 단위 테스트가 더 안정적이므로 더 많이 있음!!

### 테스트 피라미드 예외

비즈니스 규칙이나 복잡도가 없는 기본적인 작업 (CRUD 등)은 피라미드가 직사각형이다.

![Untitled 4](https://user-images.githubusercontent.com/37995685/193239780-91339830-cbb3-4336-82bf-507fa9c5a058.png)

→ 단위 테스트와 통합 테스트의 수가 같고 엔드 투 엔드 테스트가 없는 직사각형 (단순한 예에서는 통합 테스트가 단위 테스트보다 많을 수 있음)

프로젝트 외부 의존성(DB 등) 하나만 연결하는 API는 엔드 투 엔드 테스트가 더 많다.

- 사용자 인터페이스 없기에 빠르게 실행됨
- 단일 외부 의존성으로 유지비도 작음

→ 기본적으로 통합 테스트와 구별할 수 없음.. 차이점은 진입점 그 뿐!

### 블랙박스 테스트

> 시스템의 내부 구조를 몰라도 시스템의 기능을 검사할 수 있는 소프트웨어 테스트 방식
> 

애플리케이션이 어떻게 하는지가 아닌, 요구 사항이나 명세사항을 중심으로 구축된다.

### 화이트 박스 테스트

> 애플리케이션의 내부 작업을 검증하는 테스트 방식
> 

테스트는 요구 사항이나 명세사항이 아닌 소스 코드에서 파생된다.

장점: 철저하다.

단점: 테스트 대상 코드의 특정 구현과 결합돼 있어 깨지기 쉽다.

### 블랙박스 테스트 vs 화이트 박스 테스트

- 블랙박스 테스트
    - 회귀 방지 pp
    - 리팩터링 내성 bb
- 화이트 박스 테스트
    - 회귀 방지 bb
    - 리팩터링 내성 pp

→ 리팩터링 내성은 타협할 수 없으니, 블랙박스 테스트를 기본으로 선택한다.

테스트를 통해 비즈니스 요구 사항으로 거슬러 갈 수 없다? == 깨지기 쉬운 테스트!!

````aside
💡 테스트를 작성할 때는 블랙박스 방법으로, 테스트를 분석할 때는 화이트 박스 방법으로!
````

## 요약

- 좋은 단위 테스트에는 자동화된 테스트를 분석하는 데 사용할 수 있는 네 가지 기본 특성이 있다.
    - 회귀 방지
    - 리팩터링 내성
    - 빠른 피드백
    - 유지 보수성
- 회귀 방지는 테스트가 얼마나 버그의 존재를 잘 나타내는지에 대한 척도다.
- 리팩터링 내성은 테스트가 거짓 양성을 내지 않고 애플리케이션 코드 리팩터링을 유지할 수 있는 정도를 의미한다.
- 거짓 양성은 기능은 의도한 대로 작동하지만 테스트는 실패하는 경우이다.
    - 테스트에 주의를 기울이지 않고, 신뢰를 잃게 되어 테스트 스위트에 치명적인 영향을 준다!
- 거짓 양성의 원인은 테스트 대상 시스템의 내부 구현 세부 사항과 테스트 간의 강결합이다.
    - 결합도를 낮추려면 테스트는 SUT가 수행한 단계가 아닌 SUT가 만든 최종 결과를 검증해야 한다.
- 거짓 양성은 프로젝트 초기에는 별로 안 보이지만 나중에는 점점 중요해 진다.!!
- 회귀 방지와 리팩터링 내성은 테스트 정확도에 기여한다.
    - 회귀 방지 = 버그를 찾을 수 있음
    - 리팩터링 내성 = 테스트가 가능함
- 빠른 피드백은 테스트가 얼마나 빨리 실행되는지에 대한 척도다.
- 유지 보수성은 두 가지 요소로 구성된다.
    - 테스트 이해 난이도 (테스트가 작을수록 쉽다.)
    - 테스트 실행 난이도 (테스트에 관련된 프로세스 외부 의존성은 적을수록 쉽다.)
- 테스트 가치 추정치는 네 가지 특성 각각에서 얻은 점수의 곱이다. (하나라도 0이라면 ….)
- 회귀 방지, 리팩터링 내성, 빠른 패드백은 상호 배탁적으로 모두 최대 점수는 불가능하다.
    - 세 가지 특성 중 두 가지만 최대화할 수 있다!!
- 리팩터링 내성은 타협할 수 없기에, 회귀 방지와 빠른 피드백 중 하나를 타협해야 한다.
    - 테스트는 리팩터링 내성을 갖고 있거나 없거나 (이진 선택)으로 타협이 불가하다.
- 테스트 피라미드는 단위 테스트, 통합 테스트, 엔드 투 엔트의 일정한 비율을 나타내고 테스트 유형마다 두 특성 중 다른 선택을 한다.
    - 엔드 투 엔드 테스트 (가장 적음)는 회귀 방지를 선호한다.
    - 통합 테스트 (중간)
    - 단위 테스트 (가장 많음)는 빠른 패드백을 선호한다.
- 테스트를 작성할 때는 블랙박스 테스트 방법을 사용해야 한다.
- 테스트를 분석할 때는 화이트박스 테스트 방법을 사용해야 한다.
- 검증문을 작성할 때 제품 코드에 의존하지 말고 테스트에서 별도의 리터럴과 상수 집합을 사용해야 한다.
