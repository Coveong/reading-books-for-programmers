# 3장 단위 테스트 구조

## AAA 패턴

> AAA 패턴
- 각 테스트를 준비, 실행, 검증으로 나누어 테스트함
> 
- 스위트 내 모든 테스트가 단순하고 균일한 구조를 갖는 데 도움을 줍니다.
- 유지보수 비용이 줄어듭니다.

### [AAA 패턴 구조]

- 준비 구절 : 테스트 대상 시스템(SUT)과 해당 의존성을 원하는 상태로 만듬
- 실행 구절 : SUT에서 메서드를 호출하고 준비된 의존성 전달하며 출력 값을 캡처
- 검증 구절 : 결과를 검증하며, 결과는 반환 값이나 SUT와 협력자의 최종 상태 등으로 표시

### [Given-When-Then 패턴]

테스트 구성 측면에서는 AAA와 Given-When-Then 패턴 사이에 차이는 없습니다.

하지만 프로그래머가 아닌 사람에게 Given-When-Then 구조가 더 읽기 쉽습니다.

### [TDD 시 AAA패턴]

기능을 개발하기 전에 실패할 테스트를 만들 때, 기능이 어떻게 동작할지 충분히 알지 못합니다.

기대하는 동작으로 윤곽을 잡은 다음, 시스템을 어떻게 개발하지 아는 것이 좋습니다.

→ 따라서, 테스트를 작성할 시점에 실행에서 무엇을 예상하는지 이미 알고 있으므로 준비 구절부터 개발합니다.

## AAA 패턴의 각 구절

### [각 구절의 크기]

- 준비 구절 : 세 구절 중 가장 크며, 실행과 검증을 합친 만큼 클 수도 있습니다.
- 실행 구절 : 보통 코드 한 줄입니다.
- 검증 구절 : 하나의 검증을 갖지는 않아도 되지만 검증 구절이 너무 커지는 것은 경계해야 합니다.

### [준비 구절]

준비 구절이 너무 많이 작성해야 한다면 별도의 메서드나 클래스로 도출한 후 테스트를 재사용하는 것이 좋습니다.

준비 구절에서 코드 재사용에 도움이 되는 패턴으로 두 가지가 있습니다.

- 오브젝트 마더
- 테스트 데이터 빌더

### [준비 구절의 재사용]

테스트 클래스에 비공개 팩토리 메서드를 만들어 재사용 할 수 있습니다.

- 공통 초기화 코드 → 팩토리 메서드로 추출

코드를 잛게 하면서, 동시에 테스트 진행 상황에 대한 전체 맥락 유지가 가능합니다.

나아가, 모든 테스트에 사용되는 필스처의 경우 인스턴스화 합니다.

- ex) 기초 클래스 생성자에서 DB연결을 초기화하는 것이 합리적

### [실행 구절의 한 줄 이상]

실행 구절이 한 줄 이상일 경우 SUT의 공개 API에 문제가 있을 수 있습니다.

> 불변 위반
- 클라이언트 코드가 1메서드를 호출하고 2메서드를 호출하지 않을 시 생기는 모순
> 

데이터베이스에 모순이 생기면 큰 문제가 발생할 수 있습니다. 이러한 불변 위반을 해결하는 방법은 코드 캡슐화를 항상 지키는 것입니다.

> 캡슐화
- 잠재적 모순으로부터 코드를 보호하는 행위
> 

유틸리티나 인프라 코드는 해당 사항이 덜 적용됩니다.

### [실행 구문의 SUT]

SUT는 애플리케이션에서 호출하고자 하는 동작에 대한 진입점을 제공하는 것으로 SUT를 의존성과 구분하는 것이 중요합니다.

→ SUT 이름을 sut로 정하면 의존성을 쉽게 분리할 수 있습니다.

### [검증 구절의 검증문]

제품 코드에서 추상화가 누락될 수 있어 검증 구절이 너무 커지는 것은 경계해야 합니다. 

SUT에서 반환된 객체 내에서 모든 속성을 검증하는 대신 객체 클래스 내에 적절한 동등 멤버를 정의해, 단일 검증문으로 객체를 기대값과 비교하는 것도 좋습니다.

### [종료 단계]

AAA 패턴에서는 이 단계를 포함하지 않지만, 일반적으로 별도의 메서드로 도출돼, 클래스 내 모든 테스트에서 재사용됩니다.

단위 테스트는 종료 구문이 필요없으며, 통합 테스트 내의 영역입니다.

## 테스트 스위트 안티 패턴

### [여러 개의 AAA 패턴 구절 피하기]

실행과 검증 구절이 여러개가 된다면 테스트는 더 이상 단위 테스트가 아닌 통합테스트로, 이러한 테스트 구조는 리팩터링이 필요합니다.

항상, 여러개의 다단계 단위 테스트를 여러 개의 테스트로 나누는 것이 좋습니다.

### [AAA 패턴 내 주석 제거하기]

각 구절 시작 전 주석을 달아 구분하는 경우도 있지만, 빈 줄로 분리하는 것이 좋습니다.

통합 테스트에는 복잡한 설정이 많은 경우가 있으니, 준비 및 검증 구절에 빈 줄을 추가하지 않아도 되는 테스트라면 주석을 제거하고 그렇지 않으면 유지하는 것이 좋습니다.

### [테스트 내 if문 피하기]

단위 테스트, 통합 테스트 모두 분기가 없는 일련의 단계여야 합니다.

if문은 테스트를 읽고 이해하는 것을 더 어렵게 만드므로 반드시 여러 테스트로 나눠야 합니다.

### [생성자 사용한 테스트 픽스처 재사용]

생성자에서 준비 구문(픽스처)을 초기화하게 되면 모든 테스트가 서로 결합돼 버립니다.

테스트는 독립적인 수정으로 다른 테스트에 영향을 주어서는 안되기 때문에, 테스트 클래스에 공유 상태를 두지 말아야 합니다.

또한, 가독성이 떨어집니다.

### [테스트명 내 테스트 대상 메서드]

테스트 이름에 SUI의 메서드 이름을 포함하지 않아야 합니다.

단위 테스트란 코드를 테스트 하는 것이 아닌 애플리케이션 동작을 테스트하는 것입니다.

## 단위 테스트 명명법

### [엄격한 단위 테스트 명명 정책]

```
[테스트 대상 메서드]_[시나리오]_[예상 결과]
```

- 테스트 대상 메서드: 테스트 중인 메서드의 이름
- 시나리오: 메서드를 테스트하는 조건
- 예상 결과: 현재 시나리어에서 테스트 대상 메서드에 기대하는 것

→ 쉬운 영어로 작성한 이름이 읽기에 훨씬 간결합니다.

### [단위 테스트 명명 지침]

- 엄격한 명명 정책을 따르지 않습니다.
- 비개발자들에게 시나리오를 설명하는 것처럼 테스트 이름을 짓습니다.
- 단어를 밑줄 표시로 구분합니다.

### [테스트 클래스 명명]

- 보통 이름이 길지 않아 밑줄 표시 없이 잘 읽을 수 있습니다.
- [클래스명]Tests 패턴을 사용하지만, 테스트가 해당 클래스만 검증하는 것으로 제한은 아닙니다.
- [클래스명]Tests 에서 클래스는 동작 단위로 검증할 수 있는 진입점 또는 API입니다.

## 매개변수화된 테스트 리팩터링

> 매개변수화된 테스트
- 유사한 테스트를 묶을 수 있는 기능을 제공
> 

유사한 사실을 단일한 테스 메소드를 묶을 수 있어 복잡해진 동작의 관리를 편리하게 해줍니다.

### [매개변수화된 테스트 문제점과 해결책]

- 문제점 : 비용이 발생하고, 나타내는 사실을 파악하지 힘들어 집니다.
- 해결책: 긍정적인 테스트 케이스는 고유한 테스트로 도출하고, 가장 중요한 부분을 잘 설명하는 이름을 쓰는 방식으로 사용해야 합니다.
    - 동작이 너무 복잡하면 매개변수화된 테스트를 조금도 사용하지 말아야 합니다.

### [매개변수화된 테스트 데이터 생성]

C#에서는 모든 특성의 내용을 컴파일 할 때 평가하기에 컴파일러가 이해할 수 있는 값만 사용해야 합니다.

- 상수
- 리터럴
- typeOf() 표현식

→ .NET 런타임에 의존하고 있는 데이터를 사용하면 테스트가 되지 않습니다.

## 검증문 라이브러리 리팩터링

검증문 라이브러리를 사용하면 검증문을 재구성해 가독성을 높을 수 있습니다.

Fluent Assertions 라이브러리는 다양한 데이터를 검증할 수 있는 수많은 헬퍼 메서드를 제공합니다.

## 요약

- 모든 단위 테스트는 AAA 패턴을 따라야 합니다.
- 실행 구절이 한 줄 이상이면 SUT의 API에 문제가 있다는 뜻입니다.
    - 잠재적인 불변 위반으로부터 코드를 보호하는 것을 캡슐화라고 합니다.
- SUT의 이름은 `sut`로 지정해 SUT를 테스트에서 구별해야 합니다.
- 테스트 픽처스 초기화 코드는 생성자에 두지 말고 팩토리 메서드를 도입해 재사용해야 합니다.
- 엄격한 테스트 명명 정책을 시행하지 말아야 합니다.
- 매개변수화된 테스트로 유사한 테스트에 필요한 코드 양을 줄일 수 있습니다.
- 검증문 라이브러리를 사용하면, 쉬운 영어처럼 읽도록 검증문에서 단어 순서를 재구성해 테스트 가독성을 향상합니다.