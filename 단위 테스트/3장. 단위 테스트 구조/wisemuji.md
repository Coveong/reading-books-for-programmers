# 단위 테스트 구조

3장에서 다루는 내용
- 단위 테스트 구조
- 좋은 단위 테스트 명명법
- 매개변수화된 테스트 작성
- Fluent Assertions 사용

## 단위 테스트를 구성하는 방법

### AAA 패턴 사용

전체 테스트 스위트의 유지 보수 비용을 줄이고 모든 테스트가 단순하고 균일한 구조를 갖는 데 도움이 된다(Given-When-Then과 유사)

- 준비: 테스트 대상 시스템(SUT)과 해당 의존성을 원하는 상태로 만든다
- 실행: SUT에서 메서드를 호출하고 준비된 의존성을 전달하며 출력 값을 캡쳐한다
- 검증: 결과를 검증한다. 반환 값이나 협력자의 최종 상태, 협력자에 호출한 메서드 등으로 표시될 수 있다

### 여러 개의 준비, 실행 검증 구절 피하기

여러 개의 동작 단위를 검증하는 테스트 형태가 되면 더 이상 단위 테스트가 아니라 통합 테스트다

### 테스트 내 if문 피하기

if문은 테스트가 한 번에 너무 많은 것을 검증한다는 표시다. 그러므로 이러한 테스트는 반드시 여러 테스트로 나눠야 한다.

테스트에 분기가 있어서 얻는 이점은 없고 단지 추가 유지비만 불어날 뿐이다.

### 각 구절은 얼마나 커야 하는가?

실행 구절은 한 줄로 두는 것이 좋다. (유틸리티나 인프라 코드는 제외) 실행 코드가 두 줄 이상이라면 캡슐화를 지키고 있는지 살펴보자.

단위 테스트를 작성할 때에는 테스트가 제품 코드의 기능을 무조건 나열하면 안된다. 오히려 애플리케이션 동작에 대해 고수준의 명세가 있어야 한다. 이상적으로 이 명세는 프로그래머뿐만 아니라 비즈니스 담당자에게도 의미가 있어야 한다.

## 테스트 간 테스트 픽스처 재사용

준비 구절에서 코드를 재사용하는 방법 중 하나로 픽스처가 있다.

픽스처의 의미(이 책에서는 첫 번째 정의를 사용함.):
1. 테스트 실행 대상 객체다. 정규 의존성 SUT로 전달되는 인수다. (예: 데이터베이스에 있는 데이터나 하드 디스크의 파일) 이러한 객체는 각 테스트 실행 전에 알려진 고정 상태로 유지하기 때문에 동일한 결과를 생성한다.
2. NUnit 테스트 프레임워크에서 사용되는 개념; 테스트가 포함된 클래스를 표시하는 특성

테스트 픽스처 초기화 코드는 생성자에 두지 말고(하나의 테스트의 문맥을 파악하기 위해 전체 코드를 읽게 되는 것을 지향하자) 팩토리 메서드를 도입해서 재사용하자. 이러한 재사용은 테스트 간 결합도를 상당히 낮게 유지하고 가독성을 향상시킨다.

## 단위 테스트 명명법

테스트가 정확히 무엇을 검증하는지, 비즈니스 요구사하오가 어떤 관련이 있는지 쉽게 파악할 수 있는 이름으로 짓자.

[Do]
```
public void Sum_of_two_numbers()
```
[Don't]
```
// 유명한 방법 중 하나: [테스트 대상 메서드]_[시나리오]_[예상 결과]
public void Sum_TwoNumbers_ReturnsSum
```

- 엄격한 명명 정책을 따르지 않는다. 복잡한 동작에 대한 높은 수준의 설명을 이러한 정책의 좁은 상자 안에 넣을 수 없다.
- 문제 도메인에 익숙한 비개발자들에게 시나리오를 설명하는 것처럼 테스트 이름을 짓자.
- 단어를 밑줄 표시로 구준한다. 그러면 특히 긴 이름에서 가독성을 향상시키는데 도움이 된다.
- 테스트 이름에 SUT의 메서드 이름을 포함하지 말라
  - 코드를 테스트하는 것이 아니라 애플리케이션 동작을 테스트하는 것이라는 점을 명심하자.
  - 동작 대신 코드를 목표로 하면 해당 코드 구현 세부 사항과 테스트 간의 결합도가 높아지고 테스트 스위트의 유지 보수성에 부정적인 영향을 준다.
  - 단 유틸리티 코드를 작업할 때에는 SUT 이름을 사용해도 된다. (비즈니스로직이 없고 단순한 보조 기능에서 크게 벗어나지 않으므로 비즈니스 담당자에게는 아무런 의미가 없다)

## 메개변수화된 테스트

메개변수화된 테스트(Parameterized Test)를 사용하면 유사한 테스트에 필요한 코드의 양을 줄일 수 있다. 단점은 테스트 이름을 더 포괄적으로 만들수록 테스트 이름이 읽기 어려워진다.
