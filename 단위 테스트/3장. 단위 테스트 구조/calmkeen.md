# 3. 단위 테스트 구조

## 1. 단위 테스트를 구성하는 방법

AAA패턴 사용

aaa 패턴은 준비, 실행 ,검증으로 나뉜다.

```swift
//Calculator라는 메서드가 있다는 가정
//응집도 있는 테스트 세트를 위한 클래스 컨테이너
public class CalculatorTests {

//테스트를 나타내는 속성
	[Fact]
//단위테스트 이름
		public void Sum_of_two_numbers() {
			//준비
			double first = 10;
			double second = 20;
			var calculator = new Calulator();
			//실행
			double result = calculator.Sum(first, second);
			//검증
			Assert,Equal(30, result);
			}
	}
```

- 준비 구절에서 테스트 대상과 해당 의존성을 원하는 상태로 만든다.
- 실행 구절에 메서드를 호출하고 준비된 의존성을 전달, 출력 값을 캡처
- 검증 구절에서 결과를 확인, 결과는 반환값이나 SUT와 협력자의 최종 상태, SUT가 협력자에 호출한 메서드 등으로 표시
* SUT(System Under Test)로 테스트 대상 시스템, 테스트하려는 대상

### 여러 개의 준비, 실행, 검증구절 피하기

검증구절이 여러개 실행된 구절은 여러개 동작 단위를  검증하는 테스트를 뜻하는데 이는 단위테스트가 아니라 통합테스트이기 떄문에 피해야 한다.

실행과 검증이 포함된 테스트를 보면 리팩터링 하라

### 테스트 내 if문 피하기

if문이 있는 테스트는 안티 패턴이다. 테스트는 분기가 없는 간단 일련의 단계여야 한다.

이런 테스트는 여러 테스트로 나누어야 한다.

### 각 구절은 얼마나 커야 하는가?

일반적으로 준비구절이 가장 크다.

준비구절의 재사용에 도움되는 두가지 패턴

- 오브젝트 마더
- 테스트 데이터 빌더

실행 구절은 보통 한 줄이다.
- 두줄이면 결과가 두가지로 나올수 있는데 이는 모순이 생길 여지가  있다.
- 이에 대한 해결책으로 캡슐화를 항상 지키는 것

### 테스트 대상 시스템 구별하기

의존성과 SUT를 구분하는 것이 중요하다.

SUT가 많은 경우 테스트 대상을 찾는 데 시간을 너무 많이 들일 필요가 없다.

이름을 sut로 하라.

### 준비, 실행 검증 주석 제거하기

테스트내에 특정 부분의 구절을 잘 구분하는것이 중요하다.

AAA패턴을 따르고 빈 줄을 추가하지 않아도 되는 테스트라면 주석을 제거하라.

위의 상황이 아니면 주석을 유지하라.

## 3. 테스트 간 테스트 픽스처 재사용

> 텍스트 픽스처
1. 테스트싫행 대상 객체
> 

텍스트 픽스처를 재사용 하는 방법

- 테스트 생성자에서 픽스처를 초기화
- 단점
- 테스트 간 결합도가 높아진다.
- 테스트 가독성이 떨어진다.
- 테스트 클래스에 비공개 팩토리 메서드를 두는 것

## 4. 단위테스트 명명법

규칙

- 엄격한 명명 정책을 따르지 않는다.
- 복잡한 동작에 대한 높은 수준의 설명을 이러한 정책의 좁은 상자 안에 넣을 수 없다. 표현의 자유를 혀용하자
- 문제 도메인에 익숙한 비개발자들에게 시나리오를 설명하는 것처럼 테스트 이름을 짓자.
- 단어를 밑줄(_)로 구분한다
- 가독성 향상

다른 팁
- 테스트 이름에 SUT의 메서드 이름을 포함하지 말라.

## 5. 매개변수화된 테스트 리팩터링하기

보통 테스트 하나로는 동작 단위를 완전히 설명하지 못한다.

이는 단위테스트 프레임워크 매개변수화 테스트를 사용해 유사 테스트를 묶는 기능으로 해결한다.

동작이 너무 복잡하면 매개변수화된 테스트를 사용하지 마라.

긍정적 테스트 케이스와 부정적 테스트 케이스모두 각각 고유 테스트 메서드로 나타내라.

## 6. 검증문 라이브러리를 사용한 테스트 가독성 향상

ex) Fluent Assertions, .NET lib

검증문 라이브러리의 이점
- 검증문을 재구성해 가독성을 높인다.

```swift
[Fact]
public void Sum_of_two_numbers() {
	var sut = new Calculator();
	double result = sut.Sum(10, 20);
	Assert.Eqaul(30,result);
}
//에서
//조금더 쉽게
[Fact]
public void Sum_of_two_numbers() {
	var sut = new Calculator();
	double result = sut.Sum(10, 20);
	result.Should().Be(30);
}
```

유일한 단점은 프로젝트에 의존성을 추가해야 하는 것
