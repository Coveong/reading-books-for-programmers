# 2장 단위 테스트란 무엇인가

## 단위 테스트의 정의

- 작은 코드 조각(단위)을 검증하고
- 빠르게 수행하고
- 격리된 방식으로 처리하는 자동화된 테스트

🤔 3번째 `격리된 방식으로 처리하는` 의 격리의 단위는?

- 이 문제로 런던파, 고전파로 나뉩니다.

### [격리 문제: 런던파]

테스트 대상 시스템을 협력자에게서 격리하는 것

즉, 하나의 클래스가 다른 클래스 또는 여러 클래스에 의존 시 모든 의존성을 테스트 대역으로 대체 하여 테스트 대상 클래스에만 집중합니다.

**장점**

- 테스트가 실패하면 코드베이스의 문제 부분은 확실히 알 수 있습니다.
- 객체 그래프를 분할할 수 있습니다.
- 프로젝트 전반적으로 한 번에 한 클래스만 테스트하라는 지침으로 전체 단위 테스트 스위트를 간단한 구조로 설계 가능합니다.

**결론**

테스트 대상 시스템에서 협력자를 격리하며, 테스트 대역(목)으로 테스트 대상 코드 조각을 분리해 격리합니다.

> SUT (System Under Test)
- 테스트 대상 시스템으로 클래스 전체를 가키림

MUT (Method Under Test)
- 테스트 대상 메서드는 테스트에서 호출한 SUT의 메서드

목
- 테스트 대상 시스템과 협력자 간의 상호 작용을 검사할 수 있는 특별한 테스트 대역
> 

### [격리 문제: 고전파]

코드를 격리하는 방식으로 테스트 하는 것이 아닌, 단위 테스트 단위로 격리합니다.

**장점**

- 테스트 순서가 없어지며, 서로의 결과에 영향이 없습니다.
- 여러 클래스를 한 번에 테스트 가능합니다.

**결론**

단위 테스트끼리 격리하며, 테스트 대역은 테스트 간 공유 상태인 의존성에 대해서만 사용합니다.

## 의존성

일반적인 클래스는 두 가지 유형의 의존성이 동작합니다.

```csharp
customer.Purchase(store, Product.Shampoo, 5);
```

- 협력자: `store`
    - 공유하거나 변경 가능한 의존성
- 값: `Product.Sampoo` `5`
    - 값 또는 값 객체로 분류되는 의존성

### [공유 의존성(shared dependency)]

- 테스트 간에 공유되고 서로의 결과에 영향을 미칠 수 있는 수단을 제공합니다.
    - ex ) 정적 가변 필드, 데이터베이스, 파일 시스템

### [휘발성 의존성(volatile dependency)]

- 개발자 머신에 기본 설치된 환경 외의 런타임 환경의 설정 및 구성을 요구합니다.
    - ex ) 데이터베이스, API 서비스
- 비결정적 동작을 포함합니다.
    - ex ) 난수 생성기, 현재 날짜 시간 반환

### [비공개 의존성(private dependency)]

- 공유하지 않는 의존성
    - ex ) 싱글턴(테스트에서 새 인스턴스를 만듬)

### [프로세스 외부 의존성(out-of-process dependency)]

- 애플리케이션 실행 프로세스 외부에서 실행되는 의존성이며, 아직 메모리에 없는 데이터에 대한 프록시 입니다.
    - ex ) 외부 read API

## 단위 테스트 의존성의 두 분파: 고전파와 런던파

### [공유 의존성 사용 이유]

- 새 파일 시스템이나, 데이터베이스 등은 테스트 간에 공유되어야 함
- 테스트 실행 속도를 높일 수 있음

### [런던파]

테스트에서 공유 의존성, 변경 가능한 비공개 의존성을 테스트 대역으로 교체할 수 있습니다.

- 절대 변하지 않는 객체, 즉 불변 객체는 교체하지 않아도 됩니다.

### [고전파]

테스트에서 공유 의존성만 테스트 대역으로 교체 가능합니다.

## 단위 테스트의 두 분파: 고전파와 런던파

정리하면 고전파, 런던파는 세 가지 주요 주제에 대해 의견 차이가 있습니다.

- 격리 요구 사항
- 테스트 대상 코드 조각의 구성 요소
- 의존성 처리

### [런던파의 장점의 문제점]

- 입자성이 좋음 (한 번에 한 클래스만 확인)
    
    → 테스트는 코드의 단위가 아닌, 동작의 단위로 검증해야 합니다.
    
- 상호 연결된 클래스의 큰 그래프를 단위 테스트하기
    
    → 크고 복잡한 그래프를 테스트할 방법(목)을 찾는 것 보단, 이러한 클래스 그래프를 갖지 않는데 집중 필요
    
    → 목을 사용하는 것은 문제를 감추기만 할 뿐, 원인 해결 못함
    
- 버그 위치 정확히 찾아내기
    
    → 보통 SUT에 버그가 포함된 테스트만 실패하기 때문에, 테스트를 정기적으로 실행하면 버그의 원인은 쉽게 찾아 낼 수 있음
    
- 과도한 명세 문제
    - 목을 전반적으로 아무 데나 쓰는 것이 문제입니다.
    - 테스트가 SUT의 구현 세부 사항에 고전파보다 더 자주 결합됩니다.

**→ 이러한 이유로 필자는 고전파를 선호합니다.**

## TDD의 두 분파: 고전파와 런던파

### [런던파]

하향식 TDD로 전체 시스템에 대한 기대치를 설정하는 상위 레벨 테스트부터 시작합니다.

1. 목을 사용해 예상 결과를 달성하고자 시스템이 통신해야 하는 협력자 지정 함
2. 모든 클래스를 구현할 때까지 클래스 그래프를 다져나감

### [고전파]

상향식 TDD로 도메인 모델을 시작으로 최종 사용자가 소프트웨어를 사용할 수 있을 때까지 계층을 위에 둡니다.

- 테스트에서 실제 객체를 다룸

## 통합 테스트의 두 분파: 고전파와 런던파

### [런던파]

- 통합 테스트: 실제 협력자 객체를 사용하는 모든 테스트

### [고전파]

> 통합 테스트
- 단위 테스트 기준 중 하나 이상을 충족하지 못하는 테스트
> 

단위 테스트는 다음과 같은 특징이 있는 자동화된 테스트 입니다.

- 단일 동작 단위를 검증하고
- 빠르게 수행하고
- 다른 테스트와 별도로 처리합니다.

통합 테스트는 시스템 전체를 검증해 소프트웨어 품질을 기여하는 데 중요한 역할을 합니다.

- 공유 의존성에 접근하는 테스트
- 프로세스 외부 의존성에 접근하는 테스트
- 둘 이상의 동작 단위를 검증할 때의 테스트

### [엔드 투 엔드 테스트]

> 엔드 투 엔드 테스트
- 통합 테스트의 일부로, 코드가 프로세스 외부 종속성과 함꼐 어떻게 작동하는지 검증
> 

유지 보수 측면에서 가장 비용이 많이 들기 때문에, 모든 단위 테스트와 통합 테스트를 통과 한 후 빌드 프로세스 후반에 실행하는 것이 좋습니다.

- 개인 개발자 머신이 아닌 빌드 서버에서만 실행 가능합니다.

**🤔엔드 투 엔드 테스트 vs 통합 테스트**

통합 테스트와 엔드 투 엔드 테스트 사이에 뚜렷한 경계는 없습니다.

- 통합 테스트: 프로세스 외부 의존성을 한두 개만 갖고 작동
- 엔드 투 엔드 테스트: 프로세스 외부 의존성을 전부 또는 대다수 갖고 동작

→ 엔드 투 엔드 명칭은 모든 외부 애플리케이션을 포함해 시스템을 최종 사용자의 관점에서 검증하는 것 의미합니다.

## 요약

- 단위 테스트의 정의
    - 단일 동작 단위를 검증하고
    - 빠르게 수행하고
    - 다른 테스트와 별도로 처리합니다.
- 격리 문제로 두 개의 단위 테스트 분파로 나뉩니다.
    - 고전파
    - 런던파
- 런던파: 테스트 대상 단위를 서로 분리해야 함을 주장합니다.
    - 테스트 대상 단위: 단일 클래스
    - 불변 의존성을 제외한 모든 의존성을 테스트 대역으로 대체해야 함
- 고전파: 단위가 아닌 단위 테스트를 서로 분리해야 함을 주장합니다.
    - 테스트 대상 단위: 동작
    - 공유 의존성만 테스트 대역으로 대체해야 함
- 런던파의 문제점
    - 테스트는 코드단위가 아닌 동작 단위 검증 필요
    - 코드 조각을 단위 테스트 할 수 없음 = 코드 설계 문제 알려주는 강한 징후
    - 테스트 실행 후 버그 판단하는 것은 도움 되지만, 버그의 원인을 알고 있는 경우 있어 큰 문제 없음
    - 과잉 명세, 즉 SUT 세부 구현에 결합된 테스트가 문제
- 통합 테스트는 단위 테스트 기준 중 하나 이상을 충족하지 못하는 테스트
    - 엔드 투 엔드 테스트