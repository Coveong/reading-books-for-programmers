# 단위 테스트 스타일

## 단위 테스트의 세 가지 스타일

- 출력 기반 테스트: 테스트 대상 시스템(SUT)에 입력을 공급하고 그것이 생성하는 출력을 확인
- 상태 기반 스타일: 작업이 완료된 후 시스템의 상태를 확인
  - 상태라는 용어는 SUT 자체, 협력자 중 하나 또는 데이터베이스나 파일 시스템과 같은 out-of-process 종속성의 상태를 나타낼 수 있다
- 통신 기반 스타일: SUT의 협력자를 목으로 대체하고 SUT가 해당 협력자를 올바르게 호출하는지 확인

## 단위 테스트 스타일 비교

### 리팩터링 내성 지표로 스타일 비교하기

리팩터링 중에 발생하는 거짓 정보 수에 대한 척도로 비교하기

### 유지 보수성 지표로 스타일 비교하기

테스트를 이해/실행하기 얼마나 어려운가에 대한 척도로 비교하기

![image](https://user-images.githubusercontent.com/32327475/195033014-d1d015ea-788b-4047-9c42-efaf1c89d2f5.png)

## 함수형 아키텍처 이해

### 함수형 프로그래밍

호출 횟수에 상관없이 주어진 입력에 대해 동일한 출력을 만드는(숨은 입출력이 없는) '수학적 함수'를 활용한 프로그래밍

숨은 입출력의 종류:
- 사이드 이펙트(메소드 시그니처에 표시되지 않은 출력)
- 예외
- 내부 또는 외부 상태에 대한 참조

### 함수형 아키텍처

- 가변 셀은 기능 코어에 입력 데이터를 제공하고 데이터베이스와 같은 프로세스 외 종속성에 사이드 이펙트를 적용하여 결정을 해석한다.
- 비즈니스 로직을 처리하는 코드와 사이드 이펙트를 일으키는 코드를 분리하는 것

![image](https://user-images.githubusercontent.com/32327475/195035191-eb1415e5-f8fa-4999-9ec1-4875e98a1e95.png)

### 캡슐화

> 객체 지향 프로그래밍은 움직이는 부분을 캡슐화하여 코드를 이해하기 쉽게 만든다. 함수형 프로그래밍은 움직이는 부분을 최소화하여 코드를 이해하기 쉽게 만든다. - Michael Feathers

### 함수형 아키텍처와 육각형 아키텍처 비교

함수형 아키텍처와 육각형 아키텍처의 차이점은 사이드 이펙트를 처리하는 데 있다.

함수형 아키텍처는 모든 사이드 이펙트를 도메인 계층 밖으로 밀어낸다. 반대로 육각형 아키텍처는 도메인 레이어에만 국한되는 한, 도메인 레이어에 의한 사이드 이펙트가 있어도 괜찮다.

![image](https://user-images.githubusercontent.com/32327475/195035679-ab7eccad-75ad-4df5-a621-081eb3bc387d.png)


## 함수형 아키텍처와 출력 기반 테스트로 전환

### 감사 시스템 소개

다음 두 프로세스를 통해 전환해보자

- 프로세스 외부 의존성에서 목으로 변경
  - 목으로 변경하면 더 이상 파일 시스템에 접근하지 않으므로 더 빨리 실행되고 유지비도 절감된다.
- 목에서 함수형 아키텍처로 변경
  - 입출력만 필요하므로 목을 사용했을때에 비해 테스트 가독성이 크게 향상된다.

![image](https://user-images.githubusercontent.com/32327475/195035893-393a69c4-ab49-4e41-a98a-b02e50add24a.png)

### 함수형 아키텍처의 단점 이해하기

- 함수형 아키텍처와 전통적인 아키텍처 간의 선택은 '성능'과 '코드 유지 관리 가능성' 간의 절충점이다. 함수형 아키텍처는 유지 보수성 향상을 위해 성능을 양보합니다.
- 모든 코드 베이스가 함수형 아키텍처로 변환할 가치가 있는 것은 아니다. 함수형 아키텍처를 전략적으로 적용하자.
  - 시스템의 복잡성과 중요성을 고려하자. 단순하거나 중요하지 않은 코드에서는 함수형 아키텍처에 필요한 초기 투자 비용이 불필요하다.
