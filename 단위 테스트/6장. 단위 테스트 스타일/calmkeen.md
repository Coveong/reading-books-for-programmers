# 6.단위 테스트 스타일

## 6.1 단위 테스트의 세 가지 스타일

- 출력 기반 테스트(output-based testing)
- 상태 기반 테스트(state-based testing)
- 통신 기반 테스트(communication-based testing)

6.1.1 출력 기반 테스트 정의

테스트 대상 시스템(SUT)에 입력을 넣고 생성되는 출력을 점검하는 방식

전역 상태나 내부 상태를 변경하지 않는 코드에만 적용되므로 반환값만 검증하면 됨

출력 기반 단위 테스트 스타일은 함수형이라고도 한다.

![6장1](https://user-images.githubusercontent.com/78361650/195020338-41a1483f-c88c-48be-af93-788b82b0a2fe.png)


### 6.1.2 상태 기반 스타일 정의

작업이 완료된 후 시스템 상태를 확인하는 것이다. 이 테스트 스타일에서 상태라는 용어는  SUT나 협력자 중 하나, 또는 데이터베이스나 파일 시스템등 과 같은 프로세스 외부 의존성의 상태 등을 의미할 수 있다.

작업이 완료된 후 시스템의 최종 상태를 검증한다. 빗금이 그려진 원이 최종 상태를 나타낸다.

![6장 2](https://user-images.githubusercontent.com/78361650/195020327-959c7841-0fe6-4819-9419-17e859740458.png)


### 6.1.3 통신 기반 스타일 정의

목을 사용해 테스트 대상 시스템과 협력자 간의 통신을 검증하고 협력자의 목을 대체한다.

> 스타일과 단위 테스트 분파
 단위 테스트의 고전파는 통신 기반 스타일보다 상태 기반 스타일을 선호한다. 런던파는 이와 반대로 선택한다. 두 분파는 출력 기반 테스트를 사용한다.
> 

## 6.2 단위 테스트 스타일 비교

좋은 단위테스트의 4대 요소

- 회귀 방지
- 리팩터링 내성
- 빠른 피드백
- 유지 보수성

### 6.2.1 회귀 방지와 피드백 속도 지표로 스타일 비교하기

회귀 방지 지표는 세 가지 특성으로 결정된다.

- 테스트 중에 실행되는 코드의 양
- 코드 복잛도
- 코드 도메인

테스트 스타일과 테스트 속도 사이에는 상관관계가 거의 없다.

테스트가 프로세스 외부 의존성과 떨어져 단위 테스트 영역에 있는 한, 모든 스타일은 테스트 실행 속도가 거의 동일하다.

### 6.2.2 리팩터링 내성 지표로 스타일 비교하기

리팩터링 내성은 리팩터링 중에 발생하는 거짓 양성수에 대한 척도다. 거짓양성은 식별할 수 있는 동작이 아니라 코드 구현 세부 사항에 결합된 테스트의 결과이다.

상태 기반 테스트는 일반적으로 거짓 양성이 되기 쉽다.상태 기반 테스트는 api 노출 영역에 의존하므로, 구현 세부 사항과 결합할 가능성도 더 높다.

통신 기반 테스트가 허위 경보에 가장 취약하다.캡슐화를 잘 지키고 테스트를 식별할 수 있는 동작에만 결합하면 거짓 양성을 최소로 줄일 수 있다.

### 6.2.3 유지 보수성 지표로 스타일 비교하기

단위테스트 스타일과 밀접한 관련이 있다.

유지 보수성은 단위 테스트의 유지비를 측정한다.

- 테스트를 이해하기 얼마나 어려운가(테스트 크기에 대한 함수)?
- 테스트를 실행하기 얼마나 어려운가(테스트에 직접적으로 관련 있는 프로세스 외부 의존성개수에 대한 함수)?

출력 기반 테스트의 기반 코드는 전역 상태나 내부 상태를 변경할 리 없으므로, 프로세스 외부 의존성을 다루지 않는다. 따라서 두가지  유지 보수성 모두의 측면에서 출력 기반 테스트가 가장 좋다. ⇒ 반대 ( 상태기반 테스트 )

### 6.2.4 스타일 비교하기 : 결론

|  | 출력 기반 | 상태 기반 | 통신 기반 |
| --- | --- | --- | --- |
| 리팩터링 내성 지키기위한 노력 | 낮음  | 중간 | 중간 |
| 유지비 | 낮음 | 중간 | 높음 |

출력기반 테스트가 가장 좋다.

## 6.3 함수형 아키텍처 이해

출력 기반 단위 테스트 = 함수형

### 6.3.1 함수형 프로그래밍이란?

함수형 프로그래밍은 수학점 함수 (mathmatical function)을 사용한 프로그래밍이다. 수학적 함수는 숨은 입출력이 없는 함수이다.

수학적 함수의 모든 입출력은 메서드 이름, 인수, 반환 타입으로 그성된 메서드 시그니쳐를 명시해야 한다.

```swift
//    ⌜--------------메서드 시그니쳐------------------⌝
//       출력         이름               입력 
public decimal CalculateDiscount(Product[] products)
{
	decimal discount - products.Length * 0.01m;
	return math.Min(discount, 0.2m);
}

```

> 수학에서의 함수는 첫 번째 집합의 각 요소에 대해 두 번째 집합에서 정확히 하나의 요소를 찾는 두 집합 사이의 관계다.
> 

입출력을 명시한 수학적 함수는 짧고 간결하며 이해하기 쉬워 테스트가 쉽다.

반면 숨은 입출력은 코드를 테스트하기 힘들게 한다.

유형

- 부작용 : 부작용은 메서드 시그니처에 표시 되지 않은 출력이며,따라서 숨어있다.연산은 클래스 인스턴스의 상태를 변경하고 디스크의 파일을 업데이트하는 등 부작용을 발생시킨다.
- 예외: 메서드가 예외를 던지면, 프로그램 흐름에 메서드 시그니처에 설정된 계약을 위회한느 경로를 만든다. 호출된 예외는 호출 스택의 어느 곳에서도 발생할 수 있으므로, 시근처가 전달하지 않는 출력을 추가한다.
- 내외부 상태에 대한 참조: 정적 속성을 사용해 데이터베이스에 데이터를 질의할 수 있고, 비공개 변경 가능 필드를 참조할 수도 있다. 이 모두 메서드 시그니처에 없느 실행 흐름에 대한 입력이며, 따라서 숨어있다.

### 6.3.2 함수형 아키텍처란?

함수형 프로그래밍의 목표는 부작용을 완전히 제거하는 것이 아니라 **비즈니스 로직을 처리하는 코드와 부작용을 일으키는 코드를 분리하는 것**이다.

[ 분리방법 ]

- 결정을 내리는 코드: 이코드는 부작용이 필요 없기 때문에 수학적 함수를 사용해 작성할 수 있다.
- 해당 결정에 따라 작용하는 코드: 이 코드는 수학적 함수에 의해 이뤄진 모든 결정을 데이터베이스의 변경이나 메시지 보스로 전송된 메시지와같이 가시적인 부분으로 변환한다.

결정을 내리는 코드는 함수형 코어라고 하고 해당 결정에 따라 작용하는 코드는 가변 셸 이다.

![6장 3](https://user-images.githubusercontent.com/78361650/195020469-d0ac6d92-d09d-44e5-9255-c44609596572.png)


함수형 코어와 가변 셸은 다음과 같은 방식으로 협력한다.

- 가변 셸은 모든 입력을 수집한다.
- 함수형 코어는 결정을 생성한다.
- 셸은 결정을 부작용으로 변환한다.

가변셸은 가능한 아무 말도 하지 않아야 한다. 즉 의사결정을 추가하지 않게끔 결정 클래스에 정보가 있는지 확인해야한다.

목표는 출력 기반 테스트로 함수형 코어를 두루 다루고 가변 셸을 훨씬 더 적은 수의 통합 테스트에 맡기는 것이다.

> 객체지향 프로그래밍은 작동 부분을 캡슐화해 코드를 이해할 수 있게 한다. 함수형 프로그래밍은 작동 부분을 최소화해 코드를 이해할 수 있게 한다. - 마이클 페더스-
> 

### 6.3.3 함수형 아키텍쳐와 육각형 아키텍처 비교

유사점 : 관심사 분리,의존성 간의 단방향 흐름

차이점 : 부작용에 대한 처리

## 6.4 함수형 아키텍처와 출력 기반 테스트로의 전환

리팩터링 단계

- 프로세스 외부 의존성에서 목으로 변경
- 목에서 함수형 아키턱처로 변경

![6장 4](https://user-images.githubusercontent.com/78361650/195020486-4dd6d54f-e253-47ea-88b9-f36490526365.png)


예상되는 추가 개발

- 작업 디렉터리가 비어있는 경우 새로운 파일 작성
- 기존 파일에 새 레코드 추가
- 현재 파일의 항목 수가 한도를 초과할 떄 다른 파일 작성

## 6.5 함수형 아키텍처의 단점 이해하기

실행 흐름이 간단하지 않다. 의사 결정 준간 결과에 따라 프로세스 외부 의존성에서  추가 데이터를 질의할 수 도 있따.

### 성능의 단점

테스트의 성능이 문제가 아닌 시스템이 외부 의존성을 더 많이 호출하고 , 그결과로 성능이 떨어진다.

### 코드베이스 크기 증가

코어와 가변 셸 사이를 명확하게 분리해야 한다. 궁극적으로 코드 복잡도가 낮아지고 유지 보수성이 향상되지만 초기에 코딩이 더 필요하다.

함수형 방식에서 순수성에 많은 비용이 든다면 순수성을 따르지 말라.
