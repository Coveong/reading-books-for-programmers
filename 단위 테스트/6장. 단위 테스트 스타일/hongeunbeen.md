# 6장 단위 테스트 스타일

## 1. 단위 테스트의 세 가지 스타일

- 출력 기반 테스트 (output-based testing)
- 상태 기반 테스트 (state-based testing)
- 통신 기반 테스트 (communication-based testing)

하나의 테스트에서 세 가지 스타일 모두 함께 사용 가능합니다.

### 츨력 기반 테스트

<aside>
💡 테스트 대상 시스템(SUT)에 입력을 넣고 생성되는 출력을 점검하는 방식

</aside>

전역 상태나 내부 상태를 변경하지 않는 코드에만 적용되므로 반환값만 검증하면 됩니다.

```csharp
public class PriceEngine
{
	public decimal CalculateDiscount(params Product[] products){
		decimal discount = products.Length * 0.01m;
		return Math.Min(discount, 0.2m);
	}
}

[Fact]
public void Discount_of_two_products()
{
	var product1 = new Product("Hand wash");
	var product2 = new Product("Shampoo");
	var sut = new PriceEngine();

	decimal discount = sut.CalculateDiscount(product1, product2);

	Assert.Equal(0.02m, discount);
}
```

함수형이라고도 하며 부작용 없는 코드 선호를 강조하는 프로그래밍 방식입니다.

### 상태 기반 스타일 정의

<aside>
💡 작업이 완료된 후 시스템의 최종 상태를 확인하는 방식

</aside>

상태란, SUT나 협력자 중 하나, 또는 데이터에비스나 파일 시스템 등과 같은 프로세스 외부 의존성 등 의미합니다.

```csharp
public class Order
{
	private readonly List<Product> _products = new List<Product>();
	public IReadOnlyList<Product> Projects => _products.ToList();

	public void AddProduct(Product product)
	{
		_products.Add(product);
	}
}

[Fact]
public void Adding_a_product_go_an_order()
{
	var product = new Product("Hand Wash");
	var sut = new Order();
	
	sut.AddProduct(product); //결과(주문 상태 변경)

	Assert.Equal(1, sut.Products.Count);
	Assert.Equal(product, sut.Products[0]); //주문 상태 자체를 검증
}
```

### 통신 기반 스타일 정의

<aside>
💡 목을 사용해 테스트 대상 시스템과 협력자 간의 통신을 검증하는 방식

</aside>

SUT의 협력자를 목으로 대체하고 SUT가 협력자를 올바르게 호출하는지 검증합니다.

```csharp
[Fact]
public void Sending_a_greetings_email()
{
	var emailGatewayMock = new Mock<IEmailGateway>();
	var sut = new Controller(emailGatewayMock.Obejct);

	sut.GreetUser("user@email.com");

	emailGatewayMock.Verity(
		x => x.SendGreetingsEmail("user@email.com"),
		Times.Once);
}
```

## 2. 단위 테스트 스타일 비교

- 회귀 방지
- 리팩터링 내성
- 빠른 피드백
- 유지 보수성

좋은 단위 테스트의 4대 요소를 비교해보겠습니다.

### 회귀 방지와 피드백 속도 지표로 스타일 비교

회귀 방지 지표는 특정 스타일에 따라 달라지지 않고 밑의 세 가지 특성으로 결정됩니다.

- 테스트 중에 실행되는 코드의 양
- 코드 복잡도
- 도메인 유의성

테스트 스타일과 테스트 피드백 속도 사이에는 상관관계가 거의 없습니다. 하지만, 목은 런타임에 지연 시간이 생기는 편이므로 통신 기반 테스트가 약간 나쁠 수 있습니다.

### 리팩터링 내성 지표로 스타일 비교하기

출력 기반 테스트는 테스트가 SUT에만 결합되므로 거짓 양성 방지가 가장 우수합니다.

상태 기반 테스트는 일반적으로 테스트와 제품 코드 간의 결합도가 터서 거짓 양성이 발생하기 쉽습니다.

통신 기반 테스트는 SUT로 상호 작용을 확인하는 테스트로 허위 경보에 가장 취약합니다. 통신 기반 테스트는 상호 작용의 부장용이 외부 환경에 보이는 경우에만 목을 ㅅ용해야 합니다.

### 유지 보수성 지표로 스타일 비교하기

유지 보수성 지표는 단위 테스트 스타일과 밀접한 관련이 있습니다.  유지 보수성은 단위 테스트의 유지비를 측정하며, 특성을 두 가지로 정의합니다.

- 테스트를 이해하기 얼마나 어려운가?
- 테스트를 실행하기 얼마나 어려운가?

출력 기반 테스트가 가장 유지보수하기 용의하며, 상태 기반 테스트는 이보다는 어렵습니다. 이를 극복하지 위해서는 헬퍼 메서드를 사용하거나, 검증 대상 클래스의 동등 멤버를 정의해야 합니다.

### 스타일 비교하기: 결론

|  | 출력 기반 | 상태 기반 | 통신 기반 |
| --- | --- | --- | --- |
| 리팩터링 내성 위한 노력 | 낮음 | 중간 | 중간 |
| 유지비 | 낮음 | 중간 | 높음 |

출력 기반 테스트가 모든 지표가 가장 좋고, 상태 기반 테스트와 통신 기반 테스트는 지표가 좋지 않습니다. 

항상 다른 것보다 출력 기반 테스트를 선호해야 합니다. 

## 3. 함수형 아키텍처 이해

### 함수형 프로그래밍이란?

> 수학적 함수를 사용한 프로그래밍
> 

<aside>
💡 수학적 함수는 숨은 입출력이 없는 함루고 모든 입출력은 메서드 이름, 잇누, 반환 타입으로 구성된 메서드 시그니터에 명시해야 하고 호출 횟수에 상관없이 주어진 입력에 대해 동일한 출력을 생성한다.

</aside>

입출력을 명시한 수학적 함수는 이에 따르는 테스트가 짧고 간결하며 이해하고 유지보수하기 쉬우므로 테스트 하기가 매우 쉽다!

→ 출력 시반 테스트를 적용할 수 있는 메서드 유형은 수학적 함수 뿐!!

### 숨은 입출력

- 부작용
- 예외
- 내외부 상태에 대한 참조

### 함수형 아키텍처란?

> 부작용을 다루는 코드를 최소화하면서 순수 함수(불변) 방식으로 작성한 코드의 양을 극대화 함
> 

함수형 아키텍처는 부작용을 비즈니스 연간 끝으로 몰아서 비즈니스 로직과 부작용을 분리합니다.

- 결정을 내리는 코드(함수형 코어): 부작용이 필요 없기 때문에 수학적 함수를 사용할 수 있습니다.
- 해당 결정에 따라 작용되는 코드(가변 셸): DB의 변경이나 메시지 버스로 전송된 메시지와 같이 가시적인 부분으로 변환합니다.

함수형 코어와 가변 셸을 다음과 같은 방식으로 협력합니다.

- 가변 셰을 모든 입력을 수집함
- 함수형 코어는 결정을 생성함
- 셸을 결정을 부작용으로 변환함

해당 계층이 잘 분리되려면, 가변 셸이 의사 결정을 추가하지 않게끔 결정을 나타내는 클래스에 정보가 충분히 있는 확인해야 합니다. (가별 셸을 아무 말도 하지 않아야 합니다.)

### 함수형 아키텍처와 육각형 아키텍처 비교

둘 다 관심사 분리라는 아이디어를 기반으로 하고 의존성 간의 단방향 흐름을 나타냅니다.

둘의 차이점은 부작용 처리에 있습니다.

- 함수형 아키텍처: 모든 부작용을 불변 코어에서 비즈니스 연산 가장자리로 밀어냅니다.
- 육각형 아키텍처: 도메인 계층에 제한하는 한, 도메인 계층으로 인한 부작용도 문제 없습니다.

<aside>
💡 함수형 아키텍처는 육각형 아키텍처의 하위 집합입니다.

</aside>

## 4. 함수형 아키텍처와 출력 기반 테스트로의 전환

리팩터링 단계는 총 두 단계 입니다.

- 프로세스 외부 의존성에서 목으로 변경
- 목에서 함수형 아키텍처로 변경

|  | 초기 버전 | 목 사용 | 출력 기반 |
| --- | --- | --- | --- |
| 회귀 방지 | 좋음 | 좋음 | 좋음 |
| 리팩터링 내성 | 좋음 | 좋음 | 좋음 |
| 빠른 피드백 | 나쁨 | 좋음 | 좋음 |
| 유지 보수성 | 나쁨 | 중간 | 좋음 |

## 5. 함수형 아키텍처의 단점

### 적용 가능성이 낮음

메서드가 수학적 함수가 될 수 없다면 출력 기반 테스트를 적용할 수 없습니다.

### 성능 단점

출력 기반 테스트는 목을 사용한 테스트만큼 빠르게 작동합니다. 함수형 아키텍처와 전통적인 아키텍처 사이의 선택은 성능과 코드 유지 보수성 간의 절충입니다. 성능 영향이 크지 않다면 일부 시스템에서 함수형 아키텍처를 사용해 유지 보수성을 향상시키는 편이 좋습니다.

### 코드 베이스 크기 증가

함수형 아키텍처는 함수형 코어와 가변 셸 사이를 명확하게 분리해야 합기에 코딩이 더 필요합니다. 

만약, 함수형 방식에서 순수성에 많은 비용이 든다면 순수성을 따르지 말고 출력 기반 스타일과 상태 기반 스타일을 조합해서 사용하는 것이 좋습니다.

## 6. 정리

- 출력 기반 테스트: SUT에 입력을 주고 출력을 확인하는 테스트 스타일
    - 테스트 품질이 가장 좋음
- 상태 기반 테스트: 작업이 완료된 후의 시스템 상태를 확인
    - 안정성을 위해 신중해야 함
- 통신 기반 테스트: 목을 사용해 테스트 대상 시스템과 협력자 간의 통신을 검증
    - 안정성을 위해 신중해야 함
- 고전파 vs 런던파
    - 고전파: 통신 기반 스타일 < 상태 기반 스타일
    - 런던파: 통신 기반 스타일 > 상태 기반 스타일
    - 두 분파 모두 출력 기반 스타일 사용함!
- 함수형 프로그래밍: 수학적 함수로 된 프로그래밍으로 비즈니스 로직과 부작용을 분리하는 것
- 수학적 함수: 숨은 입출력이 없는 함수로 명시적이므로 테스트 용이성을 높임
    - 숨은 출력: 부작용과 예외
    - 숨은 입력: 내부 상태 또는 외부 상태에 대한 참조
- 함수형 아키텍처: 부작용을 비즈니스 연산의 가장자리로 밀어내 분리를 이루는데 도움
    - 함수형 코어
    - 가변 셀: 입력 데이터를 함수형 코어에 공급 + 코어가 내린 결정 부작용으로 변환
- 함수형 아키텍처 vs 육각형 아키텍처
    - 차이점: 부작용 처리
    - 함수형 아키텍처: 모든 부작용을 계층 밖으로 밀어냄
    - 육각형 아키텍처: 도메인 계층에만 한정돼 있는 한 도메인 계층에 의해 만들어진 부작용 OK
- 함수형 아키텍처 vs 전통적인 아키텍처
    - 선택에 있어서 성능과 코드 유지 보수성 사이의 절충이 필요
    - 함수형 아키텍처는 유지보수성 향상을 위해 성능을 희생함
- 모든 코드베이스를 함수형 아키텍처로 전환은 불가능!
    - 시스템의 복잡도와 중요성을 고려해 함수형 아키텍처를 전략적으로 적용하자