# 8.통합테스트를 하는 이유

## 8.1  통합 테스트는 무엇인가?

단위테스트는 

- 단일 동작 단위를 검증하고
- 빠르게 수행하고
- 다른 테스트와 별도로 처리한다.

라고 앞장에서 배웠는데 이 요구사항중 하나라도 충족하지 못하면 통합 테스트 범주에 속한다.

통합테스트는..

대부분 시스템이 프로세스 외부 의존성과 통합해 어떻게 작동하는지를 검증한다.

단위테스트는 도메인 모델을 다루지만, 통합 테스트는 프로젝트 외부 의존성과 도메인 모델을 연결하는 코드를 확인한다.

단위테스트와 통합 테스트간의 균형을 유지하는것이 중요하다.

통합테스트는  프로세스 외부 의존성에 직접 작동하면 느리지며 이러한 테스트는 유지비가 많이 들지만 테스트 코드를 많이 거치므로 회귀 방지가 단위테스트보다 우수하다.

단위테스트로 가능한 많이 비지니스 시나리오의 예외 상황을 확인하고, 통합테스트로 주요 흐름과 단위테스트에서 다룰수 없는 예외 상황을 다룬다.

![8 1](https://user-images.githubusercontent.com/78361650/196023817-3016c10f-2a4f-4ed7-8449-8c0239ea7639.png)

대부분의 프로젝트 피라미드 

통합 테스트에서 프로세스 외부 의존성과의 상호작용을 확인하려면 가장 긴 흐름을 선택하라.

빠른 실패의 원칙

얘치 않은 오류가 발생하자마자 연산을 중단하는것

- 피드백 루프 단축 : 버그를 빨리 발견할수록 더 쉽게 해결할 수 있다. 이미 운영 환경으로 넘어온 버그는 개발 중에 발견된 버그보다 비용이 훨씬 크다.
- 지속성 상태 보호: 버그는 애플리케이션 상태를 손상시킨다. 손상된 상태가 db로 침투하면 더 어려워진다.

## 8.2 어떤 프로세스 외부 의존성을 직접 테스트해야 하는가?

검증방식

- 실제 프로세스 외부 의존성을 사용
- 의존성을 목으로 대체하는 것

프로세스외부 의존성의 범주

- 관리 의존성( 전체를 제어할 수 있는 프로세스 외부 의존성) : 애플리케이션을 통해서면 접근할 수 있으며, 상호작용은  외부에서 볼 수 없다. 외부 시스템은 보통 api를 통해 접근한다. ex) DB
- 비관리 의존성(전체를 제허라수 없는 프로세스 외부 의존성): 상호작용을 외부에서 볼 수 있다. 다른 애플리케이션에서 볼수있는 부작용을 발생시킨다. ex)  STMP message service

DB가 이미 공유 되고 있고, 할수 있는게없다면?

다른 애플리케이션에서 볼수 있는 테이블을 비관리 의존성으로 취급하라. 테이블을 이요한 통신 패턴이 바뀌지 않도록 목을 사용하라. 나머지 db관리를 의존성을 처리하고 상호작용을 검증하지 말고, 최종상태를 확인하라.

통합테스트에서 실제 db를 사용할수 없다면?

이런경우도 목으로? X

테스트 할수 없다면, 통합 테스트를 작성하지 말고 도메인 모델의 단위 테스트만 집중하라. 가치가 충분하지 않은 테스트는 테스트 스위트에 있으면 안된다.

## 8.3 통합 테스트  예제

![8 2](https://user-images.githubusercontent.com/78361650/196023830-6008996c-d963-4006-9ee7-19000565ab25.png)

컨트롤러는 데이터베이스, 메시지 버스, 도메인 모델 간의 작업을 조정한다.

## 8.4 의존성 추상화를 위한 인터페이스 사용

인터페이스를 사용하는 일반적인 이유는 

- 프로세스 외부 의존성을 취상화해 느슨한 결합을 달성하고
- 기존 코드를 변경하지 않고 새 기능을 추가해 폐쇄 원칙을 지키기 위해서 이다.

하지만두번째 이유는 하지만 기본적인 원칙 YAGNI을 위배한다. ( YAGNI현재 필요하지 않은 기능에 시간을 들이지 말라.)

2번과 같은 방식은 기회비용이 낭비되고, 프로젝트 소유 비용이 불필요하게 증가한다.

인터페이스에 구현이 하나만 있을때도 외부 의존성에 인터페이스를 사용하는 이유는?

Mock을 사용하기 위함이다.인터페이스가 없으면 테스트 대역을 만들 수 없으므로 테스트 대상 시스템과 프로세스 외부 의존성 간의 상호 작용을 확인할 수 없다.

인터페이스를 두지 말고,관리 의존성을 컨트롤러에 명시적으로 주입하고,해당 의존성을 구체 클래스로 사용하라.

## 8.5 통합 테스트 모범 사례

통합테스트의 도움되는 일반적인 지침

- 도메인 모델 경계 명시하기
- 애플리케이션 내 계층 줄이기
- 순환 의존성 제거하기

항상 도메인 모델을 코드베이스에서 명시적이고 잘 알려진 위치에 두도록 해라.

다양한 애플리케이션 문제는 떄떄로 별도의 간접 계층으로 해결된다.

![8 3](https://user-images.githubusercontent.com/78361650/196023844-0acd3372-dc1f-42ad-97ec-70b4d433910b.png)

추상화가 지나치게 많으면 단위 테스트와 통합 테스트에 도움이 되지 않는다.

가능한 간접 계층을 적게 사용하라. 대부분 백엔드 시스템에서는 도메인 모델, 애플리케이션 서비스,인프라 계층 , 정도만 알면된다.

또 코드베이스의 유지 보수성을 대폭 개선하고 테스트를 더 쉽게 할 수 있는 방법으로 순환 의존성을 제거 하는 것이 있다. ex) callback

**테스트에 다중 실행 구절 사용**

- 준비 : 사용자 등록에 필요한 데이터 준비
- 실행 : userController.RegisterUser()호출
- 검증 : 등록이 성곡적으로 완료됐는지 확인하기 위해 데이터 베이스 조회
- 실행 : userController.DeleteUser()호출
- 검증 : 사용자가 삭제됐는지 확인하기 위해 데이터베이스 조회

이러한 방식은 사용자의 상태가 자연스럽게 흐르기에 설득력 있고, 각자의 준비단계가 될수 있따.

각 실행을 고유 테스트로 추출해 나누는 것이 좋다.

## 8.6 로깅 기능을 테스트하는 방법

**로그인  기능을 테스트 해야 하는가?**

로그인은 사용자의 중요한 정보를 생성하는 부분이다. 동작에서 중요한 부분이다.

반드시 테스트 해야하는데, 두가지 로그인 유형으로  설명한다.

- 지원 로깅은 지원 담당자나 시스템 관리자가 추적할 수 있는 메시지를 생성한다.
- 진단로깅은 개발자가 애플리케이션 내부 상황을 파악할 수 있도록 돕는다.

지원로깅을 프로세스 외부 의존성으로 작동하느 다른 기능처럼 취급하라.

로깅에는 프로세스 외부 의존성이 있기 떄문에 로그 저장소 간의 정욕을 검증하려면 목을 써야 한다.

하지만 user나 다른 도메인 크랠스에서 진단 로깅은 사용하지 말라.

로깅은 과도한 사용은 코드를 혼란스럽게 하고, 로그인의 핵심은 신호 대비 잡음 비율이기에 신호를 최대로 늘리고 잡음을 최소로 줄여라.

## 8.7 결론

식별할 수 있는 동작인지, 아니면 구현 세부 사항인지 의존성과 통신을 살펴보자. 개발자가 아닌 사람이 로그를 볼 수 있으면 기능을 목으로 하고 아니면 테스트하지 말라.
