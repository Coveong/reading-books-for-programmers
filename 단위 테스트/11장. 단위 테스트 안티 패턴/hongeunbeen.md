# 11장 단위 테스트 안티 패턴

## 1. 비공개 메서드 단위 테스트

단위 테스트를 위해 비공개 메서드를 노출하면 테스트가 구현 세부 사항과 결합되고 결과적으로 리팩터링 내성이 떨어집니다. 비공개 메서드를 테스트 하는 것 자체는 나쁘지 않지만 구현 세부 사항의 프록시에 해당하므로 좋지 않습니다.

🤔 비공개 메서드를 테스트하는 방법은 없을까요?

🗨 비공개 테스트를 직접 테스트하는 대신, 식별할 수 있는 동작으로 간접적으로 테스트하는 방법이 있습니다.

### 비공개 메서드와 불필요한 커버리지

만약, 비공개 메서드가 복잡하여 식별할 수 있는 동작으로도 테스트하기 어렵다면 두 가지 문제가 있을 수 있습니다.

- 죽은 코드다.
- 추상화가 누락돼있다.

### 비공개 메서드 테스트가 타당한 경우

비공개 메서드를 절대 테스트하지 말라는 규칙에도 예외는 있습니다. 바로, 식별할 수 있는 동작이 비공개인 경우 입니다.

예를 들면, ORM은 공개 생성자가 필요하지 않으며, 비공개 생성자로 작동할 수 있기에 생성자는 비공개이면서 식별할 수 있는 동작인 메서드입니다.

```csharp
public class Inquiry
{
	public bool IsApporved {get; private set;}
	public DateTime? TimeApproved {get; private set;}

	//비공개이면서 식별할 수 있는 동작(ORM과의 계약)
	private Inquiry(bool isApproved, DateTime? timeApproved)
	{
		if(isApproved && !timeApproved.HasValue)
		{
			throw new Exception();
		}
	
		IsApproved = isApproved;
		TimeAppored = timeAppored;
	}

	public void Approve(DateTime now)
	{
		if(IsApproved)
			return;
	
		IsApproved = true;
		TimeAppored = now;
	}
}

```

이럴 경우 클래스의 공개 API 노출 영역을 작게 유지하려면 테스트에서 리플렉션을 통해 Inquiry를 인스턴스화할 수 있습니다.

## 2. 비공개 상태 노출

단위 테스트 목적으로만 비공개 상태를 노출하는 것은 안티패턴입니다. 테스트는 제품코드와 정확히 같은 방식으로 SUT와 상호 작용해야 하며, 특별한 권한이 따로 있어서는 안 됩니다.

> 테스트 유의성을 위해 공개 API 노출 영역을 넓히는 것은 좋지 않은 관습입니다.
> 

🤔 비공개 메서드를 테스트하는 방법은 없을까요?

🗨 방법은 해당 상태가 클래스를 어떻게 사용하는지를 대신 살펴보는 것입니다. 다른 곳에서 해당 필드를 사용하기 시작하면 공식적으로 SUT의 식별할 수 있는 동작이 되기 떄문에 테스트에서 해당 필드를 결합할 수 있습니다.

## 3. 테스트로 유츌된 도메인 지식

도메인 지식을 테스트로 유출하는 것은 안티 패턴입니다. 특히 복잡한 알고리즘을 다루는 테스트에서 발생합니다. 단순히 제품 코드에서 테스트로 알고리즘(코드)를 복사-붙여넣기를 한다면 이는 구현 세부 사항과 결합됩니다.

```csharp
public class CalculatorTests
{
	[Theroy]
	[InlineData(1, 3, 4)]
	[InlineData(11, 33, 44)]
	[InlineData(100, 500, 600)]
	public void Adding_two_numbers(int value1, int value2, int expected)
	{
		int actual = Calculator.Add(value1, value2);
		Assert.Equal(expected, actual);
	}
}
```

위와 같이 올바른 테스트 방법은 테스트를 작성할 때 특정 구현을 암시하지 않고 복제하는 대신 결과를 테스트에 하드 코딩해야 합니다. 단위 테스트에서는 예상 결과를 하드코딩하는 것이 좋습니다.

## 4. 코드 오염

<aside>
💡 코드 오염은 테스트에만 필요한 제품 코드를 추가하는 것입니다.

</aside>

코드 오염의 문제는 테스트 코드와 제품 코드가 혼재되어 유지비가 증가하는 것입니다. 이를 방지하기 위해선 테스트 코드를 제품 코드베이스와 분리해야 합니다.

## 5. 구체 클래스를 목으로 처리하기

구체 클래스를 대신 목으로 처리해서 본래 클래스의 기능 일부를 보존할 수 있으며 이는 유용하지만, 단일 책임 원칙을 위배하는 단점이 있습니다.  

일부 기능을 지키려 구체 클래스를 목으로 처리해야 하면, 이는 단일 책임 원칙을 위배하므로 안티패턴입니다.

## 6. 시간 처리하기

현재 날짜와 시간 등 변경되는 기능을  테스트하면 거짓 양성이 발생합니다. 이러한 의존성을 안정화하는 두 가지 방법이 있습니다.

### 엠비언트 컨텍스트로서의 시간: 안티패턴

```csharp
public static class DateTimeServer
{
	private static Func<DateTime> _func;
	public static DateTime Now => _func();

	public static void Init(Func<DateTime> func)
	{
		_func = func;
	}
}

DateTimeService.Init(() => DateTime.Now); //운영 환경 초기화
DateTimeService.Init(() => new DateTime(2020, 1, 1)); //단위 테스트 환경 초기화
```

앰비언트 컨텍스트는 제품 코드를 오염 시키고 테스트를 더 어렵게 만듭니다. 정적 필드는 테스트 간에 공유하는 의존성을 도입해 해당 테스트를 통합 테스트 영역으로 전환합니다.

### 명시적 의존성으로서의 시간

앰비언트 컨텍스트에서 정적 메서드를 통해 참조하는 대신 서비스 또는 일반 값으로 시간 의존성을 명시적으로 주입하는 것은 안티패턴입니다. 시간을 항상 일반 값으로 주입할 수 없고 의존성 주의 프레임워크가 값 객체와 잘 어울리지는 않습니다.

## 7. 정리

- 단위 테스트를 위해 비공개 메서드를 노출하면 테스트가 구현에 결합됩니다. 식별할 수 있는 동작으로서 간접적인 테스트를 해야 합니다.
- 만약, 비공개 메서드가 클래스의 식별할 수 있는 동작이라면 클래스와 ORM또는 팩토리간의 비공개 계약을 구현해야 합니다.
- 비공개였던 상태를 단위 테스트만을 위해 노출하지 말아야 합니다.
- 테스트를 작성할 때 특정 구현을 암시하지 말아야 합니다.
- 도메인 지식을 테스트에 유출하지 않아야 합니다.
- 코드 오염은 테스트에만 필요한 제품 코드를 추가하는 것입니다.
- 기능을 위해 구체 클래스를 목으로 처리하면 단일 책임 원칙을 위반하게 됩니다.
    - 두 가지 클래스(도메인 로직 클래스/프로세스 외부 의존성 통신 클래스)로 분리
- 서비스나 일반 값의 명시적인 의존성으로 시간을 주입해야 합니다. 앰비언트 컨텍스트로 현재 시간을 측정하면 코드가 오염됩니다.