# 11장. 단위테스트 안티패턴

## 11.1 비공개 메서드 단위 테스트

**비공개 메서드와 테스트 취약성**

비공개 메서드를 노출하면 테스트가 구현 세부 사항과 결합되고 결과적으로 리팩터링 내성이 떨어진다.

비공개 메서드를 직접 테스트하는 대신 포괄적인 식별할 수 있는 동작으로 간접 테스트 하라.

**비공개 메서드와 불필요한 커버리지**

식별할 수 있는 동작에 이미 합리적인 테스트 커버리지가 있다라면 아래같은 문제가 발생한다.

- 죽은 코드, 테스트에서 벗어난 코드가 어디에도 사용되지 않는다면 리팩터링 후 남어서 관계없는 코드 일 수 있다. 이러한 코드는 삭제하자.
- 추상화 누락.

**비공개 메서드 테스트가 타당한 경우**

코드의 공개 여부와 목적의 관계

|  | 식별할 수 있는 동작 | 구현 세부 사항 |
| --- | --- | --- |
| 공개 | 좋음 | 나쁨 |
| 비공개 | 해당 없음 | 좋음 |

클래스  공개 api 노출 영역을 가능한 작게 하려면 테스트에서 리플렉션을 통해 inquiry를 인스턴스화할 수 있다.

## 11.2 비공개 상태 노출

일반적인 안티 패턴으로 단위 테스트 목적으로만 비공개 상태를 노출하는 것이 있다.

> 참고 | 테스트 유의성을 위해 공개 API 노출 여역을 넓히는 것은 좋지 않은 관습이다.
> 

## 11.3 테스트로 유출된 도메인 지식

테스트를 작성할 때 특정 구현을 암시하지 말라. 알고리즘을 복제하는 대신 결과를 테스트에 하드 코딩한다.

레거시 애플리케이션을 리팩터링할 경우에는 레거시 코드가 이러한 결과를 생성하도록 한 후 테스트에서 예상 값으로 사용할수 있다.

## 11.4 코드 오염

> 정의 | 코드 오염은 테스트에만 필요한 제품 코드를 추가하는 것이다.
> 

ILogger와 같은 코드 코염은 덜 손상되고 다루기 쉽다. 인터페이스에는 코드가 없기 때문에 버그가 있을 수 없다.

## 11.5  구체 클래스를 목으로 처리하기

구체클래스를 대신 목으로 처리해서 본래 클래스의 기능 일부를 보존할 수 있으며, 때때로 유용하다.

기능을 지키려고 클래스를 목으로 처리하면 단일 책임 원칙을 위반한다. 해당 클래스를 도메인 로직이 있는 클래스와 프로세스 외부 의존성 통신 클래스로 분리하라.

## 11.6 시간 처리하기

서비스나 일반 값의 명시적인 의존성으로 시간을 주입하라. 항상 일반 값이 좋다.
