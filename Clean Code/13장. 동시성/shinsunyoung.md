# 13장 동시성

# TOC

- [Contents](#contents)
  * [동시성이 필요한 이유?](#동시성이 필요한 이유?)
    + [미신과 오해](#미신과 오해)
    + [타당한 생각들](#타당한 생각들)
    + [난관](#난관)
  * [동시성 방어 원칙](#동시성 방어 원칙)
    + [단일 책임 원칙](#단일 책임 원칙)
    + [자료 범위 제한](#자료 범위 제한)
    + [자료 사본 사용](#자료 사본 사용)
    + [스레드는 가능한 독립적으로 구현](#스레드는 가능한 독립적으로 구현)
  * [라이브러리를 이해하라](#라이브러리를 이해하라)
    + [스레드 환경에 안전한 컬렉션](#스레드 환경에 안전한 컬렉션)
  * [실행 모델을 이해하라](#실행 모델을 이해하라)
    + [생산자-소비자](#생산자-소비자)
    + [읽기-쓰기](#읽기-쓰기)
    + [식사하는 철학자들](#식사하는 철학자들)
  * [동기화하는 메서드 사이에 존재하는 의존성을 이해하라](#동기화하는 메서드 사이에 존재하는 의존성을 이해하라)
  * [동기화하는 부분을 작게 만들어라](#동기화하는 부분을 작게 만들어라)
  * [올바른 종료 코드는 구현하기 어렵다.](#올바른 종료 코드는 구현하기 어렵다)
  * [스레드 코드 테스트하기](#스레드 코드 테스트하기)
  * [결론](#결론)
- [Reference](#reference)

<br>

# Contents

## 동시성이 필요한 이유?

**무엇(what)**과 **언제(when)**를 분리할 수 있다.

그리고 이것을 분리하면 애플리케이션의 구조와 효율이 훨씬 좋아질 수 있다.

하지만 ... 어렵다 😵

<br>

### 미신과 오해

- 동시성은 항상 성능을 높여준다.
    - 여러 프로세서가 동시에 처리할 독립적인 계산이 충분히 많은 경우에나 성능이 높아진다.
- 동시성을 구현해도 설계는 변하지 않는다.
    - 무엇과 언제를 분리하면 구조가 크게 달라진다.
- 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다.
    - 알아야한다.

<br>

### 타당한 생각들

- 동시성은 다소 부하를 유발한다.
- 동시성은 복잡하다.
- 일반적으로 동시성 버그는 재현하기 어렵다.
- 동시성을 구현하기 위해서는 근본적인 설계 전략을 재고해야 한다.

<br>

### 난관

```java
public class X {
	private int lastIdUsed;

	public int getNextId() {
		return ++lastIdUsed;
	}
}
```

`lastIdUsed` 를 42로 설정하고 두개의 스레드가 해당 인스턴스를 공유한다고 했을 때,

`getNextId()`를 호출하면 아래와 같은 결과 중 하나가 나온다.

1. 1번 스레드는 43을 받고 2번 스레드는 44를 받는다. (lasteIdUsed = 44)
2. 1번 스레드는 44를 받고 2번 스레드는 43을 받는다. (lasteIdUsed = 44)
3. 1번 스레드, 2번 스레드 모두 43을 받는다.  (lasteIdUsed = 43)

여기서 세번째 결과가 나올 수도 있으며, 재현하기도 어렵다.

<br>

## 동시성 방어 원칙

### 단일 책임 원칙

동시성을 구현할 때는 아래 내용들을 고려해야한다.

- 동시성 코드는 독자적인 개발, 변경, 조율 주기가 이싿.
- 동시성 코드에는 독자적인 난관이 있다. 다른 코드의 난관과 다르고 훨씬 어렵다.
- 잘못 구현한 동시성 코드는 별의별 방식으로 실패한다.

권장사항 → 동시성 코드는 다른 코드와 분리하는게 좋다.

<br>

### 자료 범위 제한

임계영역을 `synchronized` 키위드로 보호하는게 좋다.

공유 자료를 수정하는 위치가 많을 수록 ...

- 공유 자료를 수정하는 모든 코드를 망가뜨린다.
- 임계영역을 올바르게 보호했는지 확인하느라 똑같은 노력과 수고를 반복한다.
- 찾기 어려운 버그가 더 찾기 어렵게 된다.,

권장사항 → 자료를 캡슐화하고 공유 자료를 최대한 줄여야한다.

<br>

### 자료 사본 사용

스레드가 객체를 복사해 사용한 후 한 스레드가 사본에서 결과를 가져오는 방법을 사용할 수 있다.

<br>

### 스레드는 가능한 독립적으로 구현

모든 정보는 비공유 출처에서 가져오며 로컬 변수에 저장한다.

권장사항 → 독자적인 스레드로, 가능하면 다른 프로세서에서 돌려도 괜찮도록 자료를 독립적인 단위로 분할하는게 좋다.

<br>

## 라이브러리를 이해하라

Java5로 스레드 코드를 구현한다면 다음 사항 고려하기

- 스레드 환경에 안전한 컬렉션을 사용한다.
- 서로 무관한 작업을 수행할 때에는 `executor` 사용하기
- 가능하면 스레드가 blocking되지 않는 방법 사용하기
- 일부 클래스 라이브러리는 스레드에 안전하지 못하다는 것을 명심하기
  <br>

### 스레드 환경에 안전한 컬렉션

- java.util.concurrent의 ConcurrentHashMap
    - 대부분의 상황에서 HashMap보다 빠르다.
    - 동시 읽기/쓰기 지원
    - 복합 연산을 안전하게 만든 메소드 제공
- ReentrantLock
    
    - 한 메서드에서 잠그고 다른 메서드에서 푸는 lock
- Semaphore
    
    - count가 있는 lock
- CountDownLatch
    
    - 지정한 수만큼 이벤트가 발생해야 대기 스레드를 해제하는 lock
    
    <br>

## 실행 모델을 이해하라

- 한정된 자원 (Bound Resource)
    - 다중 스레드 환경에서 사용하는 한정된 자원
    - ex. 데이터베이스 연결
- 상호 배제 (Mutual Exclusion)
    - 한 번에 한 스레드만 공유 자원을 사용할 수 있는 경우
- 기아 (Starvation)
    - 특정 스레드가 굉장히 오랫동안 또는 영원히 자원을 기다리는 경우
- 데드락 (Deadlock)
    - 여러 스레드가 서로가 끝나기를 기다리는 경우
- 라이브락 (Livelock)
    - 락을 거는 단계에서 각 스레드가 서로를 방해하는 경우

<br>

### 생산자-소비자

하나 이상 생산자 스레드가 정보를 생성해 빈 공간이 있으면 (없으면 대기) 버퍼나 대기열에 넣는다.

하나 이상 소비자 스레드가 대기열에서 정보가 있으면 (없으면 대기) 정보를 가져와 사용한다.

생산자 - 소비자 스레드가 사용하는 대기열은 **한정된 자원**

서로에게 시그널을 보내게 되는데, 잘못하면 둘 다 진행 가능하지만 무한정 대기만 할 수도 있다.

<br>

### 읽기-쓰기

읽기 스레드를 위한 주된 정보원 → 공유 자원

쓰기 스레드가 갱신하는 것 → 공유 지원

→ 처리율을 적당히 높이고 기아를 방지해서 적절히 균형을 잡는 것이 중요

<br>

### 식사하는 철학자들

주의해서 설계하지 않으면,

데드락, 라이브락, 처리율 저하, 효율성 저하등의 상황을 겪을 수 있다.

<br>

## 동기화하는 메서드 사이에 존재하는 의존성을 이해하라

권장사항 : 공유 객체 하나에는 메서드 하나만 사용하는 것이 좋다.

만약 불가능하다면?

- 클라이언트에서 첫 번째 메서드를 호출하기 전에 서버를 잠근다.
- 서버를 잠그고 모든 메서드를 호출한 후 잠금을 해제하는 메서드를 구현한다.
- 잠금을 수행하는 중간 단계를 생성한다.

<br>

## 동기화하는 부분을 작게 만들어라

락은 스레드를 지연시키고 부하를 가중시킨다. (`synhronized` 남발 금지)

거대한 임계영역을 하나로 묶으면 스레드 간 경쟁이 늘어나고 성능이 떨어진다.

권장사항 : 동기화하는 부분을 최대한 작게 만들기

<br>

## 올바른 종료 코드는 구현하기 어렵다.

시간을 투자해서 올바르게 구현해야한다. (여러 상황 생각하기)

<br>

## 스레드 코드 테스트하기

권장사항 : 문제를 노출하는 테스트 케이스 작성하기, 프로그램 설정 & 시스템 설정, 부하를 바꿔가며 자주 돌리기

- 말이 안 되는 실패는 잠정적인 스레드 문제로 취급하기
    - 시스템 실패를 '일회성'으로 치부하지 않기
- 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌기 하기
- 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워넣을 수 있도록 하기
- 다중 스레드를 쓰는 코드 부분을 상황에 맞춰 조정할 수 있게 작성하기
    - 스레드 개수를 조율하기 쉽게 코드를 구현하는게 좋다.
- 프로세서 수보다 많은 스레드를 돌려보기
- 다른 플랫폼에서 돌려보기
- 코드에 보조 코드를 넣어서 강제로 실패하는 코드 만들어보기
    - ex. Object.sleep(), Object.wait ...
    - 직접 구현하기
        - 적정 위치를 찾아야한다.
        - 호출하기 적당한 함수를 찾아야한다.
        - 성능이 떨어진다.
        - 오류가 드러나지 않을 수도 있다.
    - 자동화하기
        - AOP, CGLIB, ASM 등과 같은 도구를 사용하기
        - ConTest
        - jiggling 기법으로 코드를 흔드는게 좋다.

<br>

## 결론

- 다중 스레드 코드는 버그를 찾기 어렵기 때문에 각별히 깨끗하게 코드를 짜야한다.
- **SRP**를 준수하는게 좋다.
- POJO를 사용해 스레드를 아는 코드, 모르는 코드를 **분리**하는게 좋다.
- 스레드 코드를 테스트할 때에는 전적으로 **스레드만 테스트**한다.
- 동시성 오류를 일으키는 **잠정적 원인**을 철저히 이해한다.
- **사용하는 라이브러리**와 **기본 알고리즘**을 이해한다.
- 보호할 코드 영역을 찾아내는 방법과 특정 코드 영역을 잠그는 방법을 이해한다.
- 어떻게든 문제가 생기기 때문에 **테스트**는 정말 중요하다.

 

# Reference

[Clean Code](https://book.naver.com/bookdb/book_detail.nhn?bid=7390287)