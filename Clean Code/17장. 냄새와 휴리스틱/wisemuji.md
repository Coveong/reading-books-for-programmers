# 냄새와 휴리스틱

다음 목록은 저자가 다양한 프로그램을 검토하고 리팩터링하면서 만든 나쁜 냄새를 정리한 것이다. 또 저자가 코드를 짜면서 사용하는 기교와 휴리스틱도 포함된다.

## 주석

### 부적절한 정보

주석은 코드와 설계에 기술적인 설명을 부연하는 수단으로 사용해야 한다.

### 쓸모 없는 주석

오래된 주석, 엉뚱한 주석, 잘못된 주석은 더 이상 쓸모가 없다.

### 중복된 주석

코드만으로 충분한데 구구절절 설명하지 말자. 다음 예시 참고

```java
i++;  // i 증가
```

### 성의 없는 주석

작성할 가치가 있는 주석은 잘 작성할 가치도 있다. 시간을 들여 최대한 간결하고 명료하게 작성하자.

### 주석 처리된 코드

소스 코드 관리 시스템이 기억하고 있으니 주저 말고 지우자.

## 환경

### 여러 단계로 빌드한다.

빌드는 간단히 한 단계로, 한 명령으로 끝나야 한다.

### 여러 단계로 테스트한다.

모든 단위 테스트는 한 명령으로 돌려야 한다. 모든 테스트를 한 번에 실행하는 능력은 아주 근본적이고 아주 중요하므로 빠르고, 쉽고 명백해야 한다.

## 함수

### 너무 많은 인수

함수에서 인수 개수는 작을수록 좋다. 넷 이상은 최대한 피한다.

### 출력 인수

출력 인수는 직관을 정면으로 위배한다. 함수에서 뭔가의 상태를 변경해야 한다면 함수가 속한 객체의 상태를 변경한다.

### 플래그 인수

boolean 인수는 함수가 여러 기능을 수행한다는 명백한 증거다 - SRP 원칙을 위반한다.

### 죽은 함수

아무도 호출하지 않는 함수는 삭제한다.

## 일반

### 한 소스 파일에 여러 언어를 사용한다.

좋게 말하자면 혼란스럽고 나쁘게 말하자면 조잡하다. 불가피한 경우라면 소스 파일에서 언어의 수와 범위를 최대한 줄이도록 애써야 한다.

### 당연한 동작을 구현하지 않는다.

최소 놀람의 원칙(The Principle of Least Surprise)에 의거해 함수나 클래스는 프로그래머가 당연하게 여길만한 동작과 기능을 제공해야 한다.

```java
Day day = DayDate.StringToDay(String dayName);
```

우리는 함수가 'Monday'를 Day.Monday로 변환하리라 기대한다.

당연한 동작을 구현하지 않으면 코드를 읽거나 사용하는 사람이 더 이상 함수 이름만으로 함수 기능을 직관적으로 예상하기 어렵다.

### 엣지 케이스를 올바로 처리하지 않는다.

스스로의 직관에 의존하지 말고 모든 엣지 케이스를 찾아내고 테스트 케이스를 작성하라.

### 안전 절차 무시

실패하는 테스트 케이스를 일단 제겨두고 나중으로 미루는 태도는 신용카드가 공짜 돈이라는 생각만큼 위험하다.

### 중복

코드에서 중복을 발견할 때마다 추상화할 기회로 간주하라.

### 추상화 수준이 올바르지 못하다.

추상화로 개념을 분리할 때는 철저해야 한다. 모든 저차원 개념은 파생 클래스에 넣고 모든 고차원 개념은 기초 클래스에 넣는다. 어느 경우든 철저히 분리해야 한다.

### 기초 클래스가 파생 클래스에 의존한다.

일반적으로 기초 클래스는 파생 클래스를 아예 몰라야 마땅하다. 이렇게 구현하면 변경이 시스템에 미치는 영향이 아주 작아지므로 현장에서 시스템을 유지보수 하기가 한결 수월하게 된다.

### 과도한 정보

잘 정의된 인터페이스는 많은 함수를 제공하지 않아 결합도가 낮다. 인터페이스를 매우 작게, 매우 깐깐하게 만들어라. 정보를 제한해 결합도를 낮춰라.

### 죽은 코드

실행되지 않는 코드를 제거하라.

### 수직 분리

변수와 함수는 사용되는 위치에 가깝게 정의한다.

### 일관성 부족

어떤 개념을 특정 방식으로 구현했다면 유사한 개념도 같은 방식으로 구현하라.

### 잡동사니(빈 기본 생성자, 사용하지 않는 함수 등)

소스 파일은 언제나 깔끔하게 정리하라. 

### 인위적 결합

서로 무관한 개념을 인위적으로 결합하지 않는다.

### 기능 욕심

클래스 메서드는 자기 클래스의 변수와 함수에 관심을 가져야지 다른 클래스의 변수와 함수에 관심을 가져서는 안된다.

### Boolean 인수

함수 동작을 제어하려는 인수는 바람직하지 않다.

### 모호한 의도

다음과 같은 코드는 저자의 의도를 흐린다.

```java
public int m_otCalc() {
	return iThsWkd * iThsRte +
	(int) Math.round(0.5 * iThsRte *
		Math.max(0, iThsWkd - 400)
	);
}
```

행을 바꾸지 않고 표현한 수식, 헝가리식 표기법, 매직 번호 등등

### 잘못 지운 책임

코드는 독자가 자연스럽게 기대할 위치에 배치한다. 때로는 개발자가 '영리하게' 개발자에게 편한 곳에 배치할 때도 있다. 

결정을 내리는 한 가지 방법으로 함수의 이름을 살펴본다. 예를 들어 보고서 모듈에 `getTotalHours` 라는 함수가 있고, 근무 시간을 입력 받는 모듈에 `saveTimeCard` 라는 함수가 있다 가정한다. 이름만 보았을 때 어느 쪽이 총계를 계산해야 옳을까? 답은 명백하다.

### 부적절한 static 함수

일반적으로 static 함수보다 인스턴스 함수가 더 좋다. 다음 예시를 보자.

```java
HourlyPayCalculator.calculatePay(employee, overtimeRate);
```

언뜻 보면 static 함수로 여겨도 적당하다. 특정 객체와 관련이 없으면서 모든 정보를 인수에서 가져오기 때문이다. 하지만 함수를 override할 가능성이 존재한다.

반드시 static 함수로 정의해야 한다면 override할 가능성은 없는지 꼼꼼히 따져본다.

### 서술적 변수

프로그램 가독성을 높이는 가장 효과적인 방법 중 하나가 계산을 여러 단계로 나누고 중간 값으로 서술적인 변수 이름을 사용하는 방법이다.

### 이름과 기능이 일치하는 함수

```java
Date newDate = date.add(5);
```

코드만 봐서는 5일을 더하는지 5주를 더하는지 알 수가 없다.

이름만으로 분명하지 않기에 구현을 살피거나 문서를 뒤적여야 한다면 더 좋은 이름으로 바꾸거나 더 좋은 이름을 붙이기 쉽도록 기능을 정리해야 한다.

### 알고리즘을 이해하라

알고리즘이 올바르다는 사실을 확인하고 이해하려면 기능이 뻔히 보일 정도로 함수를 깔끔하고 명확하게 재구성하는 방법이 최고다.

### 논리적 의존성은 물리적으로 드러내라

의존하는 모듈이 상대 모듈에 대해 뭔가를 가정하면(즉, 논리적으로 의존하면) 안된다. 의존하는 모든 정보를 명시적으로 요청하는 편이 좋다.

### if/else 혹은 switch/case문보다 다형성을 사용하라

선택 유형 하나에는 switch문을 한 번만 사용한다. 같은 선택을 수행하는 다른 코드에서는 다형성 객체를 생성해 switch문을 대신한다.

### 표준 표기법을 따르라

팀은 업계 표준에 기반한 구현 표준을 따라야 한다.

### 매직 숫자는 명명된 상수로 교체하라

일반적으로 코드에서는 숫자를 사용하지 말고 명명된 상수 뒤로 숨겨야 한다. 이때 '매직 숫자'라는 용어는 단지 숫자만 의미하지 않는다. 의미가 분명하지 않은 토큰을 모두 가리킨다.

### 정확하라

코드에서 모호성과 부정확은 의견차나 게으름의 결과다. 어느 쪽이든 제거해야 마땅하다.

### 관례보다 구조를 사용하라

명명 관례도 좋지만 구조 자체로 강제하면 더 좋다.

### 조건을 캡슐화하라

조건의 의도를 분명히 밝히는 함수로 표현하라. 예를 들어

```java
if (shouldBeDeleted(timer))
```

라는 코드는 다음 코드보다 좋다.

```java
if (timer.hasExpired() && !timer.isRecurrent())
```

### 부정 조건은 피하라

부정 조건은 긍정 조건보다 이해하기 어렵다. 예를 들어

```java
if (buffer.shouldCompact())
```

라는 코드는 다음 코드보다 좋다.

```java
if (!buffer.shouldNotCompact())
```

### 함수는 한 가지만 해야 한다

여러 가지를 수행하고 있다면 한 가지 역할만 하도록 분리하는 게 좋다.

### 숨겨진 시간적인 결합

함수를 짤 때는 함수 인수를 적절히 배치해 함수가 호출되는 순서를 명백히 드러낸다.

### 일관성을 유지하라

코드 구조를 잡을 때는 이유를 고민하고 그 이유를 코드 구조로 명백히 표현하라.

### 경계 조건을 캡슐화하라

경계 조건은 한 곳에서 별도로 처리한다. 다시 말해, 코드 여기저기에 +1이나 -1을 흩어놓지 않는다.

### 함수는 추상화 수준을 한 단계만 내려가야 한다

함수 내 모든 문장은 추상화 수준이 동일해야 한다.

### 설정 정보는 최상위 단계에 둬라

추상화 최상위 단계에 둬야 할 기본값 상수나 설정 관련 상수를 저차원 함수에 숨겨서는 안 된다. 대신 고차원 함수에서 저차원 함수를 호출할 때 인수로 넘긴다.

### 추이적 탐색을 피하라

일반적으로 한 모듈은 주변 모듈을 모를수록 좋다. 좀 더 구체적으로, A가 B를 사용하고 B가 C를 사용한다 하더라도 A가 C를 알 필요는 없다는 뜻이다. 이를 디미터의 법칙이라고 부른다.

내가 사용하는 모듈이 내게 필요한 서비스를 모두 제공해야 한다. 원하는 메서드를 찾느라 객체 그래프를 따라 시스템을 탐색할 필요가 없어야 한다. 다음과 같은 간단한 코드로 충분해야 한다.

```java
myCollaborator.doSomething();
```

## 자바

### 긴 import 목록을 피하고 와일드카드를 사용하라.

패키지에서 클래스를 둘 이상 사용한다면 와일드카드를 사용해 패키지 전체를 가져오라.

```java
import package.*;
```

명시적인 import 문은 강한 의존성을 생성하지만 와일드카드는 그렇지 않다.

와일드카드 import 문은 때로 이름 충돌이나 모호성을 초래한다. 다소 번거롭지만 자주 발생하지 않으므로 여전히 와일드카드 import 문이 명시적인 import 문보다 좋다.

### 상수는 상속하지 않는다.

상속 대신에 static import를 사용하라.

### 상수 vs enum

enum은 메서드와 필드로 사용할 수 있고 int로 선언된 상수보다 훨씬 유연하고 서술적이다.

## 이름

### 서술적인 이름을 사용하라

이름은 성급하게 정하지 말고 서술적인 이름을 신중하게 고민해서 지어야 한다. 신중하게 선택한 이름은 추가 설명을 포함한 코드보다 강력하다.

### 적절한 추상화 수준에서 이름을 선택하라

구현을 드러내는 이름을 피하라. 작업 대상 클래스나 함수가 위치하는 추상화 수준을 반영하는 이름을 선택하라.

### 가능하다면 표준 명명법을 사용하라

프로젝트에 유효한 의미가 담긴 이름을 많이 사용할수록 독자가 코드를 이해하기 쉬워진다.

### 명확한 이름

함수나 변수의 목적을 명확히 밝히는 이름을 선택한다.

### 긴 범위는 긴 이름을 사용하라

이름 길이는 범위 길이에 비례해야 한다.

### 인코딩을 피하라

이름에 유형 정보다 범위 정보를 넣어서는 안 된다. 오늘날 개발 환경에서는 `m_`, `f` 와 같은 접두어가 불필요하다.

### 이름으로 부수 효과를 설명하라

함수, 변수, 클래스가 하는 일을 모두 기술하는 이름을 사용한다.

## 테스트

### 불충분한 테스트

테스트 케이스는 잠재적으로 깨질 만한 부분을 모두 테스트해야 한다.

### 커버리지 도구를 사용하라

커버리지 도구는 테스트가 빠뜨리는 공백을 알려준다.

### 사소한 테스트를 건너뛰지 마라

사소한 테스트가 제공하는 문서적 가치는 구현에 드는 작은 비용을 넘어선다.

### 무시한 테스트는 모호함을 뜻한다

때로는 요구사항이 불분명하기에 프로그램이 돌아가는 방식을 확신하기 어렵다.

### 엣지 케이스를 테스트하라

각별히 신경 써서 테스트해야 한다. 알고리즘의 주요 조건은 잘 짜두고 엣지 케이스에서 실수하는 경우가 흔하다.

### 버그 주변은 철저히 테스트하라

버그는 서로 모이는 경향이 있다

### 실패 패턴을 살펴라

때로는 테스트 케이스가 실패하는 패턴으로 문제를 진단할 수도 있다.

### 테스트 커버리지 패턴을 살펴라

통과하는 테스트가 실행하거나 실행하지 않는 코드를 살펴보면 실패하는 테스트 케이스의 실패 원인이 드러난다.

### 테스트는 빨라야 한다.

느린 테스트 케이스는 실행하지 않게 된다.

# 결론

여기서 소개한 목록은 가치 체계를 피력할 뿐이다.

사실상 가치 체계는 이 책의 주제이자 목표다. 일군의 규칙만 따른다고 깨끗한 코드가 얻어지지 않는다. 휴리스틱 목록을 익힌다고 소프트웨어 장인이 되지는 못한다. 전문가 정신과 장인 정신은 가치에서 나온다. 그 가치에 기반한 규율과 절제가 필요하다.
