# 11장 시스템

# TOC

- [Contents](#contents)
  * [시스템 제작과 사용을 분리하라](#시스템-제작과-사용을-분리하라)
    + [Main 분리](#main-분리)
    + [팩토리](#팩토리)
    + [의존성 주입](#의존성-주입)
  * [AspectJ 관점](#aspectj-관점)
  * [테스트 주도 시스템 아키텍처 구축](#테스트-주도-시스템-아키텍처-구축)
  * [의사 결정을 최적화하라](#의사-결정을-최적화하라)
  * [결론](#결론)

- [Reference](#reference)

<br>

# Contents

## 시스템 제작과 사용을 분리하라

```java
public Service getService() {
	if (service == null)
		service = new MyServiceImpl(...);
	retrun service;
}
```

장점

- 실제로 필요할 때 까지 객체를 생성하지 않으므로 불필요한 부하가 걸리지 않는다.
- 어떤 경우에도 null을 반환하지 않는다.

단점

- getService()가 MyServiceImpl에 의존한다.
- 테스트가 어렵다.
- MyServiceImpl이 모든 상황에 적합한 객체인지 확신할 수 없다.

<br>

### Main 분리

생성과 관련한 코드는 main, main이 호출하는 모듈로 옮긴다.

나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되었다고 가정한다.

→ 모든 객체가 적절히 생성되었다고 가정

<br>

### 팩토리

객체가 생성되는 시점을 애플리케이션이 결정한다.

<br>

### 의존성 주입

제어의 역전을 의존성 관리자에 적용한 매커니즘

한 객체가 맡은 보조 책임을 **새로운 객체**에게 전적으로 맡긴다. (SRP)

진정한 의존성 주입은 클래스가 의존성을 해결하려 시도하지 않는것이다.

대신 의존성 주입 방법으로 설정자(Setter) 메서드나 생성자 인수를 제공한다.

<br>

## AspectJ 관점

관심사를 분리하는 가장 강력한 도구

## 테스트 주도 시스템 아키텍처 구축

테스트 관점으로 관심사를 분리하면 좋다.

좋은 API는 걸리적거리지 않아야한다.

> 최선의 시스템 구조는 각기 POJO(또는 다른) 객체로 구현되는 모듈화된 관심사의 영역(도메인)으로 구성된다. 이렇게 서로 다른 영역은 해당 영역 코드에 최소한의 영향을 미치는 관점이나 유사한 도구를 사용해 통합한다. 이런 구조 역시 코드와 마찬가지로 테스트 주도 기법을 적용할 수 있다.

<br>

## 의사 결정을 최적화하라

너무 일찍 결정하면 고객 피드백을 더 모으고, 프로젝트를 더 고민하고, 구현 방안을 더 탐험할 기회가 사라진다.

<br>

## 결론

시스템은 깨끗해야한다.

시스템을 설계하든 개발 모듈을 설계하든, 실제로 돌아가는 가장 단순한 수단을 사용해야한다.

<br>

# Reference

[Clean Code](https://book.naver.com/bookdb/book_detail.nhn?bid=7390287)

[클린코드 10장 - 클래스](http://amazingguni.github.io/blog/2016/06/Clean-Code-10-%ED%81%B4%EB%9E%98%EC%8A%A4)