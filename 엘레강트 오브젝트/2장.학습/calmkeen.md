# Chapter 2. Education



## 1. 가능하면 적게 캡슐화하세요

복잡성이 높을수록 유지보수성이 저하되고, 시간과 돈이 낭비되며 만족도가 떨어집니다.

이점을 염두해 , 4개 이하의 객체를 캡슐화 할것을 권장합니다.



내부 캡슐화 객체 전체를 가리켜 상태 또는 식별자라고 부릅니다.

내부에 캡슐화된 모든 객체들이 객체의 식별자를 구성하는 요소

객체를 캡슐화하지 않는 객체란 존재하지 않는다.(부품이 없는 객체는 의미가 없기때문에)



```java
class Cash{
	private Integer digits;
	private Integer cents;
	private String currency;
}
```

> 클래스의 객체를 캡슐화했을때 객체들이 서로 동일하다라고 하는데 기술적 정의가 아닌듯함.
>
> 정확한 느낌은 모르겠다.위의 코드를 보고 하는 말인듯함



객체의 식별자는 기본적으로 객체가 위치하는 좌표다.

이좌표가 많을수록 이해하기가 어렵다. 4개라는 정확한 정의가 맞다고는 힘들지만 직관적으로 보기에 좋고 이 이상의 속성들은 객체를 이용해 그룹화 해 구성된 트리로 구성되는 방식이 옳다.



## 2. 최소한 뭔가는 캡슐화 하세요



극단적인 예로 아무것도 캡슐화 하지 않는 경우가 있다.

객체가 '무'와 같이 아무것도 아닌것이 아니라면 캡슐화를 해야합니다.

객체는 자기가 하나이고 자기만 표현하느 경우가 아니라면 다른 객체들과 공존해야 하는데 이때 자신을 식별하도록 다른 객체들을 캡슐화 해야 한다.



## 3. 항상 인터페이스를 사용하세요

객체들은 **결합(couple)**되는 것이 유용하다.

객체들이 수십개를 넘어가면서 **강한결합도(tight coupling)**가 문제가 된다.

애플리케이션 전체를 유지보수 가능하도록 만들기 위해 객체를 분이 해야하는데,이걸 가장 훌륭하게 하는것이 **인터페이스** 이다.

인터페이스는 우리의 객체가 다른객체와 의사소통하기 위해 따라야 하는 **계약(contact)**이다.

동일한 인터페이스를 구현하는 클래스 들은 서로 경쟁을 하는데 이는 곧 서로 쉽게 대체할 수 있다는 것이다. 이것이 **느슨한 결합**을 의미한다.

즉 인터페이스를 전체적 환경을 구조화 된 상태로 유지할 수 있도록 해주어야 한다.



## 4. 메서드 이름을 신중하게 선택하세요



#### 빌더(builder)란?

- 뭔가 만들고 새로운 객체를 반환하는 메서드이고 객체

#### 조정자(manipulator)란?

- 추상화한 실세계 엔티티를 수정하는 메서드는 조정자

- 반환 타입은 void



책에서 제시하는 방법은 빌더의 이름은 명사로 , 조정자의 이름은 동사로 짓는 것이다.

빌더는 어떤것을 만들고, 조정자는 조작합니다.

개념적으로 빌더와 조정자 사이에는 어떤 메서드도 존재해서는 안됩니다.



#### 요약

메서드의 목적이 무엇인지 확인하라.

메서드는 빌더나 조정자 둘중 하나여야 하고, 절대 두개 다여서는 안되며.

꼭 이름을 빌더라면 명사로, 조정자라면 동사로 지어야 한다.

Boolean값 반환하는 빌더는 예외에 속한다.( 이경우 이름을 형용사로 지어야한다.)



## 5. 퍼블릭 상수를 사용하지 마세요



객체사이에 데이터를 공유하기 위해 사용하는 매우 유명한 메커니즘이다.



저자는 객체들은 어떤것도 공유해서는 안된다고 하고 닫혀있어야 한다고 한다.

캡슐화와 객체지향적인 사고 전체를 부정하는 일이라고 생각한다.

퍼블릭 상수로 재사용을 할시 **결합도**가 높아진다고 생각하고, **응집도**가 낮아진다고 생각한다.



1.결합도 증가

두개 클래스가 같은 객체에 의존하고,하드코딩 되어 있으면, 의존성을 분리할수 있는 방법이 없다.

코드의 일부가 서로 결합되고 의존되면 클래스 행동이 예상할수 없는 방향을 변경될수 있을 수 있기 때문.



2.응집도 저하

퍼블릭 상수를 사용하면 객체의 응집도가 낮아진다. 

낮은 응집도 > 문제해결에 덜 집중으로 이어짐

의미를 추가하다 보면 코드가 길어지고 복잡해짐 -> 목적과 멀어짐



#### 요약

OOP에서 퍼블릭 상수는 절대 안된다.



## 6. 불변 객체로 만드세요



모든 클래스를 상태 변경이 불가능한 불변 클래스로 구현하면 유지보수성을 크게 향상시킬 수 있다.

불변성이 나타내는 것 > 응집력이 높고, 느슨하게 결합되고,유지보수가 쉬운 클래스를 만들수 있도록 한다.



인스턴스를 생성한 후에 상태를 변경할수 없는 객체 -> 불변객체

```java
//ex
class Cash{
	private final int dollars;
	Cash(int val){
		this.dollars = val;
	}
}
```



가변객체의 핵심 : 절대로 변경 가능한 객체를 만들지 마라.

```java
Cash five = new Cash(5);
five.mul(10);
System.out.println(five); // 50이 출력
```



- 불변객체를 사용해야 하는 이유

기술적으로 불변 객체를 사용해서 지연 로딩을 구현하는 것은 불가능하다.

어노테이션은 메서드가 오직 한번만 호출되어야 한다는 것을 컴파일러에게 공유한다.

캐싱 메커니즘으로 해결할수 있긴 함.



#### 6.1 식별자 가변성

 동일해 보이는 두 객체를 비교한 후 한 객체의 상태를 변경할때 문제가 제시됨

```java
Map<Cash, String> map = new HashMap<>();
Cash five = new Cash("$5");
Cash ten = new Cash("$10");

map.put(five, "five");
map.put(ten, "ten");

five.mul(2);
System.out.println(map);
//문제발생
map.get(five)
```

map의 상태가 비정상 적이기 때문에 예측 불가능하다.

- 새로운 키 객체를 추가하는 것  ( 불변객체를 사용하면 해결 가능)
- 

#### 6.2 실패 원자성

완전하고 견고한 상태의 객체를 가지거나 아니면 실패하거나 둘중 하나만 가능한 특성

문제인 이유: 객체의 복잡성이 높아지고, 실수 가능성이 커지기 때문에. 또한 유지보수성 역시 심각한 영향을 받게 된다.



#### 6.3 시간적 결합

```java
ash price = new Cash();
price.setCollars(29);
price.setCents(95);
System.out.println(price);
```

자바 빈 표준을 사용하지 말자.

시간적 로직으로 코드를 재정렬 하려고 한다면 시간적 결합을 이해해야 한다.

가변객체가 많은 상황에서 연산순서를 일일이 기억해야 한다면 유지보수가....

프로그래머가 머리가 터질수도 있다.

객체를 사용해서 어떤 일을 수행하려면 그 전에 객체를 완전한 상태로 초기화해야 한다.



#### 6.5 null참조 없애기

null참조는 유지보수가 크게 저하된다.

언제 유효한 상태이고 언제가 다른 형태로 바뀌는지 이해하기 어렵기 때문이다.



> 모든 객체를 불변으로 만들면 null을 포함시키기 어렵고 응집도 높은 객체를 생성할 수 밖에 없도록 강제되기 때문에 유지보수가 쉽다.!



#### 6.6 스레드 안정성

- 객체가 여러 스레드에 동시에 사용될 수 있으며 그 결과가 항상 예측가능하도록 유지할 수 있는 객체의 품질을 의미

병행성 이슈가 있음.( 하지만 해결하기 가장 어렵고 때로는 불가능)



> 불변쓰레드로 만듬으로써 상태를 수정할수 없게 만들어 객체에 접근해도 문제가 없다.

명시적 동기화를 이요하면 가변 클래스 역시 안전하게 되지만...

- 문제
  - 안정성을 추가가 어렵다
  - 동기화 로직은 성능상 비용을 초래한다.
  - 데드락이 발생할수 있다.



#### 6.7 더 작고 더 단순한 객체

장점 : 단순성 즉, 응집도가 높고 유지보수가 쉬워진다.

클래스가 작다면 줄수로 따는 것이 아니여도 단순해짐. 줄수로 따지면 250 줄 이하. 정도





## 7. 문서를 작성하는 대신 테스트를 만드세요



더 읽기쉬운 코드 코드를 만들기 위해서는, 읽는 사람이 주니어 프로그래머라고 가정해야 한다.

나쁜 설계는 문서를 작성하도록 강요함.

좋은 클래스는 목적이 명확하고, 작고 ,설계가 우아하다.

코드를 문서화 하는 대신 코드를 깔끔하게 만들자.



깔끔하고 유지보수 가능한 단위 테스트를 추가하면, 클래스를 더 깔끔하고 유지보수를 향상시킬수 있다

단위테스트가 곧 문서화와 같다.

> 메인 코드만큼 단위테스트에도 관심을 기울여라!



## 8. 모의 객체(Mock)대신 페이크 객체(Fake)를 사용하세요

페이크 클래스를 사용하면 테스트를 더 짧게 만들 수 있기 때문에 유지보수성이 눈에 띄게 향상된다.

모킹의 경우는 테스트가 장황하고 이해하거나 리팩토링하기 어려워 진다.

모킹은 단위테스트에 우호적이지 않습니다.

클래스의 사용자들은 더 나은 테스트를 작성할수 있고 인터페이스를 페이크 클래스와 함께 제공하면  더 작고 깔끔한 테스트르 만들수 있다.



## 9.인터페이스를 짧게 유지하고 스마트(smart)를 사용하세요



인터페이스가 커질수록, 구현하기 위해 더 많은 것들을 요구하고 더 많은 문제가 발생한다.

```java
//너무많은것을 요구
interface Exchange {
	float rate(String target);
	float rate(String source, String target);
}
```



- 변경

스마트 클래스의 크기는 점점 커지미나 인터페이스는 작고, 높은 응집력이 유지된다.

Exchange인터페이스를 구현하는 일을 번거롭게 만들 필요가 없다.

```java
interface Exchange {
	float rate(String source, String target);
	final class Smart {
		private final Exchange origin;
		public float toUsd(String source) {
			return this.origin.rate(source, "USD");
		}
	}
}
```

인터페이스를 짧게 만들고 스마트 클래스를 인터페이스와 함께 배포함으로써 공통 기능을 추출하고 코드 중복을 피할 수 있다.

