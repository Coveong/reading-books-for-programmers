# 3장. 취업

## 1. 5개 이하의 public 메서드만 노출하세요.

### [클래스의 크기는 작게 유지]

- 클래스의 크기를 정하는 기준 : public 메서드, protected 메서드의 개수
    - 생성자와 private 메서드 제외
- 적절한 public, protected 메서드 개수 = 5개

### [클래스 크기가 작을 때 장점]

- 실수할 가능성이 줄어 들어 우아해짐
- 유지보수하기 쉬움
- 메서드와 프로퍼티가 가까이 있을 수 있어 응집도가 높아짐
- 모든 메서드가 모든 프로퍼티와 상호작용 할 가능성이 높음
- 모든 사용 시나리오를 쉽게 재현할 수 있으며, 클래스가 작기 때문에 사용 시나리오의 수도 많지 않음

## 2. 정적 메서드를 사용하지 마세요.

```java
class WebPage {
	public static String read(String uri) { }
}

String html = WebPage.read("http://www.java.com");
```

- 정적 메서드는 객체 패러다임의 남용으로 사용을 중단해야 함

### [객체 대 컴퓨터 사고]

```c
int max(int a, int b) {
	if( a > b ) return a;
	return b;
}
```

- 순차적인 사고 방식 (컴퓨터 입장에서 생각하기)
    - 특징 : 흐름은 항상 순차적이며, 스크립트의 위에서 아래로 흐름 (세미콜론을 기준으로 분리)
    - 장점 : 프로그래머가 CPU와 유사한 방식으로 수행될 작업을 CPU에게 집적 지시 가능
    - 단점 : 규모가 커지면 순차적인 사고방식은 한계에 직면함

```c
(def x (max 5 9))
```

- OOP 사고 방식(객체지향적으로 생각하기)
    - 특징 : CPU에게 할 일을 지시하는 것이 아닌 정의하고, 컴퓨터가 아닌 함수처럼 사고
        
        → `x는 최댓값이다`= is a
        
- 정리
    - 순차적인 사고 방식 : 명령의 실행 흐름을 제어할 책임 개발자에게
    - OOP 사고 방식 : 정의만 하고, 객체들이 필요할 때 스스로 상호작용하도록 제어
- OOP의 정적 메서드는 정확하게 C와 어셈블리어의 서브루틴과 동일

### [선언형 스타일 대 명령형 스타일]

- 명령형 프로그래밍 : 프로그램의 상태를 변경하는 문장을 사용해 계산 방식을 서술
    
    ```java
    public static int between(int l, int r, int x){
    	return Math.min(Math.max(l, x), r);
    }
    ```
    
- 선언형 프로그래밍 : 제어 흐름을 서술하지 않고 계산 로직을 표현
    
    ```java
    Number y = new Between(5, 9, 13);
    ```
    
- 선언형 프로그램이 더 좋은 이유
    1. 선언형 방식은 더 빠름 (현재의 언어에서는 명령형이 더 빠르지만 …)
        - 명령형 : CPU에게 모든 것을 계산해!
        - 선언형 : CPU에게 결과가 실제로 필요한 시점과 위치 결정권 위임 후, 요청이 있을 때만 CPU에서 실행 = 최적화
    2. 다형성(코드 블록 사이의 의존성을 끊을 수 있는 능력)
        - 명령형 : 한 줄이라도 순서가 바뀌면 실행 안됨
        - 선언형 : 객체지향 프로그래밍에서 객체는 일급 시민으로 객체를 다른 객체로 분리 가능
            - 정적 메서드는 분리 불가(생성자의 인자로 객체 전달 불가…)
    3. 표현력
        - 명령형 : CPU가 수행해야 하는 일을 코드를 읽는 사람도 동일하게 수행해야 함
            - 알고리즘과 실행을 다루는 방법
        - 선언형 : 코드에는 구현과 관련된 세부 사항은 감춰져 있고, 오직 행동만 표현
            - 정확하게 객체와 행동에 관한 방법
    4. 응집도
        - 명령형 : 코드의 순서를 쉽게 변경할 수 있으며, 이로 인해 알고리즘 오류 발생 가능
        - 선언형 : 계산을 책임지는 모든 코드들이 한 곳에 뭉쳐있어 실수로라도 분리 불가

### [정적 메서드 처리 방법]

- 정적 메서드를 재사용하면 순수하고 깔끔한 객체지향 코드를 작성하기란 불가능
    - 처음부터 사용하면 안됨
- 만약 있다면, 코드가 객체를 직접 처리할 수 있도록 정적 메서드를 감싸는 클래스를 만들어 고립
    
    ```java
    class FileLines implements Iterable<String> {
    	private final File file;
    	public Iterator<String> iterator() {
    		return Arrays.asList(FileUtils.readLines(this.file)).iterator();
    	}
    }
    ```
    

### [유틸리티 클래스]

- 유틸리티 클래스 : 실제로는 클래스가 아닌 편의를 위해 다른 메서드들이 사용하는 정적 메서드를 모아 놓은 정적 메서드의 컬렉션
    
    ```java
    class Math {
    	private Math() {} //생성자 가시성 = private
    	pubic static int max(int a, int b ) { ... }
    }
    ```
    
    - 클래스의 인스턴스가 생성되는 것 방지 위해 private ctor 사용
        - 클래스라고 하기 애매… 인스턴스를 생성하지 않음
        - 클래스에 선언된 메서드를 제외한 어느 누구도 클래스의 인스턴스 생성 불가
- 끔찍한 안티 패턴!!

### [싱글톤 패턴]

- 싱글톤 패턴 : 정적 메서드 대신 사용할 수 있는 개념
    
    ```java
    class Math {
    	private static Math INSTANCE = new Math();
    	private Math() {}
    	public static Math getInstance() { return Math.INSTANCE; }
    ```
    
    - 싱글톤 안에는 하나의 정적 메서드가 존재
- 싱글톤 vs 유틸리티 클래스
    
    ```java
    Math.max(5, 9); // 유틸리티 클래스
    Math.getInstance().max(5, 9); // 싱글톤
    ```
    
    - 싱글톤 : 분리 가능한 의존성으로 연결되어 있음
        
        → 싱글톤 패턴을 사용하면 내부에 캡슐화된 정적 객체를 교체해 전체 개념을 테스트할 수 있음
        
    - 유틸리티 클래스 : 분리 불가능한 하드코딩된 결함도 가짐
    
    ⇒ 캡슐화된 객체를 변경할 수 있기 때문에 싱글톤이 유틸리티 클래스보다는 더 좋음
    
- 싱글톤은 전역 변수임 = 안티패턴
    - OOP에는 전역 범위가 없기 때문에 전역 변수는 순수하게 절차적인 언어를 위해 존재하는 장치

### [소프트웨어의 전체 클래스들이 사용해야 하는 기능]

- 싱글톤, 유틸리티를 사용하지 못 한다면 캠슐화 사용
- 클래스가 작업을 수행하는데 필요한 모든 요소들이 생성자에 제공되고 내부에 캡슐화돼야 함
    - 객체는 자신이 캡슐화하고 있는 프로퍼티 이외의 어떤 것도 건드려서는 안됨

### [함수형 프로그래밍]

- 함수형 코드가 훨씬 짧은데도 객체를 사용하는 이유는 객체의 표현력이 더 뛰어나고 강력하기 때문
    - 람다 표현식은 진정한 객체 지향 스타일이 아님
- 이상적인 OOP 언어에는 클래스와 함께 함수가 포함되어야 함

### [조합 가능한 데코레이터]

- 조합 가능한 데코레이터 : 다른 객체를 감싸는 객체
    
    ```java
    names = new Sorted(
    	new Unique(
    		new Capitalized(
    			new Replaced(
    				new FileNames(
    					new Directory("/var/users/*.xml");
    				)
    			), 
    			"([^.]+)\\.xml",
    			"$1"
    			)
    		)
    	)
    );
    ```
    
    → 위 코드는 실제로 어떤일도 수행하지 않음, 선언만 하고 있음
    
    - 객체들의 전체적인 행동은 내부에 캡슐화하고 있는 객체들에 의해 유도됨
    - 각 데코레이터는 내부에 캡슐화하고 있는 객체에 별도의 행동을 추가함
    - 데코레이터의 상태는 내부에 캡슐화하고 있는 객체들의 상태와 동일함
- if, for, switch, while 과 같은 절차적인 문장이 포함되어 있어서는 안됨
- 객체 지향 프로그래밍 = 더 작은 객체들을 기반으로 더 큰 객체들을 조합하는 작업
    - 정적 메서드 = 조합 불가, 합성 불가

## 3. 인자의 값으로 NULL을 절대 허용하지 마세요

- NULL은 객체가 자신의 행동을 온전히 책임진다는 객체 패러다임과 상반되는 아이디어
    - 객체를 존중한다면 객체를 피하고 무시하면 안됨
    - 조건의 존재 여부를 객체 스스로 결정하도록 해야 함
- NULL이 절차지향에 나온 이유
    - 주소의 값이 0인 경우 해당 주소에 접근할 것을 CPU에게 요청하지 않기로 함
    - 포인터의 값 = 0 = null → CPU는 프로세스를 강제로 종료
    - 자바에는 포인터 없기 때문에 역참조가 있어야 할 필요 없음
- OOP에서 존재하지 않는 인자 문제는 널 객체를 이용해 해결
    - NULL 객체 : 비어있는 것처럼 행동하는 개체
    
    ```java
    interface Mask {
    	boolean matches(File file);
    }
    
    class AnyFile implements Mask{
    	@Override
    	boolean matches(File file){return true;}
    }
    ```
    
- 메서드 인자값으로 NULL 허용하지 않았다면?
    1. 반어적인 방법으로 NULL 체크 후 예외
    2. NULL 무시 (추천)
    
    → 중요하지 않은 NULL 확인 로직으로 코드 오염X, 무시함으로써 JVM에 정의된 표준방식으로 처리!
    

## 4. 충성스러우면서 불변이거나, 아니면 상수이거나

- 객체는 불변임 = 객체가 살아있는 동안 상태가 변하지 않음
    
    ```java
    class WebPage {
    	private final URI uri;
    	
    	WebPage(URI path) { 
    		this.uri = path;
    	}
    
    	public String content() { }
    }
    ```
    
    → 불변 객체의 메서드 호출시마다 상수처럼 매번 동일한 데이터 반환 X
    
    - 객체의 행동은 예상할 수 없지만, 객체는 불변임
    - 결과가 변하기 때문에 상수는 아니지만, 객체가 대표하는 엗티티에는 충성하고 있음 = 불변객체
- 모든 객체는 식별자, 상태, 행동을포함하는 대표자
    - 식별자 : 다른 객체와 구별함
    - 상태 : 객체가 상태에 대해 알고 있는 것
    - 행동 : 요청을 수신했을 때 객체가 할 수 있는 작업
- 불변 객체와 가변 객체의 차이
    - 불변 객체 : 식별자가 존재하지 않으며, 절대로 상태를 변경할 수 없음
    - 불변 객체의 식별자 = 객체의 상태
    - 불변 객체는 별도로 인스턴스를 생성했다고 하더라도, 두 객체는 동일함
        - 동일한 상태를 캡슐화하는 것은 중복임
    - 가변 객체 : 상태 변경이 가능하기 때문에, 상태에 독립적인 식별자를 별도로 포함해야 함
    - 가변 객체는 대표하는 엔티티의 좌표를 변경할 수 있어 충성스럽지 않음

## 5. 절대 getter와 setter를 사용하지 마세요

- Cash 클래스는 단순한 자료 구조
    
    ```java
    class Cash {
    	private int dollars;
    	public int getDollars() {
    		return this.dollars;
    	}
    	public void setDollars(int value) {
    		this.dollars = value;
    	}
    }
    ```
    
    - private 프로퍼티 dollars를 포함하는 가변 클래스

### [객체 대 자료구조]

- 자료구조 : 개성도 지니지 않은 단순한 데이터 가방임
    - 투명한 글래스 박스
    - 수동적
    - 죽어있음
- 객체 : 어떤식으로도 멤버를 노출하지 않고 접근하는 것을 허용하지 않음 = 캡슐화
    - 불 투명한 블랙 박스
    - 능동적
    - 살아 있음
- 프로그래밍의 핵심인 가시성의 범위를 축소해 사물을 단순화 시키는 것
    - 사물을 단순화 시키는 방법 : 서브루틴과 데이터 집합 사용
    - 코드, 서브루틴, CPU 명령
        
        → 이 요소들이 데이터를 조작하고, 데이터는 누군가 자신을 변경하거나 읽을 떄까지 기다림
        
    - 객체지향 : 데이터는 객체 안에 캡슐화되어 있고, 객체는 살아있음
        - 메시지를 통해 객체들은 연결되고, 메시지를 전송하는 작업인 메서드 호출(코드의 실행)을 함
        - 객체는 일급 시기면, 생성자를 통한 객체의 초기화 = 소프트웨어
- 데이터를 객체 안에 감추고 절대로 외부에 노출해서는 안됨
    - 정확하게 무엇을 캡슐화하고 있고, 자료구조가 얼마나 복잡한 지는 오직 객체만이 알고 있어야 함

### [좋은 의도, 나쁜 결과]

- getter와 setter는 캡슐화 원칙을 위반하기 위해 설계됨
    - 겉으로 보기에는 데이터에 직접적으로 접근할 수 있는 진입점과 동일하게보임
- getter, setter의 내부 구현과 무관하게 이들은 데이터임
    - 행동이 아닌 데이터를 표한하고 있음

### [접두사에 관한 모든 것]

- getter/setter 접두사 : 객체가 진짜 객체가 아닌, 존중 받을 가치 없는 자료구조라는 사실 전달
    - 내부 구조에 관해 어떤것도 가정하지 않으며, 결코 객체를 자료구조라 생각하지 않음
    
    ```java
    class Cash {
    	private final int dollars;
    	
    	//데이터 중 dollars를 찾은 후 반환해
    	public int getDollars() {
    		return this.dollars;
    	}
    
    	// 얼마나 많은 달러가 필요한가요?
    	public int dollars() {
    		return this.dollars;
    	}
    }
    ```
    

## 6. 부 ctor 밖에서는 new를 사용하지 마세요

```java
class Cash{
	private final int dollars;

	public int euro() {
		return new Exchnage().rate("USD", "EUR" ) * this.dollars;
	}
}
```

→ 하드코딩된 의존성으로 Cash 클래스는 Exchange 클래스에 직접 연결되어 있음

- 둘 사이의 결합을 끊기 위해선 Cash의 소스 코드를 수정해야만 함..
- 객체가 필요한 의존성을 직접 생성하는 대신, 생성자를 통해 의존성을 주입해야 함
    
    ```java
    class Cash {
    	private final int dollars;
    	Cash() { this(0); } //부 생성자
    
    	Cash(int value) { this(value, new NYSE()); } //부 생성자
    
    	Cash(int value, Exchange exch) { //주 생성자
    		this.dollars = value;
    		this.exchange = exch;
    	}
    }
    ```
    
    1. 새로운 객체를 생성자의 인자로 전달받음
    2. privatge 프로퍼티 안에 캡슐화
    - 의존성을 제어하는 주체가 Cash가 아닌 개발자에게 있음
- 부 생성자를 제외한 어떤 곳에서도 new를 사용해서는 안됨
    - 객체들은 상호간에 충분히 분리되고 테스트 용이함
- 객체가 다른 객체를 생성자가 아닌 메서드에서 인스턴스화해야만 하는 경우
    - 해당 인스턴스로 변환해주는 Mapping 인스턴스를 캡슐화 해 해결

## 7. 인트로스팩션과 캐스팅을 피하세요

- 타입 인트로스펙션 : 리플렉션 기법 중 하나
    - 리플렉션을 사용하면 메서드, 명령어, 구문, 클래스, 객체 등을 변경할 수 있음
    - CPU가 이 요소에 접근하기 전에 쉽고 간단하게 코드 수정 가능
    - 강력한 기법이지만 코드가 런타임에 수정된다는 사실을 기억해야 함
- 클래스 캐스팅, instanecof 연산자
    
    ```java
    public <T> int size(Iterable<T> items) {
    	if(items instanceof Collection) { ... }
    }
    ```
    
    → 런타임에 타입을 확인하고, 타입에 따라 적절하게 행동하는 방식 = 잘못된 방식
    
    - 타입에 따라 객체를 차별함
    - 러타입에 객체의 타입을 조사하는 것은 클래스 사이의 결합도 높아짐
- 메서드 오버로딩을 사용해 해결가능
    
    ```java
    public <T> int size(Collection<T> items) { ... }
    public <T> int size(Iterable<T> items) { ... }
    ```
    
    - 클래스의 사용자가 어떤 메서드 호출할 지 결정
    - 컴파일러에 의해 결정됨
