# 4장. 은퇴

## 1. 절대 NULL을 반환하지 마세요

- null을 반환하게 되면 객체에 대한 신뢰를 잃음
- 객체 : 자신만의 생명주기, 자신만의 행동, 자신만의 상태를 가지는 살아있는 유기체임
    - 객체의 상태 : 존재하면서 살아 있음, 존재하지 않으면서 죽어있음
- 객체를 신뢰하기 때문에 객체와 완벽하게 동일한 의미를 가지는 변수 역시 신뢰
    - 신뢰 : 객체가 자신의 행동을 전적으로 책임지고, 우리는 어떤 식으로든 간섭하지 않음
    - 반환값을 검사하는 방식 = 신뢰가 부족함

### [빠르게 실패하기 vs 안전하게 실패하기]

- 빠르게 실패하기
    - 문제가 발생하면 곧바로 실행을 중단하고 최대한 빨리 예외를 던짐
    - 결과에 대해서는 걱정하지 않고, 실패를 감추는 대신 강조
    - 상황을 구조하지 않는 대신, 가능하면 실패를 분명하게 만듬
- 안전하게 실패하기
    - 버그, 입출력 문제, 메모리 오버플로우 등이 발생한 상황에서도 소프트웨어가 계속 실행될 수 있도록 최대한 많은 노력 기울임
    - 상황을 구조하기 위해 예외 대신 NULL을 반환함

→ 빠르게 실패하기를 통해 에러를 발견한 즉시 보고하는 경우에만 안전성과 견고함을 얻을 수 있음

### [NULL의 대안]

1. 메서드를 두 개로 나눔
    
    ```java
    public boolean exists(String name) {
    	if(/*데이터베이스에서 발견하지 못했다면 */) { return false; }
    	return true;
    }
    public User user(String name) { return /* 데이터베이스로부터 */ ;}
    ```
    
    - 첫 번째 메서드 : 객체의 존재 확인
    - 두 번째 메서드 : 객체 반환
    - 단점 : 요청을 두번 전송하기 때문에 비효율적
2. NULL을 반환하거나 예외를 던지는 대신 객체 컬렉션을 반환
    
    ```java
    public Collection<User> user(String name) {
    	if(/* 데이터베이스에서 발견하지 못했다면 */) { 
    		return new ArrayList<>(0);
    	}
    	return Collections.singleton(/* 데이터베이스로부터 */);
    }
    ```
    
    - 사용자를 발견하지 못한 경우 빈 컬렉션 반환
    - 기술적으로 NULL과 크게 다르지는 않지만 더 깔끔
3. java.util.Optional이나 유사한 도구 사용
    - java.util.Optional : 컬렉션과 동일하지만, 오직 하나의 요소만 포함 가능
    - 객체지향적인 사고방식과 거리가 멀기 때문에 사용 X
4. 널 객체 디자인 패턴
    
    ```java
    class NullUser implements User {
    	private final String label;
    	NullUser(String name) {
    		this.label = name;
    	}
    	@Override
    	public String name() {
    		return this.label;
    	}
    	@Override
    	public void raise(Cash salary) {
    		throw new IllegalStateException( "..." );
    	}
    }
    ```
    
    - 널 객체 패턴 : 원하는 객체를 발견하지 못할 경우, 일부 작업은 정상적으로 처리하지만, 나머지 작업은 처리하지 않음
    - 객체지향적 사요지만, 제한된 상황에서만 사용 가능
    - 반환된 객체의 타입을 동일하게 유지해야 함

## 2. 체크 예외만 던지세요.

→ 언체크 예외를 사용하는 것은 실수이며, 모든 예외는 체크 예외여야 함

→ 다양한 예외 타입을 만든는 것도 좋지 않음

- 체크 예외 : 해결하지 않으면 컴파일 에러 발생
    - 문제를 처리할 책임을 높은 레벨로 확대함
    - 클라이언트로 전파하면서 선언 가능
    - 가시적임(해롭고 안전하지 않은 메서드를 다루고 있다는 사실을 명시함)
- 언체크 예외 : 예외 처리를 강제하지 않음
    - 누군가 예외를 잡기 전까지 자동으로 상위로 전파되지만 예외 처리를 강제하지 않음
    - 예외에 대한 정보는 숨겨져 있음

### [꼭 필요한 경우가 아니라면 예외를 잡지 마세요]

- 가능하면 예외를 더 높은 레벨로 전파해야 함
    - 예외를 잡아야 하는 이유가 있더나 다른 선택의 여지가 없는 경우가 아니라면 예외를 잡아서는 안됨
- 이상적인 설계 : 애플리케이션의 각 진입점 별로 오직 하나의 catch문만 존재
- 안전하게 실패하기
    
    ```java
    public int length(File file) {
    	try {
    		return content(file).length();
    	} catch (IOException ex) {
    		return 0;
    	}
    }
    ```
    
    - 문제를 은폐함
    - 흐름 제어를 위한 예외 사용
    - 예외는 분기를 위한 도구가 아님

### [항상 예외를 체이닝하세요]

- 예외 되던지기 : 예외를 잡은 즉시 새로운 예외를 던짐
    
    ```java
    public int length(File file) throws Exception {
    	try {
    		return content(file).length();
    	} catch (IOException ex) {
    		throw new Exception("길이를 계산할 수 없다.", ex);
    	}
    }
    ```
    
    → 문제를 발생시켰던 낮은 수준의 근본 원인을 더 높은 수준으로 이동시킴
    
- 예외 체이닝 : 문제와 관련된 문맥을 풍부하게 만들어 줌
    - 각각의 메서드는 발생할 수 있는 모든 예외를 잡은 후, 예외를 체인닝해 다시 던져야 함
    - 여러 예외들을 내부에 담고 있는 일련의 예외 체인을 사용해 근본 원인에 관한 정보가 손실되지 않게 해야 함

### [단 한 번만 복구하세요]

- 예외를 잡아서는 안되지만 딱 한 번은 복구해야함
    - 예외를 잡지 않는다면 런타임 환경으로 예외 전달되어 JVM이 예외 잡게 됨
- 어떤 소프트웨어든 복구에 적합한 장소 존재
    - 적합한 장소 = 사용자가 애플리케이션과  커뮤니케이션하는 진입점
        - 모든 예외는 애플리케이션의 가장 높은 곳까지 전파됨 (여러개의 지점)
    - 모든 집입점에서 동일하게 복구 수행함
    - 단일 제어 지점에서 중단되도록 설계했자면, 단위 테스트에서 실패 상황 손쉽게 재현 가능
    - 이외의 장소에서는 예외를 처리하면 안됨..
- 항상 예외를 잡고, 체이닝 하고, 다시 던지고, 결국 최상위 수준에서 오직 한 번만 복구

### [관점-지향 프로그래밍을 사용하세요]

- 관점-지향-프로그래밍(AOP) : 전형적인 연산을 크게 단순화시키고 OOP로 작성된 코드의 장황함을 제거할 수 있는 기본적인 기법
- 실패 재시도
    - OOP의 코드를 깔끔한 상태로 유지하기 위해 AOP를 적용할 수 있는 현식적인 예시
    - 실패 재시도 코드 블럭 = 관점(aspsct)
- 재시도를 위해서는 예외를 잡아서 복구해야 함
    - 관점 :  제어를 위임받아 메서드를 언제, 어떻게 호출할지 결정하는 객테를 의미
- AOP 장점 : 핵심 클래스로부터 덜 중요한 기술과 메커니즘을 분리해 코드 중복을 제거할 수 있음

### [하나의 예외 타입만으로도 충분합니다]

- 예외는 다시 던지기 위해서만 잡음
    - 즉, 잡은 예외의 실제 타입에 대해서는 신경 쓸 필요가 없음
    - 예외를 사용할 일이 없기 때문에 예외의 타입 정보는 필요하지 않음

## 3. final이나 abstract이거나

- 가상 메서드는 상속과 관련해서 문제를 일으키는 주범
    - 상속 관계로 연결된 클래스의 계층 구조 파악 어려움
    - 직관적인 상속 관계 : 자식 클래스가 부모 클래스의 코드를 계승받는 하향식 프로세스
    - 오버라이딩 : 부모가 자식의 코드에 접근하는 것 가능하게 함 = 잘못된 방식
- 클래스와 메서드를 final이나 abstract 로 제한한다면 문제 해결 가능
    - 클래스가 가질 수 있는 신분 세 가지
        - final, abstract, 둘 둥 아무것도 아님
- final : 사용자 관점에서 블랙박스로 상속을 통해 수정할 수 없음
    - 불투명하고 독립적이며 자신이 어떻게 행동해야 하는지 알고 있고, 어떤 도움도 필요로 하지 않음
    - final 클래스 안의 어떤 메서드도 오버라이딩 할 수 없음
- abstract : 글래스 박스로 불완전함
    - 스스로 행동할 수 없어 누군가의 도움이 필요하고, 일부 요소가 누락되어 있음
    - 아직 클래스가 아닌, 제대로 된 클래스를 생성하기 위해 사용하는 원재료 수준…
    - abstract 클래스의 특정 메서드 오버라이딩 가능하지만 다른 메서드는 모두 final
- final과 abstract를 사용하도록 강제하면 대부분의 위치에서 상속 불가함
- 상속이 적절한 경우 : 클래스의 행동을 확장하지 않고 정제할 떄
    - 확장 : 새로운 행동을 추가해서 기존의 행동을 부분적으로 보안하는 일
    - 정제 : 부분적으로 불완전한 행동을 완전하게 만드는 일
    - OOP에서는 확장할 수 없음 = 객체에 침입해 내부의 결속력을 훼손시킬 것이라 예상 X
- 의도를 명확하게 표현해, 올바른 방식으로 예상해 추상 클래스를 설계하거나, 아니면 아예 설계하지 말아야 함

## 4. RAII를 사용하세요

- 리소스 획득이 초기화(RAII) : 파괴자 동작
    - 객체가 살아있는 동안에만 리소스 확보해야 함
    - 객체가 더 이상 필요하지 않으면 리소스를 해제하고 객체는 파괴
- Java는 GC를 이용
    - 가비지 : main이 종료된 이유에도 살아있는 객체
    - Java는 객체를 즉시 파괴하지 않고 가비지로 만든 다음, 새로운 객체를 보관하는 메모리가 부족한 경우에만 GC로 객체 제거
    - try-with-resources로 RAII와 유사한 처리 가능
    
    ```java
    int main() {
    	try(Text t = new Text("/tmp/test.txt")) {
    		t.content();
    	}
    	//try 블록이 끝날 때 객체 t를 파괴하는 대신 객체 t의 close() 메서드 호출함
    }
    ```
    
    → 이 방법 사용하려면 Text가 Cloesable 인터페이스 구현도록!
    
- 실제 리소스를 사용하는 모든 곳에서 RAII를 사용할 것을 추천함
    - JAVA에서는 AutoCloseable사용
