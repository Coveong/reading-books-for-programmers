# 은퇴

## 절대 NULL을 반환하지 마세요

**DON'T**

```java
public String title() {
  if (/* title 이 없다면 */) {
    return null
  }
}
```

- 객체라는 사상에는 우리가 신뢰하는 엔티티라는 개념이 담겨져 있다.
  - 여기서 신뢰라는 말에는 객체가 자신의 행동을 전적으로 책임지고 우리가 어떤 식으로든 간섭하지 않는다는 의미가 담겨있다.
- 객체는 존재하면서 살아있거나 존재하지 않으면서 죽어있다. 세 번째 상태는 없다.

### 빠르게 실패하기 vs 안전하게 실패하기

- NULL을 던지는 것은 안전하게 실패하기와 가깝고 예외를 던지는 것은 빠르게 실패하기에 가깝다. 
- 문제를 더 빨리 발견할수록 문제를 수정하는 시간 또한 빨라진다.
- 버그가 더 빨리 드러날수록 더 신속하게 대응할 수 있으며 이러한 버그 수정은 제품을 좀 더 안정적이고 견고하게 만들어준다.

### NULL 대신 사용할 수 있는 방법들

- 메서드를 두 개로 나누기
  - 첫 번째 메서드는 객체의 존재를 확인하고 두 번째 메서드는 객체를 반환한다.
  - 아무것도 찾지 못한 경우 두 번째 메서드는 예외를 던진다.
- 객체 컬렉션을 반환한다. (이를 테면 빈 ArrayList)
- Null 객체 디자인 패턴

## 체크 예외(Checked exception)만 던지세요

- 언테크 예외의 경우 예외의 타입을 선언하지 않아도 무방한 반면에 체크 예외는 항상 예외의 타입을 공개해야 한다.
- 따라서 체크 예외는 항상 가시적이다.

### 꼭 필요한 경우가 아니라면 예외를 잡지 마세요

- 메서드를 설계할 때 모든 예외를 잡아서 메서드를 안전하게 만들지, 상위로 문제를 전파할지를 명확하게 선택해야 한다. (저자는 상위 전파를 선호)
- 모든 catch문에는 납득할 수 있는 이유가 있어야 한다.
- == 반드시 예외를 잡아야 하는 이유가 있거나 다른 선택의 여지가 없는 경우가 아니라면 예외를 잡아서는 안된다.
- 이상적인 설계에서는 애플리케이션의 각 진입점별로 오직 하나의 catch문만 존재해야 한다.

### 항상 예외를 체이닝하세요

**예외 체이닝**

```java
try {
  return content(file).length();
} catch (IOException ex) {
  throw new Exception("길이를 계산할 수 없다.", ex);
}
```
- 문제를 발생시켰던 낮은 수준의 근본 원인을 소프트웨어의 더 높은 수준으로 이동시켰다.
- 항상 예외를 체이닝하고 절대로 원본 예외를 무시하지 마라.
- 예외 체이닝이 필요한 이유: 의미론적으로 문제와 관련된 문맥을 풍부하게 만들기 위해 필요하다.

### 단 한번만 복구하세요

- 단 한번 복구하기에 적합한 유일한 장소: main과 같은 entry point
  - main 메서드에는 애플리케이션의 가장 높은 레벨에 위치한다.
  - main 메서드에서 예외를 잡지 않는다면 런타임 환경으로 예외가 전달되고 결국 Java 가상 머신이 예외를 잡게 된다.
  - 이 경우에도 사용자는 메시지를 보지만 그 메시지는 사용자 친화적이지 않을 것이다.
 
 ### 요약
 
 항상 예외를 잡고, 체이닝하고, 다시 던지세요. 가장 최상위 수준에서 오직 한번만 복구하세요. 이게 전부입니다.
 
 ### 관점-지향 프로그래밍을 사용하세요(AOP)

실패한 오퍼레이션을 재시도하는 다음과 같은 코드를:
```java
public String content() throws IOException {
  int attempt = 0;
  while (true) {
    try {
      return http;
    } catch (IOEception ex) {
      if (attempt >= 2) {
        throw ex;
      }
    }
  }
}
```
AOP를 적용한 다음의 코드로 개선할 수 있다:
```java
@RetryOnFailure(attempts = 3)
public String content() throws IOExcpetion {
  return http();
}
```

### 하나의 예외 타입만으로도 충분합니다

- 올바르게 예외를 체이닝했다면 예외의 타입을 알아야 할 이유가 있을까?
- 예외를 잡을 때조차도 오직 한 가지 목적을 위해서만 잡아야 한다. 그것은 바로 예외를 체이닝한 후 다시 던지기 위해서다.

## final이나 abstract이거나

- 상속은 객체들의 관계를 복잡하게 만든다는 이유로 남용하면 안된다는 주의를 많이 들을 수 있다.
  - 캡술화가 상속보다 더 나은 대안이라는 이야기가 많다. 
  - 하지만 사실 우리가 원하는 것은 상속을 완전히 제거하는 것이 아니라 올바르게 사용하는 것이다.

### final vs abstract vs ???

- final: 블랙 박스. 상속을 통해 수정할 수 없고 불투명, 독립적이며 자신이 어떻게 행동해야 하는지 알고 있고 어떤 도움도 필요로 하지 않는다.
  - 기술적으로 final 클래스 안의 어떤 메서드도 오버라이딩할 수 없다.
- abstract: 글래스 박스. 스스로 행동할 수 없기 때문에 누군가의 도움이 필요하며 일부 요소가 누락되어 있다. 
  - 기술적인 관점에서 abstract 클래스는 아직 클래스가 아니다.
- 위 둘이 아닌 세 번째 신분의 경우 블랙 박스와 글래스 박스 둘 중 어느 쪽도 될 수 있기에 혼란스러울 수 있다. 사용하지 말자.

### 상속이 적절할 때

- 의무적으로 final과 abstract를 사용하도록 강제하면 대부분의 위치에서 상속을 사용할 수 없다.
- 다만 클래스의 행동을 확장(extend)하지 않고 정제(refine == 부분적으로 불완전한 행동을 완전하게 만드는 일)할 때는 상속이 적절할 수 있다.

## RAII를 사용하세요

- RAII(Resource Acquisition Is Initialization): 리소스 획득이 초기화
- 객체가 더 이상 필요하지 않으면 리소스를 해제하고 객체는 파괴된다. (가비지 컬렉션과 관계있음)
- C++에서는 파괴자를 사용하고 Java에서는 AutoCloseable을 사용하자.

# 에필로그

- Java, C#, C++, Ruby 등을 포함한 많은 유사 OOP 언어들이 더 엄격하고 더 깔끔하고 우아한 언어들로 교체될 것을 저자는 믿는다.
- 하지만 사실 훌륭한 언어가 부족한 것이 문제가 아니다.
- 문제는 우리 안에, 우리의 의식구조 안에, OOP에 대한 우리의 이해 안에, 우리가 소프트웨어에 관해 사고하고 설계하는 방식 안에, 그리고 우리의 사고방식과 원칙 안에 있다.
- 코드를 작성하는 방식을 변경하면 소프트웨어는 우아하게 응답할 것이다. 
- 언어를 다른 방식으로 사용하기 시작할 때 비로소 언어가 변하기 시작할 것이다.










