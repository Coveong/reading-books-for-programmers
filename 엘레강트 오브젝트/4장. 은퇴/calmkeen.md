# 4. 은퇴

## 1 절대 NULL을 반환하지 마세요

- 객체에 대한 신뢰가 무너진다.
- 객체는 자신만의 생명주기, 자신만의 행동, 자신만의 상태를 가지고 살아가는 유기체이다.
 -변수는 객체의 별명일 뿐이다.
- 신뢰라는 말에는 행동을 전적으로 책임지고 어떤 식으로든 간섭하지 않는다는 의미가 담겨있다.
- 마음대로 예외를 던져서는 안된다.

### 1.1 빠르게 실패하기 vs 안전하게 실패하기

안전하게 실패하기

- 버그 입출력 문제,오버플로우가 발생해도 최대한 많은 노력으르 기울여 생존을 위해 노력
- null을 반환하더래도 생존시킨다.

빠르게 실패하기

- 문제가 발생하면 실행을 중단하고 예외를 던진다.
- 단일 제어지점에서 중단되도록 설계되었다면  단위테스트에서 실패 상황을 순쉽게 재현 할수 있다.
- 테스트를 쉽게 추가할 수 있다.
- 실패를 분명하게 만든다.

### 1.2 NULL의 대안

null을 반환하는건 안전하게 실패하기에 가깝다.( 저자는 빠르게 실패하기 팬)

- null을 대체할 첫번째 방법 : 메서드를 두개로 나누는 것

첫번쨰 메서드는 객체의 존재를 확인하고 두번째 메서드는 객체를 반환한다.

이 방식의 단점: 요청을 두번하기 때문에 비효율 적이다.

- 두번째 방법 :  NULL을 반환하거나 예외를 던지는 것 대신 객체 컬랙션 반환

NULL과 크게 다르지 않지만 더 깔끔하다.

- 마지막 방법: 널 객체(NULL Obj) 디자인  패턴

원하는 객체를 발견하지 못 할 경우,  원 객체처럼 보이지만 다른 행동을 하는 객체를 반환

## 2. 체크 예외(check exception)만 던지세요

예외가 생기면 책임을 넘기거나 미루는 것이 아닌 상위 레벨로 올리거나 해결해야한다.

### 2.1 꼭 필요한 경우가 아니라면 예외를 잡지 마세요

메서드를 설계할 때 예외를 안전하게 만들지 상위문제로 전파할지 선택해야 한다.

애플리케이션의 각 진입점 별로 오직 하나의 catch문만 존재해야 한다.

글쓴이는 상위전파를 추천하는데 문제가 발생한 장소에서 문제를 해결하는 방식은 코드 전체를 유지보수하기 어렵고 불안정하게 만든다.

예외를 잡아 상황을 ‘구조’ 하는 일은 매우 정당한 이유가 있을때만 하는 행동이다.

### 2.2 항상 에외를 체이닝하세요

필요한 이유 : 문제와 관련된 문맥을 풍부하게 만들기 위해서

가각의 메서드는 발생할 수 있는 예외를 잡은 후, 예외 체이닝을 해서 다시 던져야 한다.

### 2.3 단 한번만 복구하세요

위의 방식을 다 따르면 예외는 최상위로 이동하게 될 것이고, 정적인 main으로 가게 되면 main보다 높은 곳은 존재하지 않게 된다. 모든 진입점에서 동일 작업이 실행되어야 한다.(아무리 복잡한 시스템이라도 진입점은 별로 없기 때문에)

그 이외 장소에서는 예외를 잡아 던지고 잡지 말아야합니다.

최상위에서 한번만 복구하세요

### 2.4 관점-지향 프로그래밍을 사용하세요

```java
public String content() throws IOException {
  int attempt = 0;
  while (true) {
    try {
      return http;
    } catch (IOEception ex) {
      if (attempt >= 2) {
        throw ex;
      }
    }
  }
}
```

실패하기 전까지 3번의 재시도를 한다. 위의 단 한번만 복구하라는 걸 위배한다.

이를 해결하기 위해 aop를 사용하면…

```java
@RetryOnFailure(attempts = 3)
public String content() throws IOExcpetion {
  return http();
}
```

OOP에서 흔하게 볼 수 있는 성급한 예외 복구 방법이 안좋은 아이디어며 aop로 충분히 대체가 가능하다.

## 3. final이나 abstract이거나

상속은 자주 사용되고 매우 강력한 기능이다.

상속의 단점은 상속이 객체들의 관계를 너무 복잡학 만든다는 것이다.

하지만 문제는 상속이 아닌 가상 메서드이다.

직관적으로 상속은 자식 클래스가 부모 클래스의 코드를 계승받는 하향식 프로세스이다.

하지만 부모 프로세스에 접근이 가능 한데 이부분이 유지보수의 문제덩이로 추앙받는 곳이다.

해결방법: final이나 abstract 둘중 하나로 제한한다면 문제를 없앨 수 있다.

- 상속이 절절한 경우
- 클래스의 행동을 확장하지 않고 정제할때

[요약]

final과 abstract 어느 쪽에도 해당되지 안흔 클래스와 메서드를 만드는 것은 실수이다.

의도를 명확히 표현해야한다.

## 4. RAII를 사용하세요.

*리소스 획득 초기화(Resource ACqusition Ls Initalization)*

- 객체가 살아있는 동안 리소스를 확보하는 것
- java에 유사 프로세스로 garbage collection이 있다.

하지만 java 는 객체를 즉시 파괴하지 않고 메모리에 머무를수 있는데 이것때문에  raii이 존재하지 안흔다.

파일, 스트림, 데이터베이스 리소스를 사용하는 곳에서 RAII을 사용할 것을 추천한다.
