# Chapter 1. Birth



객체의 가시성의 범위를 이해하자.

 **가시성의 범위란** 객체를 볼수 있는 범위 라고 이해하면 될것같습니다.

```java
if(price < 100){
	Cash extra = new Cash(5); price.add(ertra)
}
 //라면 ertra는 if안 쪽이 가시성의 범위인것이다.
```



### 1.1 -er로 끝나는 이름을 사용하지 마세요.



er로 끝나는 수많은 클래스가 존재합니다. Controller, Manager,Helper, Handler, Validator, Router등등.

객체는 역량(capability)으로 지어저야 한다.속성(attribute)이 아닌 할수 있는 일로 설명되야 한다.

객체는 외부와 내부를 이어주는 연결장치가 아니다!

객체는 내부에 캡슐화된 데이터를 다루기 위해 요청할 수 있는 절차의 집합이 아니다!

객체는 캡슐화된 데이터의 대표자(representative)이다!



연결자와 대표자의 차이

-  연결자는 존중받지 못하고 일을 수행하는것이 아닌 단순히 정보 전달하는 역이다!
-  대표자는 스스로 결정을 하고 행동하는 자립적 entity다!

-er로 끝난다면 실제 객체가 아니라 어떤 데이터를 다루는 절차의 집합일 뿐이 된다.



클래스의 이름을 붙일때..

- **무엇을 하는지(what he does)**가 아니라 **무엇인지(what he is)**를 생각해야 한다.



### 1.2 생성자 하나를 주 생성자로 만드세요



생성자의 개수가 더 많을수록 클래스는 더 개선되고, 사용자 입장에서 클래스를 더 편하게 사용할수 있다.

메서드가 많아지면 클래스의 초점이 흐려지고 단일 책임 원칙을 위배하게 된다. 생성자가 많아지면 유연성이 향상된다.



생성자의 주된 작업은 인자를 사용해 캡슐화하고 있는 프로퍼티를 초기화 하는 일이다.

이런 초기화 로직을 단하나의 생성자에 위치시키고 주 생성자 라고 부르기를 권하며 부 생성자들이 주 생성자를 호출하도록 만들기를 권장합니다.



```java
//예제
class Cash{
	private int dollars;
	Cash(float dlr){
	this((int) dlr);
	}
	Cash(String dlr){
	this(Cash.parse(dlr));
	}
    Cash(int dlr){
        this.dollars = dlr;
    }
}
```



하나의 주 생성자와 다수부 생성자 원칙의 핵심은 중복 코드를 방지하고 설계가 간단해 유지보수가 향상된다는 것이다.



### 1.3 생성자에 코드를 넣지 마세요



진정한 객체지향에서 인스턴스화(instantiation)란 더 작은 객체들을 조합해서 더 큰 객체를 만드는 것을  의미합니다.

객체를 조합해야하는 의미는 새로운 entity가 필요하기 때문.

객체를 인스턴스화 하면 다음은 객체가 우리를 위해 작업하게 만드는 것.

이방식이 지닌 특징은 제어 하기 쉽고 투명하다는 점입니다.



코드를 없애면...

- 투명한 객체를 만들 수 있고

- 객체를 이해하고 재사용하기 쉽고
- 요청때만 행동하며 다른 일은 하지 않는다.

- **좋은 방식으로의 게으름**



