# 1장. 출생

## 1. -er로 끝나는 이름을 사용하지 마세요

### [클래스와 객체]

- 일반적으로는 클래스가 객체를 인스턴스화한다라고 표현
    
    ```java
    class Cash {
    	public Cash(int dollars){ ... }
    }
    
    Cash five= new Cash(5);
    ```
    
- 하지만, 클래스는 객체의 팩토리라는 개념이 더 맞음
    - 클래스를 객체의 능동적인 관리자로 생각해야 함
    - 클래스 : 객체를 꺼내거나 반환할 수 있는 위치 = 저장소, 웨어 하우스

→ 객체 = 살아있는 생명체, 클래스 = 객체의 어머니

### [new 연산자]

- `new` : 객체의 팩토리를 제어할 수 있는 원시적인 수단
    - 클래스의 정적 메서드이며, 호출되면 클래스가 제어를 획득한 후 객체 생성
- java에서 제공하는 `new 연산자`는 강력하지 않음
    - `new 연산자` 유일한 작업 : 객체라고 불리는 클래스의 인스턴스를 생성하는 것
    - 유사한 객체 존재 여부, 재사용 여부 확인 X
    - `new` 동작 방식 변경할 수 있는 매개변수 제공 X

### [팩토리 패턴]

- 개념적으로 팩토리 패턴과 `new 연산자`는 동일
    - 클래스는 객체를만들고, 추적하고, 적절한 시점에 파괴하기 때문
- Java 언어에서 팩토리 패턴은 `new 연산자`를 확장한 것처럼 동작

### [객체는 연결장치가 아님]

- 객체는 객체의 외부 세계와 내부 세계를 이어주는 연결장치가 아님
    
    → 내부에 캡슐화된 데이터를 다루기 위해 요청할 수 있는 절차의 집합 X
    
    - 스스로 어떤 일을 수행할 수 없는 연결장치는 종중받지 못함
- 객체는 캡슐화된 데이터의 대표자!
    - 스스로 결정을 내리고 행동할 수 있는 자립적인 엔티티
    - 객체는 여러 객체들이 모여 구성된 연합의 대표자로프로시저의 집합처럼 행동해서는 안됨

⇒ 외부에서 목록을 이용해 어떤일을 해야 한다면 객체에게 그 일을 하도록 요청하고, 수신하 ㄴ요청을 처리하기 위해 객체 스스로 무엇을 할지 결정해야 함

### [클래스 이름 짓는 잘못된 방법]

- 클래스의 객체들이 무엇을 하고 있는지 살펴본 후 기능에 기반해 이름 짓는 방법
    
    → 클래스의 이름은 객체가 노출하고 있는 기능에 기반해서는 안됨
    
    - 무엇을 하는지(*what he does*)에 기반 X
    - 무엇인지(*what he is*)에 기반 O
        
        → 객체는 역량으로 특징지어야 함
        
- 접미사 `-er`
    - 영어 명사에는 어떤 활동을 수행하는 대상을 가리키기 위한 접미사
    - 클래스 이름이 `-er`로 끝남  = 클래스의 인스턴스는 객체가 아닌 어떤 데이터를 다루는 절차들의 집합
        
        → 절차적인 사고 방식! (데이터와 정차를 이용해 생각하고 있음)
        

### [클래스 이름 짓는 올바른 방법]

1. 클래스의 객체들이 무엇을 캡슐화할 것인지 관찰
2. 관찰한 요소들에 붙일 적합한 이름 찾음

### [요약]

- 새로운 클래스에 이름을 붙일 때는 무엇을 하는지가 아닌 무엇인지를 생각
    - 내가 무엇을 사는지와 내가 누구인지는 다름!

## 2. 생성자 하나를 주 생성자로 만드세요

### [생성자란]

- 새로운 객체에 대한 진입점
- 몇 개의 인자들을 전달받아, 어떤 일을 수행한 후, 임무를 수행할 수 있도록 객체를 준비시킴
- 주된 작업 : 제공된 인자를 사용해 캡슐화하고 있는 프로퍼티를 초기화함

### [매서드와 생성자의 개수]

- 객체는 2~3개의 메서드와 5~10개의 생성자를 포함하는 것이 적당함
    
    → 응집도가 높고 견고한 클래스에는 적은 수의 메서드와 상대적으로 많은 수의 생성자 존재
    
    - 메서드가 많음 : 유연성이 떨어지고, 단일 책임 원칙을 위반함
    - 생성자가 많음 : 유연성이 향상됨 (모든 생성자는 동일하게 행동)

### [주 생성자, 부 생성자]

- 주 생성자 : 인자를 전달받아 인자 이용해 프로퍼티 초기화 로직 ( 단 한의 생성자)
- 부 생성자 : 인자를 전달받아 파싱하거나 변환 후 주 생성자 호출

```java
class Cash{
	private int dollars;
	Cash (float dlr) { this((int) dlr); }
	Cash (String dlr) { this(Cash.parse(dlr)); }
	Cash (int dlr) { this.dollars = dlr; } //주 생성자
}
```

→ 주 생성자는 모든 부 생성자 뒤에 위치 시켜 유지보수성을 높임

- 이 원칙의 핵심 : 중복 코드를 방지하고 설계를 더 간결하게 만들기 때문에 유지보수성 향상

### [메서드 오버로딩]

- 객체 지향 프로그래밍에서 반드시 제공되어야 하는 중요한 기능
- 메서드를 비즈니스 언어와 유사하게 만들 수 있음
    
    → 코드의 가독성 극적으로 향상
    

### [요약]

- 내부 프로퍼티는 오직 한 곳에서만 초기화해야 함
    - 다른 모든 위치에서는 단순히 인자를 준비하고, 포맷팅하고, 파싱하고, 변환만 해야 함
- 유지보수성을 저해햐난 것은 복잡성과 중복
    
    → 주생성자, 부생성자 원칙을 이용하면 해결 가능
    

## 3. 생성자에 코드를 넣지 마세요

### [생성자에서 인자 다루는 법]

- 객체 초기화 프로세스를 시작하는 유일한 장소
    
    ⇒ 제공되는 인자들은 완전해야 함 = 어떤 것도 누락하지 않고 중복되는 정보 없음
    
- 생성자에서는 인자에 손대지 말아야 함
    - 코드가 없어야 하고 인자를 건드려서는 안됨
    - 필요하다면 인자들을 다른 타입의 객체로 감싸거나 가공하지 않은 형식으로 캡슐화

### [생성자에 코드를 넣으면 안 되는 이유]

- 생성자에 코드가 없을 경우 성능 최적화가 더 쉽고 코드의 실행 속도가 빨라짐
- 진정한 객체지향에서 인스턴스화 = 더 작은 객체들을 조합해 더 큰 객체를 만드는 것
    - 객체들을 조합해야 하는 이유 : 새로운 계약을 준수하는 새로운 엔티티가 필요하기 때문

### [생성자는 코드가 없어야 함]

- 생성자는 어떤 일을 수행하는 곳이 아님
    - 생성자는 코드가 없어야하고, 오직 할당문만 표함해야 함
- 객체를 인스턴스화 하고, 객체가 우리를 위해 작업을 한느 것
    
    → 위 두 단계를 겹쳐서 실행이 되면 안됨!
    

### [성능 최적화]

```java
class StringAsInteger implements Number {
	private String text;
	public StringAsInteger(String txt) { this.text = txt; }
	public int intValue() { return Integer.parseInt(this.text); }
}

Number num = new StringAsInterger("123");
num.intValue(); //파싱
num.intValue(); //파싱
```

- 파싱이 메서드 호출 될 때마다 수행됨
    - 인자를 전달된 상태 그대로 캡슐화하고 나중에 요청이 있을 때 파싱하면, 클래스의 사용자들이 파싱 시점 자유롭게 결정 가능

```java
class StringAsInteger implements Number {
	private String text;
	public StringAsInteger(String txt) { this.text = Integer.parseInt(txt); }
	public int intValue() { return this.num; }
}
```

- 파싱은 객체를 초기화하는 시점에 단 한 번 수행됨
    - 더 효율적이지만 최적화가 불가능하고, 파싱이 필요 없는 경우에도 CPU는 파싱을 위해 시간 소모

### [올바르게 설계된 객체지향]

```java
App app = new App(new Date(), new Screen());
app.run();
```

- app을 생성하고 app에 제어 전달
- `new`로 객체 생성
    - 생성하는 동안 app을 어떤 일도 처리하지 않음
    - 내부에 포함된 모든 객체 생성, 이들 동작할 수 있도록 준비만 시킴
- `run()` 메서드 호출
    - 객체들이 필요한 때와 장소에서 적절한 작업 수행하도록 함

### [요약]

- 생성자에서 코드를 없애면 사용자가 쉽게 제어할 수 있는 투명한 객체 생성 가능
    - 객체 이행 쉽고, 재사용 쉬움
    - lazy 형태의 객체 생성 가능
- 생성자 안에서 어떤 일을 처리하고 있다면 리팩토링 어려움
- 가벼운 생성자 → 설정 쉽고 투명해 객체를 따르게 만들 수 있음
