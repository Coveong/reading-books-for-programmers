# 8장 실용주의 프로젝트

## 실용주의 팀

더 나은 프로그래머가 되게끔 도와주는 실용주의 기법들을 팀 전체에 적용하는 몇 가지 방법이 있습니다.

**깨진 창문을 없애라**

품질은 팀의 이슈로 팀 전체가 깨진 창문을 용납하지 않아야 합니다. 

팀은 상품의 품질에 대해 책임을 져야합니다.

**삶은 개구리**

프로젝트 개발의 열기 속에서 전체 환경의 변화에 계속 유의하는 것은 어려운 것이기에 단단히 통제되는 팀이라도 자기네 프로젝트가 심각하게 변화하는 것에 대해 둔감할 수 있습니다.

이를 방지하기 위해 모든 사람이 적극적으로 환경 변화를 감시해야 하고, 그로 하여금 범위의 확장 등 애초 합의 사항에 있지 않았던 것들을 항상 점검해야 합니다.

**소통하라!**

팀은 나머지 세상과 명확히 의사소통해야 할 필요가 있습니다. 

훌륭한 프로젝트 팀은 뚜렷한 특성을 가지는데 이렇게 뚜렷한 특성을 가질 수 있게 만드는 마케팅 비결은 프로젝트를 시작하기 전 이름을 지어주는 것입니다.

**반복하지 마라**

팀원 간의 중복된 일을 제거하는 어려움이 많이 발생합니다. 증복은 노력을 낭비하게 하고, 결국 유지보수의 악몽을 끌어들일 수도 있습니다. 

물론 훌륭한 의사소통이 도움이 되지만 팀원 한 명을 프로젝트 사서로 임명하여 문서와 코드 저장을 관리하는 책무를 맡기는 것도 좋은 방법입니다. 작업의 다양한 기능적 측명의 핵심 사안별로 사람을 임명해도 됩니다. 

그리고 질의 응답을 주고 받으면 됩니다.

**직교성**

프로젝트의 여러 활동이 독립적으로 이루어진다는 생각은 잘못된 생각입니다. 

자신이 만든 코드의 실사용자들로부터 두어 단계 떨어져 있는 프로그래머들은 자신의 작업물이 어ㄸ너 맥락에서 사용되는지 알기 어렵습니다.

팀이 개개인의 강점 위에 스스로 내부를 조직하게 하고 기능적으로 팀을 분리시겨야 합니다.

계약, 결합도 줄이기, 직교성 등 코드를 조직할 때 쓰는 기법을 사용해 자원을 조직하면 됩니다.

```
📌  팀을 기능 중심으로 조직하라.
```

그러나 이 기법은 책임감 있는 개발자들과 강력한 프로젝트 관리가 있을 경우에만 효과가 있습니다. 프로젝트에는 최소한 기술을 담당하는 수석, 관리를 담당하는 수석이 존재해야 합니다.

- 기술 수석 : 개발 철학과 스타일을 정하며 침에 책임을 할당하고, 사람들 사이의 토론을 중재하며 지속적으로 큰 그림을 보고, 팀 사이의 불필요한 중복을 찾아 전체 노력의 직교성을 늘이려고 노력
- 관리 수석 : 각 팀이 필요로 하는 자원을 계획하고, 진척도를 모니터하고, 그에 대해 보고하며, 비즈니스 가치의 관점에서 우선순위를 결정하는 데에 도움
    
    → 바깥과의 외교과 역할
    

**자동화**

일관성과 정확성을 보장하는 훌륭한 방법은, 팀이 하는 모든 일이 자동화하는 것입니다.

자동화는 모든 프로젝트팀에게 필요불가결한 요소로 자동화를 보장받기 위해서는 한 명 혹은 그 이상의 팀원에서 도구 제작자 역할을 위임해서, 프로젝트의 단조로운 일을 자동화할 도구를 만들고 설치하도록 해야 합니다.

**덧칠을 언제 멈출지 알아라**

팀은 개인들로 이루어진다는 사실을 명심하고, 각 팀우너이 자신의 방식대로 빛나게 해주어야 합니다.

## 유비쿼터스 자동화

빌드와 릴리스 과정이건, 코드 리뷰 서류 작업이건, 혹은 프로젝트에서 거듭 발생하는 어떤 종류의 작업이건 간에 그것은 모두 자동화되어야 합니다.

**전자동**

어떤 컴포넌트든지 버전 간 차이를 조사하다 보면 놀라울 지경입니다. 사람들은 컴퓨터만틈 반복가능하지 않을 뿌더러, 그런 것을 기대해서도 안됩니다.

```
📌  수작업 절차를 사용하지 말라.
```

**프로젝트 컴파일**

`makefile`로 프로젝트를 컴파일 한다면 스크립트로 된 자동과정이므로 장점이 있지만 IDE만으로는 우리가 원하는 수준의 자동화를 이루가 어렵습니다.

**코드 생성**

공통된 정보원에서 지식을 유도하기 위해 코드를 생성합니다. 이 과정을 쉬게 하기 위해 `make`의 의존성 분석 메커니즘을 이용할 수 있습니다.

동일한 종류의 규칙을 사용해 소스코드, 헤더 파일 혹은 문서까지도 다른 형태의 자료에서 자동으로 생성해 낼 수 있습니다.

**회귀 테스트**

회귀 테스트가 실행되도록 makefile을 사용할 수 있습니다.

**빌드 자동화**

빌드는 비어있는 디렉터리 하나를 가지고 프로젝트를 밑바닥에서부터 만드는 과정으로, 최종 선적품으로 생상합니다.

프로젝트 빌드의 전형적인 단계는 다음과 같습니다.

1. 저장고에서 소스토드를 꺼낸다.
2. 일반적으로 프로젝트 디렉리 최상단의 makefile을 이용해 프로젝트를 밑바닥에서부터 빌드한다.
3. 배포용 이미지를 만듭니다. (파일 소유권과 허가 범위를 정하는 것 등 포함)
4. 테스트 실행한다.

→ 대다수 프로젝트에서 이런 수준의 빌드는 매일 밤 자동으로 실행됩니다.

중요한 점은 전체 빌드가 모두 테스트를 거치도록 하는 것입니다.

**자동화된 관리**

귀찮은 일의 일부를 해줄 셸 스크립트를 만들기로 결정하낟고 해도 여전히 필요할 때 스크립트를 실행해야 한다는 걸 잊으면 안 됩니다.

우리의 목표는 자동화, 무인화 되었으며, 내용 주도인 작업흐름을 유지하는 것입니다.

**웹사이트 생성**

웹사이트를 유지보수하는 데 너무 많은 시간을 허비해서는 안 됩니다. 모두가 정기적으로 웹에 올라가야 하고, 잘못도니 정보는 아예 없느니만 못합니다.

**승인 과정**

몇몇 프로젝트에는 지켜야 할 다양한 행정절차가 존재합니다.

이런 행정 절차를 웹페이지에 특정 형식을 만들어 검토자들이 승인 혹은 불승인을 선택, 등록할 수 있습니다.

반복적이고 지루한 작업은 컴퓨터에게 시키면, 컴퓨터가 더 잘 할 수 있습니다.

## 가차 없는 테스트

```
📌  일찍 테스트하고, 자주 테스트하라. 자동으로 테스트하라.
```

버그는 빨리 발견될수록 고치는 비용이 적어지기에 코드를 작성하자마자 테스트 하는 것이 좋습니다. 

테스트가 중요한 이유는 테스트를 통과했다는 것은 그 코드가 완료되었다고 말할 수 있는 높은 수순의 확신을 갖게 하는 것입니다.

하지만 모든 테스트를 손으로 할 수는 없습니다.

```
📌  모든 테스트가 통과하기 전엔 코딩이 다 된게 아니다.
```

코드는 결코 완료될 수 없지만, 더 중요한 것은 코드가 모든 가능한 테스트를 통과하기 전까지는 누구에게건 사용가능하다고 주장할 수 없습니다.

- **단위 테스트**
    
    → 하나의 모듈을 테스트하는 코드로 다른 모든 형태 테스트의 근간이 됩니다.
    
    → 부분이 그 자체로 제대로 작동하지 않는다면, 합쳐졌을 때도 제대로 작동하지 않을 것입니다.
    
- **통합 테스트**
    
    → 프로젝트를 구성하는 주요 서브시스템이 다른 부분과 제대로 작동하는지 보여줍니다.
    
    → 통합 테스트는 단위 테스트의 확장에 지나지 않지만, 전체 서브시스템이 계약을 제대로 지키는지 테스트합니다.
    
- **유효성 평가와 검증**
    
    →사용자들이 필요로 하는 것인가, 시스템의 기능적 요구사항을 충족하는가에 대한 테스트입니다.
    
    → 버그 없는 시스템일지라도 잘못된 질문에 답한다면 유용하지 못합니다.
    
- **자원 고갈, 에러, 그리고 복구**
    
    → 시스템이 실세계의 상황에서 어떻게 작동할지 알아야 합니다.
    
    → 메모리, 디스크 공간, 디스크 대역폭, 네트워크 대역폭, 비디오 해상도 등 제한 하상이 있습니다. 프로젝트는 무한한 자원을 보장받지 못하빈다.
    
- **성능 테스트**
    
    → 실세계 조건에서 성능 요구사항들을 만족하는지 자문해봐야 합니다.
    
- **사용편의성 테스트**
    
    → 실제 환경의 조건하에서 실제 사용자들이 시행합니다.
    
    → 인간적 요소라는 측면에서 사용편의성을 테스트합니다.
    
    → 유효성 평과와 검증과 마찬가지로, 사용편의성 테스트는 보정할 시간이 있을 때 되도록 일찍 시행해야 합니다.
    

**어떻게 테스트할까**

- **회귀 테스트**
    
    → 이전값과 현재 테스트의 출력을 비교합니다. 중요한 안전망으로 유쾌하지 못한 사고를 줄여 줍니다.
    
    → 성능, 계약, 유효성 등을 검증하기 위해 회귀 테스트를 실행해야 합니다. 
    
- **테스트 데이터**
    
    → 실세계 데이터 : 현실에서 오고 기존 시스템 등에서 자료를 수집하는 전형적인 사용자 자료
    
    → 합성 데이터 : 통계적 조건하에서 인공적으로 생성
    
- **GUI 시스템 구동**
    
    → GUI는 모든 걸 자동화할 수는 없습니다. 테스트 결과를 수작업으로 해석해야 할 수도 있습니다.
    
- **테스트를 테스트하기**
    
    → 완벽한 소프트웨어를 작성할 수 없기 때문에, 완벽한 테스트 소프트웨어 역시 작성할 수 없습니다. 그렇기에 테스트를 테스트할 필요가 있습니다.
    
    → 어떤 버그를 감지해내는 테스트를 작성한 후, 버그가 의도적으로 생기도록 하여 다음 테스트가 불평을 해대는지 확인해야 합니다.
    
    ```
    📌  파괴자를 써서 테스트를 테스트하라.
    ```
    
- **철저히 테스트하기**
    
    → 충분하게 테스트했다는 것은 알 수 없습니다. 하지만 커버리지 분석 도구는 테스트 중에 코드를 지켜보고, 코드의 어느 라인이 실행되지 않았는지 기억합니다.
    
    → 프로그램의 모든 가능한 상태를 분별해야 합니다.
    
    ```
    📌  코드 커버리지보다 상태 커버리지를 테스트하라.
    ```
    

**언제 테스트할까**

실제 제품에 들어갈 모든 코드는 나오자마자 테스트해야 합니다. 그러기에 테스틑 대부분 자동화되어야 합니다. 

'자동화'는 테스트 결과 해석의 자동화를 또한 포함합니다.

어떤 테스트들은 자주 실행하기 쉽지 않을 수 있는데, 이런 테스트는 주기적으로 일정에 따라 실행하면 됩니다. 이때, 주기적으로 실행 된다는 점이 중요합니다.

**그물 조이기**

```
📌  버그는 한 번만 잡아라.
```

현존하는 테스트의 그물을 빠져 나가는 버그가 있다면, 다음번에는 그걸 잡아낼 수 있도록 새 테스트를 추가해야 합니다.

인간 테스터가 버그를 찾아내면, 그 때가 인간 테스터가 그 버그를 찾는 마지막 순간이 되어야 합니다.

## 결국은 모두 글쓰기

문서화를 전체 개발 프로세스의 필요불가결한 부분으로 호용합니다.

노력을 중복하거나 시간을 낭비하지 않고, 문서를 늘 손에 닿는 가까이에 두면 문서 작성이 쉬워집니다.

```
📌  한국어도 하나의 프로그래밍 언어인 것처럼 다루라.
```

내부 문서 : 소스코드, 주석, 설계와 테스트 문서 등

외부 문서 : 사용자 매뉴얼과 같이 외부 세계로 출간되거나 출하되는 모든것

```
📌  문서가 애초부터 전체의 일부가 되게 하고, 나중에 집어넣으려고 하지말라.
```

- 코드 내의 주석
- 실행가능한 문서
- 테크니컬 라이터
- 찍기나 짜기
- 마크업 언어

## 위대한 유산

이론적으로는, 명세를 올바르게 구현했담녀 성공적인 애플리케이션이지만 현실적으로는 프로젝트의 성공은 사용자들의 기대를 얼마나 잘 충족하느가에 따라 측정됩니다.

```
📌  사용자의 기대를 부드럽게 넘어서라.
```

**기대를 상호 소통하기**

사용자들과 함께 일해서 장차 여러분이 어떤 것을 넘겨줄 것인지 그들이 정확히 이해하도록 해야합니다. 애플리케이션이 해결하기로 한 비즈니스 문제에 대해 절대로 눈을 떼지 말아야 합니다.

우리의 역할은 사용자들의 희망을 제어하는 것이 아닌 협동해서, 그들이 아직 이야기 하지 않은 기대까지도 포함해, 개발 과정과 최종 전달물에 대한 공통된 이해에 도달하는 것 입니다.

**한 계단 더**

사용자를 기쁘게 놀래켜주려고 노력해야 합니다. 그들이 기대하는 것보다는 조금만 더 해주고, 약간의 노력을 들여 시스템에 사용자 편의를 위한 기능을 추가하면, 관계가 좋아질 것입니다.

어떤 기능이 진정 사용자를 기쁘게 할 것인지 단서를 잡아내기 위해 프로젝트 진행 중에 사용자의 말에 귀를 기울여야 합니다. 

## 오만과 편견

어떤 프로젝트에서는 코드 소유권 때문에 협력에 차질이 새길 수 있습니다.

경계심으로 여러분의 코드를 참견자에게서 방어해서는 안되고, 여러분 역시 다른 사람들의 코드를 존중해야 합니다.

익명성은 적당주의, 실수, 태만 그리고 나쁜 코드의 번식지가 될 수 있지만 변명만 생상해 내는 문제점으로 발전합니다. 코드에는 주인이 있어야 하지만 꼭 개인일 필요는 없이 공동 소유권을 제안할 수 있습니다.

사람들이 코드에 붙여진 여러분의 이름을 보고 그것이 튼튼하고 잘 작성되고 제대호 테스트되었으며 훌륭히 문서화 되었을 것이라고 기대하도록 만들어야 합니다. 

진정으로 프로페셔널한 일, 진정한 프로페셔널이 작성한 실용주의 프로그래머