# 4장 실용주의 편집증

```
📌 완벽한 소프트웨어는 만들 수 없다.
```

완벽한 소프트웨어는 존재하지 않기에 프로그래머는 방어적으로 코딩하도록 배웠습니다. 

여기서 더 나아가 "그들은 자기 자신 역시 믿지 않는다"를 실용주의 프로그래머들은 생각합니다.

## 계약에 의한 설계

정직한 거래를 보장하는 최선의 해법 중 하나는 계약입니다.

이 개념을 소프트웨어 모듈이 서로 소통하는 것을 돕는 것에 사용할 수 있습니다.

### DBC

계약에 의한 설계 개념으로 **프로그램의 정확성**을 보장하기 위해 소프트웨어 모듈들의 권리와 책임을 문서화하는데에 초점을 맞추는 방법 입니다.

🤔 그럼, 정확한 프로그램이란 무엇인가요?

→ 스스로 자신이 하는 일이라고 주장하는 것보다 많거나 적지도 않게 딱 그 만큼만 하는 프로그램을 말합니다.

계약에 의한 설계의 핵심은 이 주장을 **문서화**하고 **검증**하는 것입니다.

소프트웨어 시스템의 함수와 메서드은 뭔가를 할때의 루틴이 존재합니다.

- **선행조건** : 루틴이 호출되기 위해 참이어야 하는 것
    
    → 루틴의 요구사항으로 제대로된 데이터를 전달하는 것은 호출하는 쪽의 책임
    
- **후행조건** : 루틴이 자기가 할 것이라고 보장하는 것
    
    → 루틴이 완료되었을 때 세상의 상태로, 무한반복은 허용되지 않음
    
- **클래스 불변식**
    
    → 호출자의 입장에서 이 조건이 언제나 참이라고 클래스는 보장
    
    → 루틴이 종료하고 호출자로 제어권이 반환되는 때에는 불변식이 참이되어야 함
    

그리고, 루틴과 그 루틴의 잠재적 호출자 간의 계약이 존재합니다.

```
만약 호출자가 루틴의 모든 선행조건을 충족한다면,
해당 루틴은 종료시 모든 후행조건과 불변식이 참이 될 것을 보증해햐 한다.
```

이 계약 내용이 지켜지지 못했다면 예외 발생, 프로그램 종료 등의 배상이 이루어집니다. 

계약에 무응하지 못하는 게 버그가 되어버리는 실수는 결코 발생해서는 안 됩니다.

```
📌 계약에 따른 설계를 하라.
```

상속과 다형성은 객체지향 언어의 기본으로 계약에 있어 편리하게 사용할 수 있습니다.

### DBC 구현

요구사항과 보증의 문제를 전면으로 내세운다는 것이 DBC의 장점입니다. 

하지만 결국 DBC는 설계 기법입니다.

자동 검사가 없이도 계약을 코드에 주석으로 넣을 수 있습니다.

## 죽은 프로그램은 거짓말을 하지 않는다

모든 에러는 정보를 줍니다. 에러가 발생할리 없다고 스스로 설득하고선 무시할 수 있는 위험을 알아야 합니다.

```
📌  일찍 작동을 멈추게 하라.
```

가능한 빨리 문제를 발견하게 되면, 좀 더 일찍 시스템을 멈출 수 있습니다. 

분명히 실행 중인 프로그램을 그냥 종료해 버리는 것은 적절하지 않을 때도 있습니다.(해제되지 않은 자원, 로그 메시지 기록 등) 

하지만 불가능한 뭔가가 발생했다는 것을 코드가 발견하면, 프로그램은 더 이상 유효하지 않다고 할 수 있기에 되도록 빨리 종료해야 합니다.

## 단정적 프로그래밍

```
📌  단정문을 사용해서 불가능한 상황을 예방하라.
```

코딩 시 절대 일어나지 않을거 같다는 생각이 든다면, 그걸 확인하는 코드를 추가해야 합니다. 

확인하는 코드를 구현하는 가장 간단한 방법은 단정문을 사용하는 것 입니다.

단정문에 전달된 조건은 부작용이 있으면 안 됩니다.

또한, 컴파일 중 단정 기능이 꺼져 있을 수 있기에 실행 되어야만 하는 코드는 절대 단정문 속에 두지 말아야 합니다.

### 단정 기능을 켜두라

- 테스트가 모든 버그를 발견한다는 가정
- 프로그램이 험한 세상에서 돌아간다는 사실을 잊는 것

→ 두 가지를 조심해야 합니다. 

첫째 방어선은 모든 가능한 에러를 체크하는 것이고, 둘째는 놓친 것들을 잡아내기 위해 단정문을 쓴는 것입니다.

퍼포먼스 문제가 있다고 해도, 정말 문제가 되는 단정문만 꺼놓아야 합니다.

## 언제 예외를 사용할까

예외에 문제가 있다면 이걸 언제 사용할지 알아야 하는 것입니다.

예외는 의외의 상황을 위해 남겨두어야 합니다. 

잡하지 않은 예외는 프로그램을 종료시킬 것이라고 가정하고 '모든 예외 처리기를 제거해도 이 코드가 여전히 실행될까' 라고 자문해 볼 때 답이 '아니오' 라면 예외가 비예외적인 상황에서 사용되고 있을 확률이 높습니다.

```
📌  예외는 예외적인 문제에 사용하라.
```

예외가 있다는 것은 즉 컨트롤의 이동이 즉각적이고 로컬하지 않다는 것을 말합니다. 일종의 연쇄 goto 같은 것입니다.

이런 프로그램은 캡슐화 역시 깨트리고 예외 처리를 통해 루틴과 그 호출자들 사이의 결합도가 높아져 버립니다.

### 에러 처리기는 또 다른 대안이다

에러 처리기는 에러가 감지되었을 때 호출되는 루틴으로 특정 부류의 에러를 처리하기 위해 루틴을 등록하게 됩니다.

에러 처리기를 예외 대신, 예외와 함께 사용된다면 예외를 처리하기 위해 코드를 추가하지 않아도 될 것입니다.

## 리소스 사용의 균형

개발자들은 코딩 시 모두 리소스를 관리하지만 할당과 해제를 다루는 일관된 계획을 갖고 있지 않습니다.

```
📌  시작한 것은 끝내라.
```

즉, 단순히 리소스를 할당하는 루틴이나 객체가 리소스를 해제하는 책임 역시 져야한다는 것을 의미합니다.

이상적으로는 리소스를 할당하는 로틴이 해제 역시 책임져야 합니다.

### 중첩 할당

리로스 할당의 기본 패턴을 확장해 한 번에 하나 이상의 리소스를 필요로하는 루틴에 적용할 수 있습니다. 

이때도 지켜야할 규칙이 있습니다.

1. 리소스를 할당한 순서의 반대로 해제해야 합니다.
    
    → 한 리소스가 다른 리소스를 참조하는 경우가 있을 수 있습니다.
    
2. 코드의 여러 곳에서 동일한 리소스 집합을 할당하는 경우, 할당 순서를 언제나 같게 해야 합니다.
    
    →교착 가능성이 줄어들 것입니다.
    

어떤 종류의 리소스를 사용하는지는 중요하지 않고 리로스를 할당하는 것이 누구이든, 그 리소스를 해제할 책임까지 져야 합니다.

### 객체와 예외

할당과 해제의 균형은 클래스의 생성자와 소멸자에서도 적용됩니다. 

클래스는 하나의 리소스를 대표하며 생성자는 그 리소스 타입의 특정 객체를 제공하고, 소멸자는 그것을 현 스코프에서 제거합니다.

- 클래스 : 리소스
- 생성자 : 리소스 타입의 특정 객체 제공
- 소멸자 : 현 스코프에서 제거

### 균형과 예외

예외를 지원하는 언어는 예외 이전에 할당된 모든 것이 깨끗이 청소된다고 보장할 수 없기에 리소스 해제에 문제가 존재합니다.

- C++에서 예외와 리소스 사용의 균형
    
    → try catch 문에서의 루틴은 나가는 경로가 최소한 두 개는 존재하기에 포인터에서 스택에 놓이는 실젝 객체를 사용해야 합니다.
    
- 자바에서 리소스 사용의 균형
    
    → 게으른 방식의 자동 객체 삭제를 사용하는데 자바에서는 finally이 try절에 포함됩니다.
    
    → finally 절 안의 코드는 반드시 실행 되기에 리소스 사용의 균형을 잡을 수 있습니다.
    

### 리소스 사용의 균형을 잡을 수 없는 경우

보통 동적 자료 구조형을 사용하는 프로그램에서 리소스 할당 방식이 아예 적절하지 않은 경우도 존재합니다.

이때, 집합적인 자료구조 안의 자료에 대해 책임을 지는 게 누구인지 정해좋아햐 합니다.

세 가지 방법이 존재합니다.

1. 최상위 구조 자신이 자기 안에 들어있는 하위 구조들의 할당을 해체할 책임
2. 최상위 구조에서 그냥 할당이 해제
3. 최상위 구조는 하나라도 하위 구조를 가지고 있을 경우 자기의 할당 해제를 거부

각 데이터 구조에 따라 달라질 수 있지만 어떤 것을 선택할지 명백하게 결정하고 그에 따라 일관성 있게 구현해야 합니다.

절차형 언어에서는 위 세 가지 방법이 아닌 다른 방법으로 구현해야 합니다.

만약, C언어를 사용한다면 C에서 데이터 구조를 능동적으로 움직이지 못하기 때문에 중요한 구조마다 표준적인 할당과 해제 기능을 제공하는 모듈을 하나씩 작성해야 합니다.

### 균형을 점검하기

실용주의 프로그래머는 자신을 포함해 아무도 믿지 않기에 정말 리소스가 적절하게 해제되었는지 점검하는 코드를 작성하는것이 좋습니다.

리소스의 종류마다 래퍼를 만들고 그 래퍼들이 모든 할당과 해제의 기록을 유지하는 것을 확인하고 래퍼들을 사용해 정말 그런지 점검해야 합니다.