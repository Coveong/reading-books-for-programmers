# 4장. 실용주의 편집증

> Tip 30.
완벽한 소프트웨어는 만들 수 없다.

# 21. 계약에 의한 설계

소프트웨어 모듈이 서로 소통하는 것을 돕기 위해 동일 개념을 사용할 수 있을까? 대답은 "그렇다"이다.

## DBC

스스로 자신이 하는 일이라고 주장하는 것보다 많거나 적지도 않게 딱 그만큼만 하는 프로그램이 정확한 프로그래밍이며, 이 주장을 문서화하고 검증하는 것이 계약에 의한 설계(Design By Contract, DBC)의 핵심이다.

모든 함수와 메서드는 무언가를 하고, 하기 전에 상태에 대한 어떤 기대를 가지고 있다. 루틴이 끝난 후에는 상태가 어떨 것이다.라는 진술을 할 수 있다. 

- 선행조건(precondition)
    - 루틴이 호출되기 위해 참이어야 하는 것.
        - 즉, **루틴의 선행조건이 위반된 경우에는 루틴이 호출되어서는 안 된다**.
    - 제대로 된 데이터를 전달하는 것은 호출하는 쪽의 책임이다.
- 후행조건(postcondition)
    - 루틴이 자기가 할 것이라고 보장하는 것
    - 루틴이 완료되었을 때 세상의 상태
    - **루틴에 후행조건이 있다는 것은 곧 그것이 종국에는 종료될 것이라는 것을 암시한다.**
        - 무한 반복은 허용되지 않는다.
- 클래스 불변식(class invariant)
    - 호출자의 입장에서 볼 때는 이 조건이 언제나 참이라고 클래스가 보장한다.
    - 루틴의 내부 처리 중에는 불변식이 참이 아닐 수도 있지만, 루틴이 종료하고 호출자로 제어권이 반환되는 때에는 불변식이 참이 되어야 한다.

> Tip 31.
계약에 따른 설계를 하라.

서브클래스는 사용자가 차이점을 모르고서도 기반 클래스 인터페이스를 통해 사용할 수 있어야 한다. 

## DBC 구현

요구사항의 보증의 문제를 전면으로 내세우는게 가장 큰 장점이다.

- 입력 도메인 범위
- 경계 조건
- 루틴이 뭘 전달한다고 약속하는지
- 루틴이 뭘 전달한다고 약속하지 않는지

이런 것들을 나열하는 것만으로도 더 나은 소프트웨어를 만들 수 있다.

### 언어 지원

자바의 경우에는 iContract가 있다. 주석(JavaDoc 형식)을 받아 단정문 로직이 포함된 새로운 소스 파일을 생성해 낸다.

## DBC와 일찍 멈추가

문제를 찾고 원인을 밝히기 위해서는, 사고가 났을 때 일찍 멈추는 것이 유리하다.

# 22. 죽은 프로그램은 거짓말을 하지 않는다

모든 에러는 정보를 준다. 

> Tip 32.
일찍 작동을 멈추게 하라

## 망치지 말고 멈추라

불가능한 뭔가가 발생했다는 것을 코드가 발견한다면, 프로그램은 더 이상 유효하지 않다. 이 시점 이후로 하는 일은 모두 수상 쩍은게 된다.

일반적으로, 죽은 프로그램이 입히는 피해는 절름발이 프로그램이 끼치는 것보다 훨씬 덜한 법이다.

# 23. 단정적 프로그래밍

- 이 코드는 지금부터 30년동안 사용될리가 없어
- 이 애플리케이션은 외국에서 사용하는 일이 없으니 국제화도 할 필요 없어
- count는 음수가 될 수 없어
- sout이 실패할리 없어

이런 류의 자기 기만을 훈련하지말자. 특히 코딩할 때는

> Tip 33.
단정문을 사용해서 불가능한 상황을 예방하라.

"절대 일어나지 않을 거야"라는 생각이 든다면, 확인하는 코드를 추가하라(예를 들면 assert)

단, 에러처리 대신 단정을 사용하지는 마라. 단정은 결코 일어나면 안되는 것들을 검사한다.

## 단정 기능을 켜두라

코드의 퍼포먼스에 영향이 있어 단정 기능을 꺼두는 경우가 있는데, 그러지 마라.

프로그램을 출시할 때 단정 기능을 꺼버리는 것은, 공중 곡예를 하면서 연습으로 한 번 건너봤다고 그물 없이 건너는 것과 비슷하다. 정 끄고 싶으면 정말 문제가 되는 단정문만 꺼두자.

# 24. 언제 예외를 사용할까

> Tip 34.
예외는 예외적인 문제에 사용하라.

예외가 있다는 것은 컨트롤러의 이동이 즉각적이고 로컬하지 않다는 것을 말한다. 예외를 정상적인 처리 과정의 일부로 사용하면 안 된다.

# 25. 리소스 사용의 균형

> Tip 35.
시작한 것은 끝내라.

리소스를 할당하는 루틴이 해제 역시도 책임져야한다.

### 중첩 할당

1. 리소스를 할당한 순서의 반대로 해제해야, 리소스를 고아로 만들지 않는다.
2. 여러 곳에서 동일한 리소스 집합을 할당하는 경우, 할당 순서를 언제나 같게하라. 교착 가능성이 줄어든다.

## 객체와 예외

리소스를 클래스로 캡슐화하자. 그리고 필요할 때마다 클래스의 객체를 생성하고, 객체가 스코프를 벗어나거나 GC에 의해 수거해 가면 객체의 소멸자가 클래스로 감싸진 리소스를 해제한다.

## 균형과 예외

예외가 발생했을 경우 리소스를 어떻게 닫을까?

자바에서는 게으른 방식의 자동 객체 삭제를 사용한다. finally절을 사용할 수도 있다.