# 2. 실용주의 접근법



## 7. 중복의 해악



소프트웨어 신뢰성을 높게 하고 개발을 이해하고 유지보수하기위해서  DRY원칙을 ㅅ사용해 보자.

>  DRY - 반복하지 마라 (Dont Repeat Yourself)



중복이 생기는 이유.

- 가용된 중복  - 개발자가 다른 선택이 없다고 느낌
- 부주의한 중복 - 개발자가 그런 생각을 못함
- 참을성 없는 중복 - 게을러짐
- 개발자간의 중복 - 여러사람이 동일 파트를 중복한다.



#### 강요된 중복

- 정보의 다양한 표현양식  - 정보의 형태가 다른 형태로 표현되는것
  - 해결 : 코드 생성기를 작성.
- 코드내의 문서화 -주석
  - 주석은 정확하고 필요한 정보만 담자.
- 문서화와 코드 - 기한이 다가오면 문서의 갱신을 뒤로 미룬다. 이점을 주의하라.
- 언어에 관한 문제 - 헤더 파일과 구현 파일에 있는 주석에 대해 생각해보자.



#### 부주의한 중복

- 모델에 따라 정규화 하라.
- 비정규화 된 데이터는 피해라.



#### 참을성 없는 중복

- 돌아가는 길이 지름길이다 라는 말을 믿지마라. 
- 나중의 고통을 피하기 위해 시간을 투자할 의지가 필요하다.



#### 개발자간의 중복

- 개바랒간의 적극적이고 빈번한 소통을 장려하는 것이다.





> 재사용하기 쉽게 만들어라.





## 8. 직교성



 그래프의 축과 같이 두 직선이 직각으로 만나는 경우를 직교한다고 함

컴퓨터에서 이용어는 독립성나 결합도 줄이기를 의미한다.



> 관련 없는 것들 간에 서로 영향이 없도록 하라.



#### 작교성의 장점

생산성 향상

- 변화가 국소화 되서 개발 시간 테스트 시간이 감소된다.
- 재사용을 촉진한다.
- 컴포넌트책임할당이 잘되어있어 새로운 결합이 편하다



 리스크 감소

- 감염코드는 격리된다.
- 시스템이 잘 깨지지 않는다.
- 테스트를 많이 하게 된다.
- 종속이 덜어진다.



### 프로젝트 팀



- 설계
  - 레이어식 접근을 해본다.





특정 기능에 대한 요구사항을 극적으로 변경했을 경우 , 몇 개의 모듈이 영향을 받는가?

직교적인 시스템에는 답이 하나여야 한다.



- 현실 세계의 변화와 설계 사이의 결합도를 얼마나 줄였는지에 대해서 확인해봐라.



#### 툴킷과 라이브러리

써드파티 툴킷이나 라이브러리를 도입할 떄 시스템의 직교성을 보존할 수 있는지 주의 깊게 살펴봐라.

lib도입할때 여러분의 코드에 있어서 안될 변화를 강요하고 있지 않은지 검토

AOP 를 사용하면 로깅되고 있는 코드와 직교적으로 로깅을 구현할 수 있다.

클래스를 분산시키는 방법 

RMI

COBRA

#### 코딩

직교성을 유지하기 위해 사용할 수 있는 몇 가지 기법이 있다.

- 코드 결합도를 줄여라.
- 전역 데이터를 피하라.
- 유사한 함수를 피하라.

#### 테스트

직교적으로 설계, 구현한 시스템은 테스트하기 더 쉽다.

시스템 컴포넌트 간의 상호작용이 형식화 되고 제한되었기 때문에 시스템 테스트의 더 많은 부분을 가각 모듈 수준에서 수행할수 있다.



## 9. 가역성



> 최종결정이란 없다.



#### 유연한 아키텍처



## 10. 예광탄



#### 어둠속에서 빛을 내는 코드

코딩에서 효과를 얻으려면 요구사항으로부터 시스템 일부 측면에까지 빨리 눈에 보이게 반복적으로 도달하게 해줄 무언가를 찾아야 한다.



예광탄 코드 접근 장점

- 사용자들은 뭔가 작동되는 것을 일찍부터 보게 된다.
- 개발자들은 들어가서 일할 수 있는 구조를 얻는다.
- 통합 작업을 수행할 기반이 생긴다.
- 보여줄 것이 생긴다.
- 진전 상황에 대해 더 정확하게 감을 잡을 수 있다.





#### 예광탄 코드 대 프로토타이핑

예광탄 코드와 프로토타이핑은 다르다.

프로토타입 -> 나중에 버릴수 있는 코드

예광탄 코드 -> 기능은 별로 없지만 완결된 코드



## 11. 프로토타입과 포스트 잇



#### 프로토타입 대상

- 아키텍처
- 기존 시스템에 추가할 새로운 기능
- 외부 데이터의 구조 혹은 내용
- 써드파티 도구나 컴포넌트
- 성능문제
- 사용자 인터페이스 설계



#### 프로토타입을 어떻게 사용할 것인가?



- 정확성 - 적절히 가짜 데이터만 사용할수 있따.
- 완정성 - 제한된 기능만을 제공하여 미리 선정한 데이터 메뉴만 작동시킨다.
- 안정성 
- 스타일 - 주석이나 문서를 만들지 않아도 된다.



#### 아키텍처 프로토타이핑

규명사항

- 주요 컴포넌트의 책임이 잘 정의되었고 적절한가?
- 주요 컴포넌트 간의 협력관계가 잘 정의었는가?
- 결합도는 최소화 되었는가?
- 인터페이스 정의와 제약 사항은 수용할만한가?
- 각 모듈 실행 중에 필요로 할때 데이터에 접근할 수 있는가?



## 12. 도메인 언어



도메인에 더 가깝게 일할 수 있는 도구를 여러분 스스로에게 제공하라.

> 문제 도메인에 가깝게 프로그래밍하라



#### 데이터 언어와 명령형 언어

데이터 언어는 애플리케이션이 사용할 어떤 형식의 데이터 구조를 만든다.

명령형 언어는 실제로 실행되며, 문장 제어 구조체를 가질 수 있고 유지 보수를 쉽게 할 수 있다.



#### 쉬운개발 아니면 쉬운 유지보수

언어를 파싱하는 코드는 작성하기 힘들지만 사람들이 언어를 이해하기는 훨씬 쉬우며 추가 확장도 편이하다.

최초노력은 유지보수비용 절감의 몇배로 보상받을 것이다.



## 13. 추정



> 추정을 통해 놀람을 피하라.



#### 얼마나 정확한 것이 충분히 정확한 것인가?

어떤 의미에서 모든 답은 추정치이다.

#### 추정치는 어디에서 오는가?

모든 추정치는 문제의 모델에서 기반한다.

그일을 해본 사람에게 물어보라.

#### 무엇을 묻고있는지를 이해하자.

#### 시스템의 모델을 만들어보라

클라이언트가 요청한 것이 무엇인지를 이해하고 대략적이고 꾸밈없는 모델ㅇ르 만들어 보라.

모델을 만드는것은 추정 프로세스에 부정확성을 야기한다.

#### 모델을 컴포넌트로 나누어라

#### 각매개 변수에 값을 주어라

#### 답을 계산하라

값이 이상하다면 이값을 너무 쉽게 버리면 안된다. 계산이 정확하다면  이 정보는 귀중한 정보가 될것이다.

#### 추정치를 기록하는 용기

#### 프로젝트 일정 추정하기

- 요구사항 체크하기
- 위험 분석하기
- 설계, 구현, 통합
- 사용자와 함께 검증하기



> 코드와 함께 일정도 반복하며 조정하라



프로젝트 초기에는 얼마나 많은 반복이 필요할지에 대해 막연히 생각할 수밖에 없지만 이를 반복하면 확신과 프로젝트를 다듬을수 있다.















