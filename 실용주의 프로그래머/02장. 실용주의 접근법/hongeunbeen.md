# 2장 실용주의 접근법

## 중복의 해악

지식은 고정적이지 않고 변화합니다. 

이러한 지식의 불안정성은 유지보수 모드에서 시스템에 대한 지식을 재조직하고 재표현하는데 대부분의 시간을 보내게 되리라는 것을 의미합니다.

유지보수 모드란 버그를 고치고 기능을 개선하는 것을 의미하기에 대부분 서비스를 출시 후에 시작된다고 하지만 실제로는 늘 유지보수 모드에 있습니다. 

설계를 하거나 코딩을 가는 중에 새로운 요구사항이 도착하거나 환경이 변할 수 있기에 요지보수는 별개의 활동이 아닌 전체 개발 과정의 일상적인 부분입니다.

🤔 그럼, 소프트웨어를 신뢰성 높게 개발하고, 개발을 이애하고 유지보수하기 쉽게 만드는 방법은 무엇인가요?

→ 유일한 방법은 DRY원칙을 따르는 것 뿐입니다.

```
DRY : 모든 지식은 시스템 내에서 단일하고, 애매하지 않고, 정말로 믿을만한 표현양식을 가져야 한다.
```

DRY를 따르지 않는다면 중복이 발생하게 됩니다.

### 어떻게 중복이 생기는가?

- 강요된 중복
- 부주의한 중복
- 참을성 없는 중복
- 개발자간의 중복

1. **강요된 중복**
    
    환경이 중복을 요구하는 것 처럼 보일 때, 중복을 피할 수 없을 것 같은 구조이지만 각각의 지식을 한 곳에 두면서 DRY 원칙을 따르는 방법이 있습니다.
    
    - 정보의 다양한 표현양식
        - 간단한 필터나 코드 생성기를 작성하는 것
        
        → ex ) 클래스 정의를 온라인 데이터베이스 스키마에서 생성하거나 애초에 스키마를 만들 때에 사용되었던 메타데이터에서 생성
        
    - 코드내의 문서화
        - 낮은 타원의 지식은 그것이 속하는 코드에 놔두고, 주석은 다른 높은 차원의 설명을 위해 아껴두는 것
        - 주석은 필연적으로 낡게 될 것이고, 믿을 수 없는 주석은 더 심각한 문제 발생
    - 문서화와 코드
        - 문서와 코드 모두는 동일 지식에 대한 표현
        
        → ex ) 테스트가 정확하게 명세를 반영하는 것을 보장하기 위해, 문서 자체에서 테스트가 자동 생성되도록 함
        
    
    만약, 언어가 모듈의 인터페이스와 그 구현을 분리하는 경우에는 상당한 양의 중복이 강요됩니다.
    
    이럴때에는 특정 언어가 요구하는 것을 극복하는 쉬운 기법이 있지는 않지만 함수 혹은 클래스 헤더 주석을 두 개 파일에 걸쳐 중복할 이유는 없습니다.
    
    헤더 파일에는 인터페이스에 대한 사항을 기록하고, 구현 파일에는 그 코드의 사용자가 알 필요가 없는 상세한 것들을 기록해야 합니다.
    

1. **부주의한 중복**
    
    설계 실수의 결과로 중복이 발생할 수 있습니다.
    
    이러한 중복은 분명히 문제가 되기에 내재하는 비즈니스 모델에 따라 정규화해야 합니다. 또한 비정규화된 데이터는 피해야 합니다.
    
    가능한 곳에서는 언제나 객체의 속성을 읽고 쓸 수 있는 액세스 함수를 사용하면 캐싱과 같은 기능을 추가하기 쉬워집니다.
    

1. **참을 수 없는 중복**
    
    시간의 압박으로 인한 중복의 유혹을 느끼게 된다면 '돌아가는 길이 지름길이다' 라는 격언을 기억해야 합니다.
    
    참을성 없는 중복은 발경하기도 쉽고 다루기도 쉬운 형태이지만, 후에 고통을 피하기 위해서는 훈련이 필요하고, 미연에 시간을 투자할 의지가 있어야 합니다.
    
2. **개발자가의 중복**
    
    발견하거나 다루기 가자아 어려운 유형의 중복으로 한 프로젝트에서 일하는 서로 다른 개발자 사이의 중복입니다.
    
    이러한 중복은 결국 유지 보수 문제로 귀결될 가능성이 있습니다.
    
    높은 차원의 해법으로, 깨끗한 설계와 강력하고 기술적인 프로젝트 리더, 그리고 그 설계 내에서 책임의 분배가 제대로 이해되도록 하는 것, 이런 것들로 개발자 간의 중복 문제를 다루어야 합니다.
    
    분명한 책임 영역으로 나뉘어지지 않는 공통 필요 기능이나 데이터는 여러 번 거듭 구현될 가능성이 있기에 공통의 문제를 다루기 위한 토론장을 만들어야 합니다.
    
    한 사람의 팀원을 프로젝트의 사서로 만들어 지식 교환을 해야 합니다. 
    
    소스 트리의 한 가운데에 유틸리티 루틴과 스크립트들이 저장될 수 있는 장소를 마련해야 합니다. 
    
    다른 사람이 자신의 코드를 등려다 본다고 기분 나빠하지 말고 코드 리뷰시 다른 사람의 소스 코드와 문서를 읽도록 해야 합니다.
    

```
📌 재사용하기 쉽게 만들라.
```

## 직교성

설계, 빌드, 테스트 그리고 확장하기에 쉬운 시스템을 만드는 데에 있어 직교성은 중요한 개념입니다.

### 직교성이란?

- 기하학에서 빌려온 용어로 그래프의 축과 같이 두 직성이 직각으로 만나는 경우 직교한단고 말합니다.
- 컴퓨팅에서는 일종의 독립성이나, 결합도 줄이기를 의미하며, 하나가 바뀌어도 나머지에 어떤 영향도 주지 않으면 서로 직교한다고 할 수 있습니다.

### 직교성의 장점

비직교적인 시스템은 본질적으로 변화와 조정을 하기 복잡합니다.

```
📌 관련없는 것들 간에 서로 영향이 없도록 하라.
```

직교적인 시스템을 작성하면 두 가지의 큰 장점이 존재합니다.

- 생산성 향상
- 리스크 감소
1. **생산성 향상**
    - 변화가 국소화 되어 개발시간과 테스트 시간이 줄어듭니다.
        
        → 간단한 컴포넌트들은 설계하고, 코딩하고, 단위 테스트하고, 그러고 잊어버릴 수 있습니다.
        
    - 직교적인 접근법은 또한 재사용을 촉진합니다.
        
        → 책임이 잘 정의되어 있다면 새로운 컴포넌트와 결합을 할 수 있고 시스템이 느슨하게 결합되어 있을 경우 재설정하고 리 엔지니어링 하기 쉽습니다.
        
    - 직교적인 컴포넌트들을 결합하는 경우 꽤 미묘한 생산성 향상이 있습니다.
        
        → 직교적인 컴포넌트들을 결합람으로써 단위 노력당 더 많은 기능을 얻을 수 있습니다.
        
2. **리스크 감소**
    - 감염된 코드는 격리됩니다.
    - 시스템이 잘 깨어지지 않습니다.
    - 더 많은 데스트를 하게 됩니다.
    - 플렛폼에 덜 종속될 것 입니다.
    

직교성의 원칙을 일에 적용할 수 있는 몇 가지 방법이 있습니다.

1. **프로젝트 팀**
    - 팀 내 업무가 겹치는 영역이 많다면 책임 영역에 대해 혼동되는데 이는 종종 직교성의 문제입니다.
    - 요청된 개별 변화에 대한 토론에 필요한 인원을 보면 프로젝트 팀 구조가 얼마나 직교성을 갖는지 확인 할 수 있습니다.
2. **설계**
    - 시스템은 협력하는 모듈들의 집합으로 구성되어야 하고, 각 모듈은 다른 부분과 독립적인 기능을 구현해야 합니다.
    - 컴포넌트들이 레이어로 조직 될 때 각 레이어는 하나의 추상화 층을 이루는데 이 레이어식 접근이 직교적 시스템을 설계하는 강력한 방법입니다.
    - 레이어 그림에서 각 레이어는 자기 밑에 있는 레이어들이 제공하는 추상화만 사용합니다.
    - 직교적 설계를 테스트하는 방법은 '특정 기능에 대한 요구사항을 극적으로 변경했을 경우, 몇 개의 영향을 받는가?'에 대한 컴포넌트의 답이 하나일 때 직교적 설계입니다.
    - 자신의 힘으로 제어할 수 없는 속성에 의존하지 말아야 합니다.
        
        → MVC는 코드간의 결합도를 줄이는 방법에 대해 설명하는데 직교적 설계에 효과적입니다.
        
3. **툴킷과 라이브러리**
    - 시스템의 직교성을 보존할 수 있는 써드파티 툴킷이나 라이브러리를 도입해야 합니다.
    - EJB 시스템은 메타데이터를 이용해 표현되기 때문에 코드밖에 존재하는데 이러한 점 때문에 같은 애플리케이션 코드가 서로 다른 EJB 트랜잭션 환경에서도 변경 없이 실행될 수 있습니다.
    - AOP도 소스코드 이곳저곳에 분산되어 있을 코드를 한 곳에 모아 AOP를 사용하면 로깅되고 있는 코드와 직교적으로 로깅을 구현할 수 있습니다.
4. **코딩**
    - 코드의 결합도를 줄여야 합니다.
        
        → 다른 모듈의 구현에 의존하지 않는 코드를 작성해야 합니다.
        
    - 전역 데이터를 피해야 합니다.
        
        → 싱글톤은 불필요한 링크를 유도하기에 주의해야 합니다.
        
    - 유사한 함수를 피해야 합니다.
        
        → 중복 코드는 구조적 문제의 징후입니다.
        
5. **테스트**
    - 버그를 수정하고 테스트를 마친 뒤 버그 수정에 대한 태그를 붙이면 각 수정에 의해 영향 받은 소스 파일의 개수를 알 수 있습니다.
6. **문서화**
    - 내용과 표현 두 축으로 문서에도 직교성이 적용되며 이를 도와주는 스타일시트와 매크로가 예시입니다.

DRY원리는 시스템 내부의 중복을 최소화시키고, 직교성은 시스템 컴포넌트 간의 상호의 존도를 줄입니다.

DRY원리로 무장하고 직교성 원리를 충실히 한다면 개발하고 있는 시스템은 더 좋아질 것입니다.

## 가역성

```
📌 최종 결정이란 없다.
```

### 유연한 아키텍처

캡슐화가 되어있고, 결합도가 높으며, 하드코딩된 로직과 매개변수가 많다면 결정을 유연하고 말랑거리게 유지하는 것은 불가능합니다.

이를 해결하기 위해선, 요구사항을 메타데이터에 넣고, 필요한 수행문을 코드에 넣을 때 애스팩트나 펄 등을 이용해 메커니즘을 자동화시켜야 합니다. 또한 어떤 메커니즘을 이용하든 이를 되돌릴 수 있도록 해야 합니다.

## 예광탄

우리는 요구사항으로무터 최종 시스템의 일부 측면에까지 빨리, 눈에 보이게, 반복적으로 도달할게 해줄 무언가를 찾아야 합니다.

```
📌 목표물을 찾기 위해 예광탄을 써라
```

예광탄 코드는 나중에 버리려고 만드는 것이 아닌 계속 사용할 코드 입니다. 상용 코드와 같게 에러 검사, 구조화, 문서화, 자기 검사가 포함되지만 단지 완전한 기능이 들어있지 않을 뿐입니다.

예광탄 코드에는 여러 장점이 있습니다.

1. 사용자들은 뭔가 작동되는 것을 일찍부터 보게 됩니다.
    - 사용자들이 각 반복 주기마다 얼마나 목표물에 가까이 왔는지 알 수 있습니다.
2. 개발자들은 들어가서 일할 수 있는 구조를 얻을 수 있습니다.
    - 애플리케이션의 모든 요소간 상호작용을 다 만들고 코드로 구체화 해 놓으면 생산성 및 일관성이 촉진됩니다.
3. 통합 작업을 수행할 기반이 생깁니다.
    - 변화는 명확하게 보이고, 상호작용들은 더 제한적이게 되어 테스팅과 디버깅 속도는 빨라지고 정확해 집니다.
4. 보열줄 것이 생깁니다.
5. 진전 상황에 대해 더 정확하게 감을 잡을 수 있습니다.
    - 개발자들은 유스 케이스를 한 번에 하나씩 다루기에 수행을 평가하기 쉽습니다.

예광탄은 목표물을 맞추는 것이 아닌 맞을 때 까지 조준을 욺기는 것이 핵심입니다.

코드가 작으면 쉽고 빠르게 변경이 가능하고 더 적은 비용과 더 빠른 속도로 반응을 모아 새로운 버전을 만들 수 있습니다.

### 예광탄 코드 VS 프로토타이핑

- 예광탄 코드
    - 접근 방법 : 다른 종류의 문제에 대한 대응 방법
    - 애플리케이션이 전체적으로 어떻게 연결되고 상호작용하는지 알고 싶거나 개발자들에게 코드를 붙일 아키텍처 골격 제시하고 싶을 경우 사용합니다.
- 프로토타이핑
    - 접근 방법 : 최종 시스템의 어떤 특정한 측면을 탐사해 보는 방법
    

즉, **예광탄 코드는 기능을 별로 없지만 완결된 코드이며, 최종 시스템 골격의 일부**를 이루는 반면, **프로토타입은 나중에 버릴 수 있는 코드**입니다.

## 프로토타입과 포스트잇

소프트웨어 프로토타입은 위험 요소를 분석하고 노출시키며 이를 매우 저렴한 비용으로 바로잡을 수 있는 기회를 얻을 수 있습니다.

🤔 프로토타입은 반드시 코드로 작성해야 하나요?

→ 꼭 그럴 필요는 없습니다. 포스트잇은 같이 애플리케이션 로직과 같은 동적인 것들을 프로토타이핑 해 볼 수 있는 도구입니다.

프로토타입은 제한된 몇 가지 질문에 답할 목적으로 설계되기에 훨씬 적은 비용으로 제품을 빠르게 개발할 수 있지만 세부사항을 포기할 수 없는 사항이라면 예광탄을 택하는 편이 좋습니다.

### 프로토타입의 대상

프로토타입의 대상은 위험을 수반하는 모든 것 입니다.

- 아키텍처
- 기존 시스템에 추가할 새로운 기능
- 외부 데이터의 구조 혹은 내용
- 써드파티 도구나 컴포넌트
- 성능 문제
- 사용자 인터페이스

위의 모든 것이 대상이 될 수 있습니다.

```
📌 프로토타입을 통해 학습하라.
```

프로토 타입은 학습 경험이며, 이를 통해 배우게 되는 교훈이 존재하고 이것이 진정한 핵심입니다.

### 프로토타입 사용 방법

🤔  프로토타입을 만들 때 무시해도 좋은 세부사항은 무엇인가요?

- **정확성** : 가짜 데이터를 사용 가능합니다.
- **완전성** : 제한된 기능만을 제공하기 합니다.
- **안정성** : 에러는 무시될 수 있습니다.
- **스타일** : 프로토타입 코드는 주석이나 문서를 만들지 않아도 됩니다.

위처럼 프로토타입은 세부사항을 생략하고 시스템의 특정 측명에 초점을 맞추기에 프로젝트를 진행하는 언어보다 고수준 언어를 이용해 구현할 수 도 있습니다.

### 아키텍처 프로토타이핑

많은 프로토타입들은 고려 중인 전체 시스템을 모델링하기 위해 만들어지는데 예광탄과는 달리 꼭 기능을 가져야 하는 것은 아닙니다.

즉, 전체적으로 시스템이 어떻게 동작할지에 대한 감을 찾는 것 뿐입니다.

- 주요 컴포넌트의 책임이 잘 정의되고 적절한가?
- 주요 컴포넌트 간의 협력관계가 잘 정의되었는가?
- 결합도는 최소화되었는가?
- 잠재적 중복을 찾아낼 수 있는가?
- 인터페이스 정의와 제약 사항은 수용할만한가?
- 각 모듈이 실행 중에 필요로 하는 데이터에 접근할 수 있는 경로를 갖고 있는가? 모듈은 데이터를 필요로 할 때 데이터에 접근할 수 있는가?

### 프로토타입을 사용하지 않을 방법

코드는 폐기될 것이고 불완전하며 완성할 수 있다는 사실을 사람들에게 분명히 주지시켜야 합니다.

만약, 사람들이 이를 이해하지 못 한다면 차라리 예광탄 접근 방식을 취해 프레임워크를 얻는게 더 좋은 방법입니다.

## 도메인 언어

```
📌 문제 도메인에 가깝게 프로그래밍하라.
```

소형 언어를 구현하는 방법은 파싱하기 쉬운 라인중심 형식의 언어를 만들거나,기존의 것을 확장하는 방법이 있습니다.

## 추정

```
📌 추정을 통해 놀람을 피하라.
```

추정에서 사용하는 단위가 결과의 해석에 차이를 가져옵니다. 양의 추정치를 말할 떄 전달하려는 정확도를 고려해 답변의 단위를 선택해야 합니다.

🤔  그럼, 추정지는 어디에서 오나요?

→ 이미 그 일을 해본 사람에게 물어보는 것입니다. 비슷한 상황에 처했던 사람에게 물어보고 이해하려 노력해야 합니다. 다른 사람들의 경험을 통해 성공적인 추정치를 낼 수 있습니다.

- **무엇을 묻고 있는지를 이해 해야 합니다.**
- **시스템의 모델을 만들어 보면 대략적인 그림이 나오게 됩니다.** 모델을 만드는 것은 추정 프로세스에 부정확성을 야기하지만 유익한 일이기에 필요합니다.
- **모델을 컴포넌트로 나누어야 합니다.** 모델을 컴포넌트로 분해하고 어떻게 상호작용하는지 기술해줄 수식어를 찾으면 각 컴포넌트가 전체 모델에 어떻게 기여하는지에 영향을 미치는 매개변수를 갖고 있는지 알 수 있습니다.
- **각 매개 변수에 값을 주어야 합니다.** 매개 변수를 찾고 값을 주다보면 부정확함이 있는데 이때 결과에 큰 영향을 미치는 매개 변수가 무엇인지 규명하고 변수의 값을 최대한 정확히 산출해야 합니다.
- **답을 계산해야 합니다.** 중요 매개 변수드르이 값을 변경시켜 가면서 여러번 계산해보고, 모델과 가장 잘 맞는 값을 찾아야 합니다. 만약, 계산이 정확하다면 문제가 잘못 되었거나 모델이 잘못되었을 것 입니다.
- **추정치를 기록해야 합니다.** 계산한 추정값을 기록하고 실제 결과와 비교해 평가를 해보는 것이 좋습니다. 추정치가 잘못되어도 원인을 찾는 습관을 들여야 합니다.

### 프로젝트 일정 추정하기

프로젝트의 일정을 정할 수 있는 유일한 방법은 진행하는 해당 프로젝트를 경험하는 것뿐입니다.

- 요구사항 체크하기
- 위험 분석하기
- 설계, 구현, 통합
- 사용자와 함께 검증하기

```
📌 코드와 함께 일정도 반복하며 조정하라.
```

초기 기능의 구현과 테스트를 마친 후, 첫 번째 반복의 끝으로 삼아야 합니다. 이 경험을 바탕으로 반복의 횟수와 각 반복에서 무엇을 할지에 대한 초기 추측을 다듬을 수 있습니다.

이렇게 공식화하고 일정 정제를 각 반복 과정의 일부로 삼았을 때, 가장 정확한 추정치를 알 수 있습니다.