# 6. 코딩하는 동안 해야 할 일들



## 31. 우연에 맡기는 프로그래밍

행운과 어쩌다 오는 성공에 의존하느 프로그래밍을 하지 않고 의도적인 프로그래밍을 해야 한다.



### 프로그래밍을 우연에 맡기면 어떻게 되는가



어떤 시도를 해봐도 구석구석을 살펴보아도 돌아가지 않는 까닭은 코드가 처음부터 왜 돌아가는지 몰랐기 때문이다.

#### 우연적 구현

단순히 코드가 작성된 방식이 그렇기 때문에 생기는 일

결국 문서화되지 않은 에러나 입력값이 특정한 조건에서만 돌아가는 겨웅와 마주치게 된다.

문제를 구지 파헤쳐야 하는 이유

- 정말로 제대로 돌아가는 것이 아닐지도 모른다. 우리에게만 그런 것처럼 보일 수도 있다.
- 여러분이 의존하는 조건이 단지 우연인 경우도 있따. 다른상황에서는 이상하게 작동할지도 모른다.
- 문서화되지 않은 동작은 라이브러리의 다음 릴리스에서 변경될 가능성이 있다.
- 불필요한 추가 호출은 코드를더 느리게 만든다.
- 추가로 호출한 루틴 떄문에 새로운 버그들이 코드에 들어올 가능성이 있다.

다른사람의 루틴을 호출할 때도 문서화된 동작에만 의존하라.

확고한 사실에 근거하지 않은 가정은 어떤 프로젝트에서든 재앙의 근원이 된다.



> 우연에 맡기는 프로그래밍을 하지 말라.



### 의도적으로 프로그래밍하기



- 언제나 자기가 지금 무엇을 하고 있는지 알아야한다.
- 맹목적으로 코딩하지 말라.
- 계획을 세우고 그것을 바탕으로 진행하라.
- 신뢴할 수 있는 것에만 기대라
- 여러분의 가정을 문서로 남겨라
- 코드만 테스트할 것이 아니라 여러분이 세운 가정도 테스트해 보아야 한다.
- 노력을 기울일 대상의 우선순의를 정하라
- 과거의 노예가 되지 말라. 기존 코드가 앞으로 짤 코드를 지배하도록 놓아두지 말라.



## 32. 알고리즘의 속도

추정에 관한 의문들은 약간의 분석, 대문자 O표기법 이라고 ㅎ불리는 근사값을 기록하는 방식을 이용하면 답을 찾을 수 있는 경우가 많다.



### 알고리즘을 추정한다는 말의 의미는 무엇인가?

알고리즘은 대개 선형적이지 않다.증가폭이 큰 알고리즘이 있따. 즉 수행시간이나 메모리 요구량이 n 보다 빠르게 늘어난다.



#### O() 표기법

근사값을 다루기 위한 수학적 방법이다



### 상식적인 추정



- 간단한 반복문
  - 알고리즘이 O(n)가능성이 높다.

- 겹친 반복문
  - 반복문안에 반복문이 들어있따면 알고리즘은 O(m x n)이 되며 m,n은  반복문의 횟수이다.
- 반씩 잘라 나가기
  - 반복문을 돌때 반으로 줄여나간다면 대수적 알고리즘 즉 O(lg(n))일 가능성이 높다.
- 나눠서 정복하기
  - 나눠서 반씩 독립시행 후 합치는 알고리즘은 O(nlog(n))이 될수 있따. 퀵 정렬이 전형적임
- 조합적
  - 아고리즘이 항목의 순열을 다루기 시작하면 거의 대부분의 수행시간은 걷잡을 수 없을 정도로 늘어난다.



### 실전에서의 알고리즘 속도

> 여러 알고리즘의 찾수를 추정하라

숫자가 외부요인에 따라 달라진다면, 수행시간이나 메모리 소비에 어떤 영향을 미칠지 생각해봐라

이론뿐만이 아니라 실무로 향했을때 고려할 내용이 있다.

> 여러분의 추정을 테스트 하라

코드 프로파일러를 사용해서 알고리즘이 돌아갈 떄 실행되는 각 단계의 반복 회수를 센 다음 규모를 바꿔가며 그래프를 그린다.



### 최고라고 언제나 최고는 아니다.

알고리즘은 선택할 때도 실용적이여야 한다.

성급한 최적활르 조심하라.

알고리즘을 개선하느라 귀중한 시간을 투자하기에 알고리즘이 정말로 병목인지 먼저 확인해라.



## 33. 리펙터링

코드 작성 , 다시 작업, 다시 설계를 통틀어서 '리팩터링'이라고 한다.



### 리팩터링은 언제 해야 하는가?



- 중복위반을 발견했다.
- 직교성이 좋지 않은 설계를 발견했다.
- 유효기간이 끝난 지식을 확인했다.
- 성능을 개선해야 한다.



#### 현실세계의 복잡한 문제들

> 일찍 리팩터링하고, 자주 리팩터링하라



리팩터링 할 것들의 명단을 만들고 유지하라.



### 리팩터링은 어떻게 하는가?

리팩터링의 본질은 재설계다.

하지만 리팩터링은 천천히 신중하게 조심스럽게 진행해야 한다.



손해보다 이득이 큰 리팩터링을 위한 간단한 조언

1. 리팩터링과 새로운 기능 추가를 동시에 하지 말라.
2. 리팩터링을 시작하기 전 든든한 테스트 집합이 있는지 확인하고 테스트를 자주 돌려본다.
3. 단계를 작게 나누어 신중하게 작업한다.



## 34. 테스트하기 쉬운 코드

### 단위 테스트

단위테스트란? 어떤 모듈에게 이것저것을 시켜보는 코드를 가리킨다.

#### 계약을 잘 지키는지 테스트해 보기

테스트 케이스를 작성하라.

코드가 계약을 지키는지 코드로 표현된 계약의 의미가 생각과 일치하는지 알수있다.

> 테스트를 염두에 두고 설계하라.

모듈을 설계할때, 심지어 루틴 하나를 설계할 때도, 지켜야하는 계약을 지키는지 테스트하는 코드도 함께 설계해야 한다.



### 단위 테스트 작성하기

테스트코드를 쉽게 접근할 수 있게 해놓아라.

1. 모듈의 모든 기능을 어떻게 이용해야 하는지 보여주는 예제.

2. 후일 코드 변경시 검증하기 위한 테스트를 구축할수 있는 수단



### 테스트 장치를 이용하기

테스트 장치는 상태를 기록으로 남기거나 예상 결과값에 비추어 출력을 분석하거나 테스트를 선택하고 실행하는 일처럼 자주 쓰이는 작업들을 다룰 수 있어야한다.

테스트 장치는

- 시작할 때 할 일과 마칠 때 할 일을 지정할수 있는 표준적인 방법
- 개별적인 테스트들을 선택하거나 아니면 모든 테스트를 한번에 선택하게 해주는 메서드
- 예상한 결과에 비추어 분석할수 있는 방법
- 실패를 보고하는 표준화된 형태



### 테스트 윈도우를 만들기

테스트 집합이 아무리 좋더라도 모든 버그를 발견할 가능성은 없다.

이에

추적메서지를 담아두는 로그 파일

실행중인 코드의 내부로 들어갈 수 있는 메커니즘의 단축키를 만드는 것등으로  내부형태를 보아  진단을 도울수 있다.



## 35. 사악한 마법사

마법사 = 개발자를 도와주는 툴, 플러그인 등



마법사를 사용했는데 마법사가  만들어 준 코드를 이해하지 못한다면 애플리케이션의 주인이 아니다.

> 자신이 이해하지 못하는, 마법사가 만들어 준 코드는 사용하지 말라.

누구도 자신이 완전히 이해하지 모하는 코드를 내놓아서는 안된다.







