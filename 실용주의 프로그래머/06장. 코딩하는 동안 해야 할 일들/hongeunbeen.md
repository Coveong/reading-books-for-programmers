# 6장 코딩하는 동안 해야 할 일들

## 우연에 맡기는 프로그래밍

우연에 맡기는 프로그래밍을 하지 말아야 합니다. 대신, 의도적으로 프로그래밍을 해야 합니다.

하지만 즐거운 우연과 주도면밀한 계획을 착각하기 쉬운 경우가 있습니다.

### 우연적 구현

우연적 구현은 단순히 코드가 지금 작성된 방식이 그렇기 때문에 생기는 일들을 가리킵니다.

따라서 결국에는 문서화되지 않은 에러나 입력값이 특정한 조건에서만 돌아가는 경우와 마주치게 됩니다.

어떻게 돌아가는지 모르는 코드가 잘 돌아갈 때 굳이 건드려야 합니다

- 정말로 제대로 돌아가는 것이 아닐지도 모릅니다.
- 의존하는 조건이 단지 우연인 경우가 있습니다.
- 문서화되지 않은 동작은 라이브러리의 다음 릴리스에서 변경될 가능성이 있습니다.
- 불필요한 추가 호출은 코드를 더 느리게 만듭니다.
- 추가로 호출한 루틴으로 새로운 버그들이 코드에 들어올 가능성이 있습니다.

다른 사람의 루틴을 호출할 때도 문서화된 동작에만 의존해야 합니다. 

### 우연적 맥락

확실한 것이 아니면 의존하면 안 됩니다.

- 언어
- GUI 환경
- 등...

### 암묵적인 가정

요구사항부터 테스트까지 우연은 항상 발생합니다. 

테스팅이 특히 거짓 원인과 우연적인 결과로 가득찬 영역입니다. 가정하지 말고 증명해야 합니다.

확고한 사실에 근거하지 않은 가정은 어떤 프로젝트에서든 재앙의 근원이 됩니다.

```
📌  우연에 맡기는 프로그래밍을 하지 말라.
```

### 의도적으로 프로그래밍하기

의도적으로 프로그래밍을 하여 개발 주기의 이른 시기에 코드를 뒤져 에러를 발견하는게 좋습니다.

- 언제나 자기가 지금 무엇을 하고 있는지 알아야 합니다.
- 맹목적으로 코딩하지 말아야 합니다.
- 계획을 세우고 그것을 바탕으로 진행해야 합니다.
- 신뢰할 수 있는 것에만 기대야 합니다.
- 가정을 문서로 남겨야 합니다.
- 코드만 테스트할 것이 아닌 스스로 세운 가정도 테스트해야 합니다.
- 노력을 기울일 대상의 우선순위를 정해야 합니다.
- 과거의 노예가 되지 말아야 합니다.

## 알고리즘의 속도

프로그래머가 날마다 사용하는 추정은 알고리즘이 사용하는 자원, 곧 시간, 프로세서, 메모리 등등을 추정하는 것입니다.

알고리즘을 추정한다는 말은 입력의 크기나 반복문 등 수행시간과 메모리 요구향을 계산하는 것입니다.

### O() 표기법

O() 표기법은 근사값을 다루기 위한 수학적 방법으로 우리가 측정하는 것(시간, 메모리, 기탕 등등)의 상한값을 정하는 표기법입니다.

예를 들면 어떤 함수가 O(n^2)이 걸린다면, 이 말은 이 함수가 실행되는 데 걸리는 시간의 최대값이 n^2보다 더 발리 늘어나지 않는다는 뜻입니다.

하지만 관습적으로 최상위 차수를 제외한 다른 모든 차수는 제거하며, 상수 곱수도 표시하지 않기에 같은 표기를 하였음에도 정확히는 알 수 없다는 단점이 있습니다.

O() 표기법은 시간에만 적용되지 않으며, 알고리즘이 사용하는 다른 어떤 자우너을 나타낼 때도 사용할 수 있습니다.(메모리 소비를 모델링하는 데에도 O() 표기법 사용 가능합니다.)

### 상식적인 추정

상식을 이용해 수많은 간단한 알고리즘의 차수를 추정할 수 있습니다.

- 간단한 반복문 : O(n)일 가능성이 높습니다.
- 겹친 반복문 :  O(n x m)으로 정렬 알고리즘은 O(n^2)이 되기 쉽습니다.
- 반씩 잘라 나가기 : O(lg(n))
- 나눠서 정복하기 : O(nlg(n))이지만 정렬된 퀵정렬 같은 경우 O(n^2)이 될 확률이 있습니다.
- 조합적 : 순열은 계승과 관련있기에 대부분의 수행시간이 걷잡을 수 없이 늘어나 휴리스틱을 동원합니다.

알고리즘 속도가 외부요인에 따라 달라진다면, 작업을 멈추고 커다란 수치가 들어왔을 경우, 수행시간아니 메모리 소비에 어떤 영향을 미칠지 생각해 보는 것이 좋습니다.

```
📌  여러분 알고리즘의 차수를 추정하라.
```

만약 실행시간이나 메모리에 대해 확실하지 않다면, 입력 레코드의 수나 런타임에 영향을 줄 것이라고 생각되는 요소를 바꾸어 가면서 실행하고 그래프를 그리면 감을 잡을 수 있습니다.

어떤 일을 하는 코드인지 코드 자체에 대해서도 생각해 봐야 합니다.

추정을 이미 했다고 하더라도, 현장에서 실제 데이터를 입력받아 돌아가는 코드의 수행시간만이 정말로 의미있는 수치입니다.

```
📌  여러분의 추정을 테스트하라.
```

만약, 정확하게 시간을 재는 일이 어렵다면, 코드 프로파일러를 사용하여 그래프로 그리면 됩니다.

### 최고라고 언제나 최고는 아니다

적당한 알고리즘을 선택할 때도 실용적이어야 할 필요가 있습니다. 

가장 빠른 알고리즘이 언제나 가장 좋은 알고리즘은 아닙니다.

입력 데이터를 알고리즘이 요구하는 형식으로 준비하는데 비용이 더 들 수도 있습니다.

성급한 최적화를 조심하고 알고리즘이 정말로 병목인지 먼저 확실히 해두어야 합니다.

## 리팩터링

코드는 정적인 존재가 아닙니다.

코드를 다시 작성하기, 다시 작업하기, 다시 설계하기는 총괄해서 리팩터링이라고 알려져 있습니다.

🤔  그럼 리팩터링은 언제 해야 하나요?

→ 언제나 바로 지금이 최적기 입니다.

리팩터링하는 것은 사실 고통 관리를 실천하는 것입니다.

- 중복
- 직교성이 좋지 않은 설계
- 유효기간이 끝난 지식
- 성능

리팩터링을 하지 않은 핑계란 없습니다. 리팩터링해야 할 것들의 명단을 만들고 유지해야 합니다.

```
📌  일찍 리팩터링하고, 자주 리팩터링하라.
```

🤔  만약, 리팩터링이 지금 당장은 힘들다면 어떻게 해야 하나요?

→ 코드를 사용하는 사람들이 코드가 조만간 리팩터링될 것이라는 사실과 이 사실이 그들의 코드에 어떤 영향을 주게 될지 인지하도록 만들어야 합니다.

### 리팩터링 하는 방법

리팩터링의 본질은 재설계입니다. 때문에 천천히, 신중하게, 조심스럽게 진행해야 하는 작업입니다.

마틴 파울러가 조언한 리팩터링 시 주의 점 입니다.

1. 리팩터링과 새로운 기능 추가를 동시에 하지 말라.
2. 리팩터링을 시작하기 전 든든한 테스트 집합이 있는지 먼저 확인한다.
3. 단계를 작게 나누어 신중하게 작업니다.

여기서 탄탄한 회귀 테스트 집합을 유지하는 것이야말로 확신을 가지고 리팩터링하기 위한 비결이라고 마틴 파울러는 지적합니다.

모듈에 큰 변화가 있다면, 일부러 빌드를 실해하도록 변화를 주는 기법도 유용합니다.

리팩터링 대상 코드에 의존하는 옛날 코드들이 컴파일이 안되게 만들어 어떤 코드가 의존하는지 쉽게 찾아내서 지금 상황에 맞도록 고칠 수 있습니다.

## 테스트하기 쉬운 코드

코드를 서로 연결하기 전 코드를 하나하나 철저하게 테스트해야만 합니다.

### 단위 테스트

각 모듈의 동작을 검증하기 위해 다른 것들과 분리시켜 놓고 테스트를 하는 방식입니다.

모듈을 통제된 환경에서 철저하게 테스트하고 나면, 더 넓은 환경에서 모듈이 어떻게 행동할 것인지 감을 잡을 수 있습니다.

단위 테스트는 일종의 인위적인 환경을 구축한 다음, 테스트할 모듈의 루틴들을 호출합니다.

이러한 단위 테스트로 개별 부분이 기대대로 잘 작동할 것이라는 믿음이 있습니다.

🤔   그럼 단위는 어떻게 나누나요?

→ 단위 테스트를 계약을 잘 지키는지 보는 테스트로 생각하는 것은 추천합니다. 어떤 단위가 자기가 맺은 계약을 존중하는지 확실하게 보여주는 테스트 케이스를 작성하고 테스트 케이스는 우리에게 두 가지 사실을 알려줍니다.

- 코드가 계약을 지키는지 여부
- 코드로 표현된 계약의 의미가 우리가 생각한 것과 일치 여부

🤔  하지만, 많은 모듈에게 의존하고 있을 경우 족립된 모듈 구조는 어떻게 테스트해야 하나요?

→ 그 모듈의 하위 컴포넌트들을 먼저 테스트 하고 하위 컴포넌트들이 모두 검증된 후에 모듈 자체를 테스트합니다. 이렇게 된다면 디버그에 들어가는 노력을 줄일 수 있습니다.

모두 번잡한 일이지만 프로젝트에서 알려지지 않은 채로 숨어있는 버그들을 찾을 수 있고, 계약을 잘 지키는지 테스트 하는 것을 감조함으로써 프로젝트 후반에 일어날 재앙을 방지합니다.

```
📌  테스트를 염두에 두고 설계하라.
```

모듈 하나, 루틴 하나를 설계할 때 항상 지켜야할 계약과 계약을 지키는지 테스트하는 코드를 함께 설계해야 합니다.

애초에 에러가 나지 않게 하는 것보다 더 좋은 방법은 없지만 코드를 구현하기 전 테스트를 만들어보면 인터페이스가 고정되기 전 시험할 수 있습니다.

### 단위 테스트 작성

단위 테스트는 찾기 편한 위치에 있어야 합니다.

- 모듈의 모든 기능을 어떻게 이요해야 하는지 보여주는 예제입니다.
- 후일 코드 변경시 검증하기 위한 회귀 테스트를 구축할 수 있는 수단입니다.

또한, 단위 테스트를 만들어 제공하는 것에서 끝나는 것이 아닌 자주 돌려봐야 합니다.

### 테스트 장치 사용하기

표준으로 사용할 테스트 장치를 만들어 사용할 수 있습니다.

- 시작할 때 할일과 마칠 때 할일을 지정할 수 있는 표준적인 방법
- 개별적인 테스트들을 선택하거나, 아니면 모든 테스트를 한꺼번에 선택하게 해주는 메서드
- 예상한 (또는 예상하지 못한) 결과에 비추어 결과를 분석할 수 있는 방법
- 실패를 보고하는 표준화된 형태

테스튼느 조립식으로 작동되어 계층의 구조의 깊이에 제한이 없어야 하며, 일부든 전체든 동일한 도구로 똑같이 쉽게 테스트 할 수 있어야 합니다.

실행중인 프로그램에 로그파일, 진단 제어창을 이용해 테스트 윈도우를 만들 수 있습니다.

결국, **테스트는 기술적이라기보다는 문화적인 것입니다.**

어떤 프로젝트라도 이런 테스트 문화를 스며들게 할 수 있습니다.

```
📌  소프트웨어를 테스트하라. 그렇지 않으면 사용자가 테스트하게 될 것이다.
```

## 사악한 마법사

자신을 위해 만들어진 코드를 이해하지 못하는 한, 자기 자신을 속이는 것입니다.

```
📌  자신이 이해하지 못하는, 마법사가 만들어 준 코드는 사용하지 말라.
```

누구도 자신이 완전히 이해하지 못하는 코드를 내놓아서는 안 됩니다.