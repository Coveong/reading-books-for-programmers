# 01장. 사용자 수에 따른 규모 확장성

# 단일 서버

> 웹 앱, DB, 캐시 등이 서버 한 대에서 실행된다.
> 
1. 사용자가 도메인 이름(api.mysite.com)을 입력해서 사이트에 접속한다
    1. 웹 애플리케이션
    2. 모바일 앱
2. DNS를 통해 IP 주소로 변환한다. (ex. 15.125.23.214)
3. 해당 IP 주소로 HTTP 요청이 전달된다.
4. 요청을 받은 웹 서버는 HTML 페이지나 JSON 형태의 응답을 반환한다.

```
[생각정리]
단일 서버는 정말 웬만하면 만들 일이 없는 것 같다.
만약 정말 단일 서버로도 충분한 트래픽양이어도 ASG를 달아두는게 좋은 것 같음
물론 ASG를 다는 순간 데이터베이스 서버는 따로 둬야해서 가격이 올라가지만 ... 🥲 
그래도 토이프로젝트가 아닌 이상 단일 서버로 냅두는 경우는 없는 것 같다.
```

# 데이터베이스

> DB를 별도의 서버로 분리한다.
> 

## 어떤 데이터베이스를 사용할까?

- RDBMS
    - 자료를 테이블, 열, 칼럼으로 표현한다.
    - 여러 테이블과 조인이 가능하다.
- NoSQL
    - 키-값 저장소(key-value store)
    - 그래프 저장소(graph store)
    - 칼럼 저장소(column store)
    - 문서 저장소(document store)
    - [https://blog.teamtreehouse.com/should-you-go-beyond-relational-databases](https://blog.teamtreehouse.com/should-you-go-beyond-relational-databases)

### NoSQL이 좋은 선택인 경우

- 아주 낮은 응답 지연시간(latency)이 요구될 때
- 다루는 데이터가 비정형일 때
- 데이터를 직렬화/역직렬화 할 수 있기만 하면 될 때
- 저장해야하는 데이터가 완전 많을 때

```
[생각정리]
최근들어 RDB, NoSQL끼리 비교할 일이 많이 생긴 것 같은데, NoSQL은 로그성 데이터를 쌓을 때 특히 좋은 것 같다.
그리고 insert/update 성능이 RDB와 비교했을때 압도적으로 빠른 것도 큰 매력인 것 같다.
그래도 RDB가 가지는 안정성은 무시 못하는듯 ... 중요한 비즈니스 로직에 사용되는 DB는 웬만하면 RDB를 사용하게 되는 것 같다.
```

# 수직적 규모 확장 vs 수평적 규모 확장

- 수직적 규모 확장(Scale up)
    - 서버를 고사양으로 바꾸는 것
    - 트래픽의 양이 적을 때에는 수직적 확장이 좋은 선택임
    - 그리고 단순함
- 수평적 규모 확장(Scale out)
    - 더 많은 서버를 추가해서 성능을 개선하는 행위

## 수직적 규모 확장의 한계

- CPU, 메모리를 무한대로 증설할 방법이 없다.
- 장애가 발생했을 때 서버가 완전히 중단된다.

→ 수평적 규모 확장법이 보다 적절하다.

```
[생각정리]
이건 책에서도 나온것처럼 아묻따 스케일 아웃이 좋은 것 같다.
단!! 당연한 이야기지만 인스턴스 크기가 적어도 프로그램은 올릴 수 있을 정도는 되어야하는 한해서 스케일 업이 되어있어한다.

최근에 있던 일인데, 인스턴스 크기가 t2.micro로 되어있는 테스트 서버가 있었다.
근데 이게 배포할 때에는 아무 문제 없이 잘 올라갔는데 자꾸 프로세스가 픽픽 죽어 디깅해보니 인스턴스의 크기가 자바를 안정적으로 띄울 수 없는 크기였던 것...
그래서 결국 t2.medium으로 변경해서 해결했다.

그리고 무엇보다 가장 중요한건 스케일업은 비싸다 ㅠ
t4g.medium이 0.03USD/h인데, t2.large가 0.09USD/h다. 둘이 메모리 차이가 4GB밖에 안나는데 가격은 3배차이남 ... 흑흑
```

## 로드밸런서

트래픽 부하를 고르게 분산하는 역할을 한다.

1. 사용자는 로드밸런서의 공개 IP 주소로 접속한다.
    - 웹 서버는 클라이언트의 접속을 직접 처리하지 않는다.
    - 서버 간 통실에서는 사설(private) IP 주소가 이용된다. (인터넷을 통해서 접근 불가능)
2. 로드밸런서 역시도 서버와 통신하기 위해 사설 IP 주소를 사용한다.

### 얻을 수 있는 이점

- 하나가 죽어도 서비스는 계속 정상적으로 돌아간다.
- 트래픽을 분산할 수 있다.

```
[생각정리]
로드밸런스는 무족건 ... 넣는게 좋다고 생각한다.
사실 부하분산도 좋긴한데, 조건에 따라 다른 대상그룹을 지정할 수 있는게 정말 좋은 것 같다. 
```

## 데이터베이스 다중화

> ㅇㅋ... 웹 계층은 어떻게 하는지 알았는데 데이터베이스는 어떻게?
> 
- master - slave로 나눈다.
    - 원본은 master 서버에, 사본은 slave 서버에 저장하는 방식
    - 단, 쓰기 연산은 master에서만 지원한다. (즉, slave에서는 읽기만 가능!)
    - 읽기 연산의 비중 > 쓰기 연산의 비중
        - 그러므로 slave의 수가 더 많다.

![Untitled](01%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%89%E1%85%A1%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%8C%E1%85%A1%20%E1%84%89%E1%85%AE%E1%84%8B%E1%85%A6%20%E1%84%84%E1%85%A1%E1%84%85%E1%85%B3%E1%86%AB%20%E1%84%80%E1%85%B2%E1%84%86%E1%85%A9%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%8C%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A5%E1%86%BC%20b9449d9553294063a070c3e02f8a4a7e/Untitled.png)

like this

### 얻을 수 있는 이점

- 성능
    - 데이터 변경은 master에, 읽기는 slave에게 분산된다.
    - 병렬로 처리될 수 있는 쿼리 수가 늘어나므로, 자연스럽게 성능도 좋아진다.
- 안정성
    - 데이터베이스 서버 가운데 일부가 파괴되어도 데이터는 보존될 수 있다.
    
    → 지역적으로 떨어진 여러 장소에 다중화시켜 놓을 수 있기 때문이다.
    
- 가용성
    - 하나의 데이터베이스에서 장애가 발생해도 다른 서버에 있는 데이터를 가져와 계속 서비스할 수 있게 된다.
    

### 장애가 나는 경우라면?

- slave
    - slave가 1개라면?
        - master에게 읽기 연산이 전달된다.
        - 새로운 slave를 생성하고 교체한다.
    - slave가 여러개면?
        - 읽기 연산은 나머지 slave에게 분산된다.
        - 새로운 slave를 생성하고 교체한다.
- master
    - slave가 1개라면?
        - master로 승격하고, 모든 연산이 일어난다.
        - 새로운 slave를 생성한다.
        - 사실 프로덕션에서는 더 복잡하다...
            - slave가 최신 상태가 아닐 가능성이 있기 때문에!
            - 이럴 때에는 복구 스크립트를 돌린다.
            - 다중 마스터(multi-master), 원형 다중화(circular replication)을 사용할 수도 있다.

```
[생각정리]
생각정리라기보단 추가적으로 알면 좋을 것 같은 내용!!

**Q. 데이터 동기화는 어떻게 할까?**
어차피 최신 데이터는 master에 있기 때문에, slave들만 바꾸면 되는데,
slave들은 폴링을 통해서 master에 쓰여진 내용으로 자기 자신을 갱신한다.

**Q. 갱신 쿼리가 slave한테 가면 어떻게하죠?**
(MySQL 기준으로) 내용 불일치를 감치하면 레플리케이션을 중지한다.

**Q. 확장?**
slave는 메모리에 맞춰서 확장이 가능하지만, master는 확장하지 않는다.
master도 확장이 가능하긴 하지만, 상당히 복잡함.
테이블을 분할해서 테이블 크기를 작게 해주고 쓰기 작업을 분산하는 경우도 있다.
만약 쓰기 작업이 너무 많은 어플리케이션이라면 처음부터 RDB를 사용하지 않는 방법도 있다.

**Q. 실제로 읽기 쿼리와 쓰기 쿼리의 비율은?**
보통 9(읽기):1(쓰기)

**Q. 다중화에 필요한 서버 대수는 몇대?**
위에서는 slave가 1개일 때를 예시로 들었지만, 사실 기본은 4대가 1세트이다. (master 1 : slave 3)
왜냐하면 slave가 2대밖에 없다면 ...
1. slave 1이 고장났다.
2. slave 1을 대체할 새로운 서버를 만든다.
3. slave 2는 slave 1에 데이터를 복사해야한다.
4. 읽기 연산이 모두 master에 가게 되는데, 과부하가 걸릴 수 있다.

무중단이 필수조건이 아니면 달라질 수도 있지만, 기본은 4대가 1세트이다. (master 1 : slave 3)
```

## 최종 설계안

1. 사용자는 DNS로부터 로드밸런서의 공개 IP 주소를 받는다.
2. 사용자는 해당 IP 주소를 사용해 로드밸런서에 접속한다.
3. HTTP 요청은 그룹 안의 서버에게 적절히 분산되어 전달된다.
4. 웹 서버는 데이터를 slave db에서 읽고, 변경 연산은 master db에게 전달한다.

> 응답 시간은 어떻게 개선하지?!
→ with cache & CDN
> 

# 캐시

> 값 비싼 연산 결과, 자주 참조되는 데이터를 메모리에 두고 가져다 쓰는것
> 

애플리케이션의 성능은 데이터베이스를 얼마나 자주 호출하느냐에 크게 좌우되는데, 캐시는 그런 문제를 완화할 수 있다.

## 캐시 계층

데이터가 잠시 보관되는 곳, 데이터베이스보다 훨씬 빠르다. 또한 캐시 계층의 규모를 독립저긍로 확장시키는 것도 가능하다.

웹서버 ↔ 캐시 ↔ DB

1. 웹 서버에 요청한다.
2. 캐시에 응답이 저장되어있는지 보고, 저장되어있다면 데이터를 클라이언트에 반환한다. 없으면 DB 질의를 통해 데이터를 찾고, 캐시에 저장한 뒤 클라이언트에 반환한다.
    - 읽기 주도형 캐시 전략

이외에도 다양한 캐시 전략이 있는데, 적절한걸 선택하자!

[https://codeahoy.com/2017/08/11/caching-strategies-and-how-to-choose-the-right-one/](https://codeahoy.com/2017/08/11/caching-strategies-and-how-to-choose-the-right-one/)

## 캐시 사용 시 유의할 점

- 데이터 갱신은 자주 일어나지 않지만 참조는 빈번하게 일어날 때 고려해보자.
- 영속적으로 보관할 데이터를 캐시에 두는 것은 바람직하지 않다. 중요한 데이터는 지속적 저장소(persistent data store)에 두어야 한다.
- 만료 기간을 적절하게 두어야 한다. 정책을 마련해두자
- 저장소의 원본을 갱신하는 연산 + 캐시를 갱신하는 연산이 단일 트랜잭션으로 처리되아야 한다. 그렇지 않으면 일관성이 깨진다.
- 캐시 서버를 한 대만 두는 경우 이 서버가 단일 장애 지점(Single Point of Failure, SPOF)가 될 수도 있다. 이걸 피하기 위해 여러 지역에 걸쳐 캐시 서버를 분산시켜야 한다.
- 캐시 메모리를 얼마나 크게 잡을것인지 고려해보아야한다. 너무 작으면 데이터가 너무 자주 캐시에 밀려나게 된다. 이를 방지하기 위해 캐시 메모리를 과할당(overpeovision)하는 것도 좋은 방법이다.
- 캐시가 꽉 찼을때 데이터 방출(evivtion) 정책을 고려해야한다.
    - 가장 흔하게 쓰이는 것은 LRU(Least Recently Used - 젤 마지막으로 쓴거 먼저 보내기)
    - LFU(Least Frequently User - 사용 빈도가 가장 낮은거 보내기)
    - FIFO(First In First Out - 가장 먼저 들어온거 먼저 보내기)

```
[생각정리]
스프링 진영에서 가장 흔하게 사용하는 spring-data-cache는 기본적으로 별도의 캐시 서드파티 모듈(ex. EHCache, Redis)이 없다면,
ConcurrentMapCache를 사용하는데, 얘는 단순 메모리 캐시고 서드파티 모듈을 등록하면 캐시 서버를 대상으로 저장할 수 있게 된다.

보편적으로 사용하는 스펙...?
TTL - 24 hours (86,400 seconds)
Memory - 는 트래픽에 따라 천차 만별인듯 ... 
Evivtion - LRU
```

# 콘텐츠 전송 네트워크(CDN)

> 정적 콘텐츠를 전송하는 쓰이는, 지리적으로 분산된 서버의 네트워크
요청 경로, 쿼리 스트링, 쿠키, 요청 헤더 등의 정보에 기반하여 HTML 페이지를 캐시
> 

1. 사용자가 이미지 URL을 통해 image.png에 접근한다.
2. CDN 서버의 캐시에 해당 이미지가 없는 경우, 서버는 원본 서버에 요청해서 파일을 가져온다.
3. 원본 서버가 파일을 CDN 서버에 반환한다. 응답의 HTTP 헤더에는 해당 파일이 얼마나 오래 캐시될 수 있는지를 설명하는 TTL 값이 들어가있다.
4. CDN 서버는 파일을 캐시하고 사용자 A에게 반환한다. 이미지 TTL에 명시된 시간이 끝날 때까지 캐시된다.
5. 사용자 B가 같은 이미지에 대한 요청을 CDN 서버에 전송한다.
6. 만료되지 않은 이미지에 대한 요청은 캐시를 통해 처리된다.

## 고려해야할 점

- 비용
    - 자주사용되지 않는 콘텐츠를 캐싱하는 것은 이득이 크지 않다.
- 적절한 만료 기한 설정
- CDN 장애에 대한 대처 방안
- 콘텐츠 무효화(invalidation) 방법
    - 만료되지 않은 콘텐츠를 CDN에서 제거하는 방법
        - CDN 사업자가 제공하는 API를 이용해서 콘텐츠 무효화
        - 콘텐츠의 다른 버전을 사용하도록 버저닝
            - image.png?v=2
            

```
[생각정리]
웬만하면 CloudFront를 사용하려고 한다. 위에 나온 비용, 응답속도 개선도 있지만 보안적인 요소에서도 중요한 역할을 하기 때문이다.

1. AWS Shield Standard를 사용하면 추가요금 없이 디도스 공격 방어 가능
2. S3는 http, CloudFront는 https
3. S3의 버킷을 퍼블릭한 상태로 두지 않아도 됨
4. 원하는 도메인 주소로 바꾸어 S3의 엔드포인트를 숨길 수 있음

그리고 CloudFront도 EC2의 Savings Plans같이 Savings Bundle을 사용해서 1년 약정으로 미리 구매할 수 있는데,
최대 30%까지 할인해준다. 굿~!
```

# 무상태(stateless) 웹 계층

> 웹 계층도 수평적으로 확장해보자!
> 

그러기 위해서는 웹에서 사용자의 상태(ex. 세션)를 저장하고 있으면 안된다.

상태 정보는 DB에 저장하자 → 이걸 무상태 웹 계층이라고 한다.

## 상태 정보에 의존적인 아키텍처

- 상태를 유지하여 요청들 사이에 상태가 공유되도록 한다. (세션 데이터, 프로필 이미지를 저장)
    - 같은 클라이언트의 요청은 늘 같은 서버로 전송되어야 한다.
    - 로드밸런스에서 고정 세션이라고 해서 이걸 지원해주긴 하는데, 상당히 부담이 될 수 있다.

## 무상태 아키텍처

- 사용자의 요청은 어떤 웹 서버로도 전달될 수 있으며, 웹 서버는 상태 정보가 필요한 경우 DB에서 가져올 수 있다.

이런 구조는 단순하고, 안정적이며 구조 변경하기 쉽다.

# 데이터 센터

사용자가 있는 위치에서 지리적으로 가까운 데이터 센터로 안내하는 것을 지리적 라우팅이라고 한다.

물론 하나가 장애나면 장애가 나지 않은 데이터 센터로 트래픽 몰빵함

## 다중 데이터 센터를 만들기 위해서 고민해보아야 하는 것

- 트래픽 우회
    - 올바른 데이터 센터로 안내를 어떻게 할것인가?
    - GeoDNS를 사용하면 가장 가까운 센터로 트래픽을 보낼 수 있게 한다.
- 데이터 동기화
    - 만약 장애가 나서 다른 데이터 센터로 몰빵이 되었는데, 어떻게 데이터를 동기화 시키는걸까?
    - 데이터를 여러 데이터 센터에 걸쳐 다중화할 수도 있다.
    - [https://netflixtechblog.com/active-active-for-multi-regional-resiliency-c47719f6685b](https://netflixtechblog.com/active-active-for-multi-regional-resiliency-c47719f6685b)
- 테스트와 배포
    - 여러 위치에서 모두 테스트를 해보아야 하고,
    - 여러 위치에 모두 배포가 되게 해야한다.
    

![Untitled](01%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%89%E1%85%A1%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%8C%E1%85%A1%20%E1%84%89%E1%85%AE%E1%84%8B%E1%85%A6%20%E1%84%84%E1%85%A1%E1%84%85%E1%85%B3%E1%86%AB%20%E1%84%80%E1%85%B2%E1%84%86%E1%85%A9%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%8C%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A5%E1%86%BC%20b9449d9553294063a070c3e02f8a4a7e/Untitled%201.png)

# 메시지 큐

> 메세지의 무손실을 보장하는, 비동기 통신을 지원하는 컴포넌트
> 

1. 생산자(producer) 또는 발행자(publisher)라고 불리는 입력 서비스가 메시지를 만들어 메시지 큐에 발행(publish)한다.
2. 큐에는 소비자(consumer) 또는 구독자(subscriber)라고 불리는 서비스 혹은 서버가 연결되어있는데, 메시지를 받아 그에 맞는 동작을 수행하는 역할을 한다.

![Untitled](01%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%89%E1%85%A1%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%8C%E1%85%A1%20%E1%84%89%E1%85%AE%E1%84%8B%E1%85%A6%20%E1%84%84%E1%85%A1%E1%84%85%E1%85%B3%E1%86%AB%20%E1%84%80%E1%85%B2%E1%84%86%E1%85%A9%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%8C%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A5%E1%86%BC%20b9449d9553294063a070c3e02f8a4a7e/Untitled%202.png)

## 장점

- 서버 간 결합이 느슨해진다. → 규모 확장성이 보장되어야 하는 안정적 애플리케이션을 구성하기 좋다.
- 생산자, 소비자는 서로의 상태를 알 필요가 없다.

```
[생각정리]
웬만하면 조회같이 응답이 필수적으로 요구되는게 아니라면 메시지 큐를 사용하는게 좋은 것 같다.
```

# 로그, 메트릭 그리고 자동화

## 로그

- 시스템의 오류와 문제들을 보다 쉽게 찾을 수 있기 때문에 중요하다.

## 메트릭

- 사업 현황에 관한 유용한 정보들을 얻을 수 있다
- 현재 상태를 손쉽게 파악할 수도 있다.
- 유용한 것들
    - 호스트 단위 메트릭
        - CPU
        - 메모리
        - 디스크 I/O
    - 종합 메트릭
        - DB 계층의 성능
        - 캐시 계층의 성능
    - 핵심 비즈니스 메트릭
        - DAU
        - 수익
        - 재방문

## 자동화

- 생산성을 높여준다.

```
[생각정리]
셋 다 필수인듯! 

로그 같은 경우에는 Elastic Search, Newrelic을 사용했는데 개인적으로는 둘 다 경험이 좋았다.
로그는 검색만 잘되면 장땡인 것 같음

메트릭은 Prometheus&Grafana, Cloud Watch를 사용했는데 이건 Grafana가 경험이 좋았다.
특히 원하는 텔레메트리를 수집하고 커스텀이 쉽게 가능하다는게 정말 좋았다! 
Cloud Watch 같은 경우에는 음 ...이 친구는 뭔가 부족한 너낌 ...
그리고 뭣보다 Grafana가 UI가 간지나고 예쁘다.

APM은 Newrelic이 제일 무난하고 좋았던 것 같다. (사실 써본게 별로 없음 .,.)
```

# 데이터베이스의 규모 확장

여기에도 수직적 규모 확장(Scale up), 수평적 규모 확장(Scale out)이 있다.

## 수직적 확장(Scale up)

- 고성능의 자원(CPU, RAM, 디스크 등)을 증설하는 방법
- 스택오버플로우는 천만 명의 사용자 전부를 한 대의 마스터 데이터베이스로 처리하기도 했다.
    - [https://nickcraver.com/blog/2013/11/22/what-it-takes-to-run-stack-overflow/](https://nickcraver.com/blog/2013/11/22/what-it-takes-to-run-stack-overflow/)

### Scale up의 한계

- 무한 증설이 불가능하다.
- SPOF로 인한 위험성이 크다.
- 비용이 많이 든다.

## 수평적 확장(Scale out)

= 샤딩(sharding)이라고도 부른다. 

> 대규모 데이터베이스를 샤드(shard)라고 부르는 작은 단위로 분할하는 기술
> 

모든 샤드는 같은 스키마를 쓰지만 샤드에 보관되는 데이터 사이에는 중복이 없다.

ex) 사용자 ID % 4로 나눠서 해당하는 테이블에 저장한다.

### 고려해야할 점

- 샤딩 키를 어떻게 정하느냐
    - 파티션 키라고도 부름
    - 데이터가 어떻게  분산될지 정하는 하나 이상의 칼럼으로 구성
    - 위 예시에서 샤딩 키는 user_id

### 샤딩을 도입할 때 풀어야하는 문제

- 데이터의 재 샤딩(resharding)
    1. 데이터가 너무 많아져서 하나의 샤드로는 더 이상 감당하기 어려울 때
    2. 샤드 간 데이터 분표가 균등하지 못해서 어떤 샤드에 할당된 공간 소모가 다른 샤드에 비해 빨리 진행될 때 (샤드 소진)
    - 안정 해시(consistent hasing) 기법을 활용하면 해결할 수 있다.
- 유명인사(celevrity) 문제 또는 핫스팟 키(hotspot key) 문제
    - 특정 샤드에 질의가 집중되어 서버에 과부하가 걸리는 문제
- 조인과 비정규화(join and de-normalization)
    - 조인이 힘들어진다.
    - 데이터베이스를 비정규화하여 하나의 테이블에서 질의가 수행될 수 있도록 하는 것이 방법

![Untitled](01%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%89%E1%85%A1%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%8C%E1%85%A1%20%E1%84%89%E1%85%AE%E1%84%8B%E1%85%A6%20%E1%84%84%E1%85%A1%E1%84%85%E1%85%B3%E1%86%AB%20%E1%84%80%E1%85%B2%E1%84%86%E1%85%A9%20%E1%84%92%E1%85%AA%E1%86%A8%E1%84%8C%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A5%E1%86%BC%20b9449d9553294063a070c3e02f8a4a7e/Untitled%203.png)

최종 !!

# 백만 사용자, 그리고 그 이상

수백만 사용자 이상을 지원하려면 새로운 전략을 도입하고 지속적으로 시스템을 가다듬어야 한다.

- 웹 계층은 무상태 계층으로
- 모든 계층에 다중화 도입
- 가능한 한 많은 데이터를 캐시할 것
- 여러 데이터 센터를 지원할 것
- 정적 콘텐츠는 CDN을 통해 서비스할 것
- 데이터 계층은 샤딩을 통해 그 규모를 확장할 것
- 각 계층은 독립적 서비스로 분할할 것
- 시스템을 지속적으로 모니터링하고 자동화 도구들을 활용할 것어떤