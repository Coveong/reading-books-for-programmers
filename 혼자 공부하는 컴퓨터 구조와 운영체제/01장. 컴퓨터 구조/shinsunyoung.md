# 컴퓨터 구조 정리 컴퓨터 구조

- 왜 컴퓨터 구조에 대해 알아야 할까?
1. 문제 해결 능력이 향상됨
2. 나에게 필요한 적절한 성능, 용량, 비용의 컴퓨터를 구매하거나 고려하며 개발할 수 있음

## 컴퓨터가 이해하는 정보

- 데이터
    - 컴퓨터가 이해하는 숫자, 문자, 이미지, 동영상 같은 정적인 정보
    - 단위
        - 0과 1을 나타내는 가장 작은 정보단위를 비트(bit)라고 함. 1아니면 0밖에 표현 못함
            - 2비트는 몇 개의 정보 표현이 가능할까? → 00, 01, 10, 11 … 총 4개
            - 3비트는 몇 개 가능할까? → 000, 100, 010, 001, 110, 101, 011, 111 … 총 8개
            - n비트는 몇 개 가능할까? → 2^n개
        - 8비트 = 1바이트(byte), 그 다음에는 1000개씩 해서 kB → MB → GB → TB
        - 워드(word)라는 것도 있음
            - CPU가 한 번에 처리할 수 있는 정보의 크기 단위
            - 32bit = 2byte = 1word
            - 워드의 절반을 half word, 워드를 full word, 워드 크기*2면 double word
    - 진수 표기법
        - 2진수
            - 2진수 표기를 하기 위해 아래첨자(2)를 붙이거나 0b를 붙임 (ex. **0b**1000, 1000**(2)**)
            - **음수 표기법은? 모든 0과 1을 뒤집고, 거기에 1을 더한 값 (ex. 11은 01이 됨)**
            - 음수와 양수 구분은? 플래그 사용
        - 16진수
            - 10부터는 A, 16부터는 10
            - 표기를 위해 아래첨자(16)을 붙이거나 0x를 붙임 (ex. **0x**15, 15**(16)**)
            - 2진수로 변환이 용이함
                - 각 글자를 따로 이진수로 변환하고, 그대로 이어붙이면 됨
                - 1A2B(16)가 있을때, 1, A, 2, B를 2진수로 표현하면 0001, 1010, 0010, 1011이 되는데, 이걸 이어붙이면 0001101000101011이 2진수가 되는거임
                - 2진수를 16진수로 바꿀때도 똑같이 4개씩 끊고 16진수로 바꾸면 됨
    - 문자 집합과 인코딩
        - 문자 집합: 컴퓨터가 인식하고 표현할 수 있는 문자의 모음
            - 아스키코드: 7비트로 표현 가능, 2^7 = 128개의 문자를 표현할 수 있음. 나머지 1비트는 패리티 비트라고 오류 검출을 위해 사용되는 비트임… 너무 적음
            - EUC-KR: 완성형 인코딩(하나의 글자에 고유한 코드를 부여하는 방식). 한글 한 글자를 표현하려면 16비트가 필요함. 4자리 16진수! 다만 쀍, 쀓, 믜같은 글자는 표현 불가능
            - UTF-8: 유니코드 문자 집합 사용.
                - 예를 들어 한은 D55C(16), 글은 AE00(16). 둘 다 0800~FFFF 사이이니 3바이트로 표현됨
                - 한: 11101101 10010101 10011100
                - 글: 11101010 10111000 1000000
        - 인코딩: 문자 집합에 있는 문자를 0과 1로 바꾸는 것
        - 디코딩: 0과 1로 이루어진 문자 코드를 사람이 이해할 수 있는 문자로 변환하는 과정
- 명령어
    - 데이터를 움직이고, 컴퓨터를 작동시키는 정보
    - 프로그래밍 언어는 어떻게 명령어가 될까?
        - 고급 언어: 사람을 위한 언어
            - 고급언어는 컴파일 방식 or 인터프리터 방식으로 작동된다
                - 컴파일 방식: 소스 코드(고급 언어) -컴파일러(컴파일)→ 저급언어(목적 코드) -(링킹)→ 실행 파일
                - 인터프리터 방식: 한 줄씩 저급 언어로 변환. 컴파일 방식보다 느림
        - 저급 언어: 기계를 위한 언어
            - 기계어: 0과 1의 명령어 비트로 이루어진 언어
            - 어셈블리어: 기계어를 읽기 편한 형태로 번역한 언어 (ex. push rbp, pop rbp …)
    - 명령어의 구조
        - 뭐를(연산 코드), 무엇을 대상으로(오퍼랜드)
            - ex. 더해라(연산 코드), 100과 120을 (오퍼랜드)
        - 오퍼랜드
            - 하나도 없으면 0-주소 명령어, 하나면 1, 2개면 2 … 3까지 있음!!
            - 오퍼랜드 필드에는 주소를 담는 경우가 많음. 그래서 “주소 필드”라고 부르기도 함
                - 12-16비트는 연산 코드(4비트 사용)
                - 0-12비트는 오퍼랜드. 즉, 2주소인 경우에 오퍼랜드 하나당 표현할 수 있는건 2^6 = 64개밖에 없을수 있음… 만약 3-주소 명령어면 2^4=16개밖에 안되기 때문
                - 쉽게 말하면 더 많은 데이터를 저장하기 위해서~
                - 연산의 대상이 되는 데이터가 저장된 위치를 유효 주소라고 함.
            - 명령어 주소 지정 방식 (addressing modes)
                - 연산에 사용할 데이터가 저장된 위치를 찾는 방법
                - 즉시 주소 지정 방식
                    - 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시
                    - 대부분 데이터임
                - 직접 주소 지정 방식
                    - 오퍼랜드 필드에 유효 주소 직접적으로 명시
                    - 10번지 ~ 막 이렇게! 유효 주소를 표현할 수 있는 크기가 연산 코드만큼 줄어듦
                - 간접 주소 지정 방식
                    - 오퍼랜드 필드에 유효 주소의 주소를 명시
                    - 속도가 느림
                    - 주소도 범위가 넘어갈 수 있어서 한 번 더 하는거임… 물리적인 한계를 극복하기 위해
                - 레지스터 주소 지정 방식
                    - 연산에 사용할 데이터가 저장된 레지스터 명시
                    - 메모리에 접근하는 속도보다 레지스터에 접근하는 것이 더 빠름
                    - 레지스터는 내부에 있는거고 메모리는 외부에 있으니까!
                - 레지스터 간접 주소 지정 방식
                    - 연산에 사용할 데이터를 메모리에 저장하고,
                    - 유효 주소를 레지스터에 저장 (데이터를 레지스터에 저장하는게 아니라!)
                    - 대부분의 CPU는 이런 방식을 사용함
                - 정리하면…
                    - 즉시 주소 지정: 연산에 사용할 데이터
                    - 직접 주소 지정: 유효 주소 (메모리 주소)
                    - 간접 주소 지정: 유효 주소의 주소
                    - 레지스터 주소 지정: 유효 주소 (레지스터 이름)
                    - 레지스터 간접 주소 지정: 유효 주소를 저장한 레지스터
        - 연산 코드
            1. 데이터 전송: move(옮기기), store(저장), load(가져오기), push(스택에 저장), pop(스택에 가져오기)
            2. 산술, 논리 연산: add, subtract, multiply, divide (덧, 뻴, 곱, 나), increment, decrement (1더하기, 빼기), and, or, not, compare 
            3. 제어 흐름 변경: jump(실행 순서 옮기기), conditional jump, halt(멈추기), call(돌아올 주소를 저장한채 실행 순서 옮기기), return(call에서 저장했던 주소로 돌아가라)
            4. 입출력 제어: read(input), write(output), start io(입출력 장치 시작), test io(입출력 장치 상태 확인)

## 컴퓨터의 네 가지 핵심 부품

- 중앙처리장치(CPU)
    - 컴퓨터의 뇌
    - 메모리에 저장된 명령어를 읽어 들이고, 해석하고, 실행함
    - 구성 요소
        - 산술논리연산장치 (ALU)
            - 계산기. 계산만을 위해 존재하는 부품
        - 레지스터
            - CPU 내부의 작은 임시 저장 장치
            - 여러 개의 레지스터가 존재하고, 각기 다른 이름과 역할을 가짐
        - 제어장치 (CU. Control Unit)
            - 제어 신호라는 전기 신호를 내보내고 명령어를 해석함
            - 읽고 싶을땐 “메모리 읽기”라는 제어신호를 보냄 (CPU → 메모리)
            - 쓰고 싶을땐 “메모리 쓰기”라는 제어신호를 보냄 (CPU → 메모리)
    - 메모리에 저장된 명령어 실행 순서
        1. 제어장치에서 “메모리 읽기” 제어 신호를 보내서 1번지 값을 읽어옴
        2. 레지스터에 명령어 저장됨
        3. 제어장치는 명령어를 해석한 뒤 3, 4번 값이 필요하다는 것을 판단
        4. 제어장치는 3, 4번 메모리를 읽기 위해 “메모리 읽기” 제어 신호를 보냄
        5. 3, 4번 메모리들은 서로 다른 레지스터에 저장됨
        6. ALU는 읽어들인 데이터로 연산 수행
        7. 계산 결괏값은 레지스터에 저장
        8. …
- 주기억장치(메모리(RAM), ROM)
    - 현재 **실행되는** 프로그램의 명령어, 데이터를 저장하는 부품
    - 저장된 값에 빠르고 효율적으로 접근하기 위해 주소라는 개념을 사용
        - 메모리에 저장된 정보는 계속 바뀌기 때문에 CPU는 메모리 몇 번지에 무엇이 저장되어 있는지 모름!!
        - 물리 주소: **메모리 하드웨어**가 사용하는 주소
            - 정보가 실제로 저장된 하드웨어 상의 주소
        - 논리 주소: **CPU와 실행 중인 프로그램**이 사용하는 주소
            - 실행 중인 프로그램 각각에게 부여된 0번지부터 시작되는 주소
            - 자신만의 주소이기 때문에 다른 프로그램과 중복될 수 있음 (인터넷, 게임, 메모장이 모두 10번지를 가지고 있을 수 O)
            - CPU가 명령한 주소를 물리주소로 바꾼 뒤 메모리에 저장해야 함
        - 메모리 관리 장치 (MMU. Memory Managment Unit)
            - 논리 주소 ↔ 물리 주소 간 변환
            - CPU가 발생시킨 논리 주소(시작점으로부터 떨어진 거리) + 베이스 레지스터 값(프로그램의 첫 물리 주소) = 물리 주소
                - ex. A의 100번지 데이터: 논리주소(100) + 베이스 레지스터(15000) = 물리주소(15100)
                - ex. B의 100번지 데이터: 논리주소(100) + 베이스 레지스터(45000) = 물리주소(45100)
            - 논리주소가 프로그램 마지막 주소를 넘어가는 명령어 실행을 방지하는 건 한계 레지스터(limit register)가 담당
                - 논리 주소의 초대 크기를 저장함
                - 따라서 프로그램 물리 주소 범위는, **베이스 레지스터 값 이상, 베이스 레지스터 + 한계 레지스터 값 미만**
                - 한계 레지스터보다 높은 주소에 접근하려고 하면 인터럽트를 발생 시켜 실행을 중단함
    - 명령어, 메모리 모두 저장 (당연히 0, 1로 모두 이루어져있음)
        - 1번지) 더하라, 3번지와 4번지를
        - 2번지) 저장하라, 연산결과를
        - 3번지) 120
        - 4번지) 100
    - 가격이 비싸 용량이 적음
    - 휘발성 저장 장치라서 전원이 꺼지면 저장된 내용이 잃음 (보조기억장치로 보충)
    - RAM
        - 용량이 충분할수록 많은 프로그램을 동시에 빠르게 실행하는 데 유리함
            - 하지만 무조건 속도가 비례해서 증가하는건 아님. 어느 수준 이상부터는 거기서 거기임
        - 종류
            - DRAM (Dynamic RAM)
                - 저장된 데이터가 동적으로 변하는 (사라지는) RAM
                - 일정 주기로 데이터를 다시 저장해야 함
                - 일반적으로 많이 사용함. 소비 전력이 낮고, 저렴하고, 집적도가 높기 때문에 대용량 설계에 용이
            - SRAM (Static RAM)
                - 저장된 데이터가 변하지 않는 RAM
                - 일반적으로 DRAM보다 속도가 더 빠르지만, 소비 전력이 높고, 비싸고, 집적도가 낮음
                - 캐시 메모리에서 많이 사용함
            - SDRAM(Synchronous Dynamic RAM)
                - 클럭 타이밍에 맞춰 CPU와 정보를 주고 받을 수 있는, 발전된 DRAM
            - DDR SDRAM(Double Data Rate SDRAM)
                - 대역폭을 두배로 넓혀 속도를 빠르게 만든 SDRAM
                - 최근에 가장 흔히 사용됨
                - 한 클럭당 하나만 주고 받을 수 있는건 SDR SDRAM(Single Data Rate SDRAM)
                - 즉, SDR SDRAM보다 두 배 더 빠름
                - DDR2 SDRAM은 DDR보다 두배 넓은거, DDR3는 DDR2보다 두배, DDR4는 DDR3보다 두배…
                    - 2=4배, 3=8배, 4=16배로 이해하기
    - 캐시 메모리
        - CPU - 메모리 사이에 위치하며, 레지스터 보다는 용량이 크고 메모리보다는 속도가 빠른 SRAM 기반의 저장 장치
        - CPU 안에 있는 캐시 메모리는 L1, L2 캐시, 사이에 있는건 L3 (속도는 L1이 제일 빠르고 용량은 L3가 제일 많음. 가격도 L1이 제일 비쌈)
            - 그래서 L1, L2는 CPU마다 할당되고, L3는 여러 코어가 공유함
        - 자주 사용할 법한 대상을 저장해야 함. 실제로 데이터가 활용될 경우 캐시 히트(cache hit)라고 함, 틀린건 캐시 미스(cache miss)
            - 캐시 적중률 계산 = 캐시 히트 회수 / (캐시 히트 횟수 + 캐시 미스 횟수)
        - 어떻게 적중률을 높일까? → 참조 지역성의 원리 사용
            1. 최근에 접근했던 메모리 공간에 다시 접근한다.
            2. 접근한 메모리 공간 근처를 접근한다. (공간 지역성)
- 보조기억장치
    - 하드 디스크, 플래시 메모리(SSD, USB) DVD, CD-ROM… 컴퓨터 전원이 꺼져도 저장됨 (비휘발성 저장 장치)
        - 대신 CPU는 보조기억장치에 직접 접근하지 못함 (메모리에만 가능)
        - CPU가 실행하고 싶은 프로그램이 보조기억장치에 있으면 RAM으로 복사하여 저장한 뒤 실행
    - 메모리는 현재 “**실행되는**” 프로그램 저장, 보조기억장치는 “**보관할**” 프로그램 저장
    - 하드 디스크
        - 자기적인 방식으로 데이터를 저장 (자기 디스크, magnetic disk)
        - 동그란 원판에 데이터를 저장하고, 그것을 회전 시켜 뾰족한 리더기로 데이터를 읽음
            - 동그란 원판 = **플래터, platter** (수많은 N극, S극으로 이루어지고, 0과 1의 역할 수행)
                - 여러 겹의 플래터로 이루어져 있고, 양면 모두 사용 가능 (헤드도 두 개. 단면이면 플래터당 하나)
                - 트랙과 섹터라는 단위로 데이터를 저장함
                - **트랙, track** (운동장 달리기 트랙처럼 여러 동심원으로 나누었을 때 하나의 원)
                    - 같은 트랙이 위치한 한 곳을 모아 연결한 논리적 단위를 **실린더 (cylinder)** 라고 함.
                    - 연속된 정보는 한 실린더에 기록됨.
                        - 네 개의 섹터를 저장할 때 첫 번째 플래터 윗면, 뒷면, 두번째 플래터 윗면, 뒷면에 저장
                        - 그렇게 해야 디스크 암을 움직이지 않아도 되기 때문
                - **섹터, sector** (플래터를 피자조각처럼 나눈 한 조각. 하드 디스크의 가장 작은 전송 단위. 1섹터는 512바이트… 4,096바이트까지 가능)
                    - 하나 이상의 섹터를 묶어 **블록(block)**이라고 하기도 함
            - 회전 시키는 요소 = **스핀들, spindle** (스핀들이 돌리는 분당 회전수를 RPM, Revolution Per Minute)
            - 플래터 대상으로 데이터를 읽고 쓰는 요소 = **헤드, head** (뾰족한 부분의 맨 끝부분. 플래터 위에 미세하게 떠있음)
            - 헤드를 원하는 위치로 이동시키는 요소 = **디스크 암, disk arm** (헤드가 부착되어 있음)
        - 저장된 데이터에 접근하는 과정?
            - 탐색 시간: 데이터가 저장된 트랙까지 헤드를 이동시키는 시간 (수직으로)
            - 회전 지연: 헤드가 있는 곳으로 플래터를 회전 시키는 시간
            - 전송 시간: 하드 디스크 → 컴퓨터 간 데이터를 전송하는 시간
        - 1TB 하드 디스크 네개로 **RAID**를 구성하면 4TB 하드 디스크보다 성능과 안정성이 더 좋다
            - RAID: 하드 디스크, SSD에서 사용. 여러 개의 물리적 보조기억장치를 하나의 논리적 보조기억장치처럼 사용
            - RAID 0
                - 단순히 데이터를 나눠서 저장하는 구성 방식 (스트라이핑, striping)
                    - 저장된 데이터는 스트라입(stripe)이라고 함
                - 읽고 쓰는 속도가 빨라짐
                - 하드 디스크 하나에 문제가 생기면 다른 모든 하드 디스크의 정보를 읽는 데 문제가 생김
            - RAID 1
                - 복사본을 만드는 구성 방식 (미러링, mirroring)
                - 쓰기 속도는 RAID 0보다 느리고 용량도 두 배 줄어듬 ⇒ 비용이 증가함
            - RAID 4
                - 오류를 검출하고 복구하기 위한 정보를 저장하는 장치를 두는 구성 방식
                    - 오류를 검출하고 복구하는 정보를 패리티 비트(parity bit)라고 함
                - RAID 1보다 적은 하드 디스크로 데이터를 안전하게 보관할 수 있음
                - 새로운 데이터를 저장할 때마다 패리티를 저장하는 장치에 병목 현상이 발생함
            - RAID 5
                - 각각의 하드 디스크에 패리티 정보를 분산 시켜 저장함
            - RAID 6
                - 5와 비슷하나 각각의 하드 디스크에 서로 다른 두 개의 패리티 정보를 저장함
                - 저장할 패리티가 두개이므로 RAID 5보다는 속도가 느리지만, 더 안전함
    - 플래시 메모리(USB, SD, SSD)
        - 전기적으로 데이터를 읽고 쓸 수 있는 반도체 기반의 저장 장치
        - **NAND 플래시 메모리**
            - 용량을 늘리기가 쉬움
            - 쓰기 속도가 빠름
            - 우리가 보조 기억 장치로 쓰는건 대부분 이거임
        - NOR 플래시 메모리
            - 읽기 속도가 빠름
            - 데이터 안정성이 우수한 특징이 있음
        - 셀(cell)
            - 플래시 메모리에서 데이터를 저장하는 가장 작은 단위. 셀들이 모여 MB, GB, TB가 됨
            - 한 셀에 1비트 저장할 수 있으면 SLC (Single Level Cell)
                - 한 셀로 두 개의 정보 표현 가능 (0, 1)
                - 빠른 입출력이 가능하지만 용량 대비 가격이 높음.. 혼자 자취하는 사람
                - 기업에서 읽고, 쓰기가 많이 반복되며 고성능의 빠른 장치가 필요한 경우 사용
            - 2비트는 MLC (Multiple Level Cell)
                - 한 셀로 네 개의 정보 표현 가능 (00, 01,  10, 11)
                - 대용량화에 유리하고 가격이 SLC보다 저렴함. 그래서 많이 씀
            - 3비트는 TLC (Triple Level Cell)
                - 한 셀로 여덟 개의 정보 표현 가능 (000, 001, 010, 100, 110, 101, 011, 111)
                - SLC, MLC 보다 수명, 속도가 떨어지지만 용량 대비 가격이 저렴함
        - 셀이 모이면 페이지(page)
            - 읽기와 쓰기는 페이지 단위로 이루어짐
            - 세 개의 상태를 가짐
                - Free: 새로운 데이터를 저장할 수 있는 상태
                - Valid: 유효한 데이터를 저장하고 있는 상태. 이 때는 덮어쓰기가 불가능하여 새 데이터를 저장할 수 없음
                    - 예를 들어 [A, B, C, _] 에서 A값을 덮어쓰고 싶으면 [A(Invalid), B, C, A’] 가 저장
                - Invalid: 유효하지 않은 데이터(쓰레기값)을 저장하고 있는 상태
                    - 가비지 컬렉션 기능을 사용해 쓰레기값 정리
                    1. 유효한 페이지들만 새로운 블록으로 복사한 뒤
                    2. 기존의 블록을 삭제함
        - 페이지가 모이면 블록(block)
            - 삭제는 블록 단위로 이루어짐
        - 블록이 모이면 플레인(plane)
        - 플레인이 모이면 다이(die)
- 입출력장치
    - 마이크, 스피커, 프린터, 마우스, 키보드 … 컴퓨터 외부와 연결되어 내부와 정보를 교환하는 장치 (보조기억장치도 입출력장치 아닌가? → 그래서 “주변장치”라고 통칭하기도 하는데, 얘네는 보조하는 역할은 아님)
    - 장치 컨트롤러
        - 입출력 장치가 까다로운 이유
            1. 종류가 너무 많음
            2. CPU, 메모리의 데이터 전송률은 높지만 입출력장치의 전송률은 낮기 때문
            
            → 그래서 장치 컨트롤러라는 하드웨어를 통해 컴퓨터 내부와 정보를 주고 받음
            
        - 장치 컨트롤러의 역할
            1. CPU와 입출력장치 간의 통신 중개
            2. 오류 검출
            3. 데이터 버퍼링
                - 장치 사이에 주고 받는 데이터를 버퍼(buffer)라는 임시 저장 공간에 저장하여 전송률을 비슷하게 맞춤
        - 입출력 장치를 연결하기 위한 **하드웨어적인** 통로
        - 구조
            - 데이터 레지스터, 상태 레지스터, 제어 레지스터로 구성됨
            - 데이터 레지스터
                - CPU - 입출력장치 사이에 주고받을 데이터가 담기는 레지스터
                - 데이터 버퍼링의 버퍼 역할을 함
                - 요즘에는 이거 대신 RAM을 사용하기도 함
            - 상태 레지스터
                - 입출력 작업 준비가 되었는지, 완료 되었는지, 오류는 없는지 등의 **상태 정보**가 저장됨
            - 제어 레지스터
                - 입출력장치가 **수행할 내용**에 대한 제어 정보와 명령을 저장
        - 장치 컨트롤러가 CPU와 정보를 주고 받는 방법
            - **프로그램 입출력**
                - 프로그램 속 명령어로 입출력장치를 제어하는 방법. CPU가 명령어를 만나면 장치 컨트롤러와 상호작용함
                - 예를 들어 메모리에 저장된 정보를 하드 디스크에 백업하는 상황?
                    1. CPU는 하드 디스크 컨트롤러의 제어 레지스터에 쓰기 명령을 보냄
                    2. 하드 디스크 컨트롤러는 하드 디스크 상태 확인. 준비되었다면 상태 레지스터에 준비되었다고 표시
                    3. CPU가 주기적으로 폴링하여 준비된걸 알게 되면 백업할 메모리 정보를 데이터 레지스터에 씀. 완료될때까지 1-2번 반복
                    
                    → 근데 CPU는 장치 컨트롤러의 레지스터를 어떻게 알까? → 메모리 맵 입출력, 고립형 입출력 덕분!
                    
                - 메모리 맵 입출력
                    - 메모리 주소 공간 + 입출력장치에 접근 주소 공간 = 하나의 주소 공간
                    - 1024개 주소를 중 512개는 메모리 주소, 512개는 장치 컨트롤러의 레지스터를 표현하기 위해 사용
                    - 예를 들어 517번지가 “프린터 컨트롤러의 상태 레지스터”라면, 517번을 읽어들이면 프린터 상태를 확인할 수 있음
                    - 메모리, 입출력장치에 같은 명령어 사용 가능
                - 고립형 입출력
                    - 메모리 주소 공간 / 입출력장치에 접근 주소 공간 … 이렇게 분리된 주소 공간 사용
                    - 제어 버스에 메모리 읽기/쓰기 말고 입출력장치 읽기/쓰기 선을 따로 만들어서 각각 1024개 주소 공간 활용 가능
                    - 입출력 전용 명령어 사용
            - **인터럽트 기반 입출력**
                - 장치 컨트롤러가 입출력 작업을 끝낸 뒤 CPU에게 인터럽트 요청 신호를 보내면 인터럽트 서비스 루틴 실행
                - 인터럽트가 동시에 발생한 경우에는 어떻게 처리할까?
                    - 보통 우선순위가 높은 순으로 인터럽트 처리
                        - 무시할 수 없는 인터럽트인 **NMI(Non-Maskable Interrupt)**가 발생하면 이거 먼저 처리함
                    - PIC
                        - **프로그래머블 인터럽트 컨트롤러(PIC)**를 사용해 인터럽트의 우선순위를 판별한 뒤 CPU에게 뭐 먼저 처리해야 되는지 알려주는 장치
                        - 각각 인터럽트를 받아들이는 핀이 여러 개 있는데, 여러 개가 동시에 요청을 보내면 우선순위 판별
                        1. PIC가 장치 컨트롤러에서 인터럽트 요청 신호를 받음
                        2. 우선순위 판단 후 CPU에 인터럽트 요청 신호를 보냄
                        3. CPU는 PIC에 인터럽트 확인 신호를 보냄
                        4. PIC는 데이터 버스를 통해 CPU에 인터럽트 벡터를 보냄
                        5. CPU는 해당 장치의 인터럽트 서비스 루틴을 실행함
                        - 단, NMI는 우선순위를 판별하지 않음 (제일 높기 때문에)
            - **DMA 입출력**
                - 프로그램 기반 입출력, 인터럽트 기반 입출력 둘 다 데이터를 CPU가 주도하고, 데이터도 CPU를 거쳐야됨
                    - 예를 들어 입출력장치 데이터를 메모리에 저장하는 경우
                        1. CPU는 장치 컨트롤러에서 입출력 장치 데이터를 하나씩 읽어 레지스터에 적재
                        2. 적재한 데이터를 메모리에 저장
                    - 반대로 데이터를 입출력장치에 내보내는 경우
                        1. CPU는 메모리에서 데이터를 하나씩 읽어 레지스터에 적재
                        2. 적재한 데이터를 하나씩 입출력장치에 내보냄
                - CPU 넘 바쁜데 … 그래서 입출력 장치, 메모리가 CPU를 거치지 않고 상호작용하는 DMA (Direct Memory Access)
                - 이걸 사용하려면 시스템 버스에 연결된 **DMA 컨트롤러**가 필요함
                - DMA 입출력 과정
                    1. CPU는 DMA 컨트롤러에 입출력장치의 주소, 수행할 연산, 읽거나 쓸 메모리의 주소 등과 같은 정보로 입출력 작업 명령
                    2. DMA 컨트롤러는 CPU 대신 장치 컨트롤러와 상호작용하여 입출력 작업을 수행, 필요한 경우 메모리에 직접 접근
                    3. 작업이 끝나면 DMA 컨트롤러는 CPU에 인터럽트를 걸어 작업이 끝났음을 알림
                - DMA 컨트롤러는 CPU가 시스템 버스를 이용하지 않을때마다 조금씩 사용하거나 집중적으로 사용해야 될 때에는 CPU 허락을 받음
                - 입출력 버스?
                    - DMA를 위해 한 번 메모리에 접근할 때마다 시스템 버스를 두 번 사용해야 함
                    1. 메모리에서 DMA 컨트롤러로 데이터를 가져오기 위해 시스템 버스 사용
                    2. DMA 컨트롤러의 데이터를 장치 컨트롤러로 옮기기 위해 시스템 버스 사용
                    
                    → 시스템 버스를 너무 많이 쓰면 CPU가 사용 못하니 입출력 버스라는걸 사용해서 별도로 사용
                    
                    - PIC 버스, PCI Express 버스 등 여러 종류가 있음… PCle 슬롯이라는 통로를 사용해 입출력장치 - PCle 버스와 연결
    - 장치 드라이버
        - 장치 컨트롤러의 동작을 감시하고 제어함으로써 컴퓨터 내부와 정보를 주고받을 수 있게 하는 프로그램
        - 입출력 장치를 연결하기 위한 **소프트웨어적인** 통로

## 메인보드와 시스템 버스

- 핵심 부품들은 모두 메인보드라는 판에 연결됨, 마더 보드라고도 부름
- 메인보드끼리 버스(bus)라는 통로가 있고, 이걸 통해 정보를 주고받음.
- 가장 중요한 버스는 시스템 버스
    - 주소 버스: 주소를 주고 받는 통로
    - 데이터 버스: 명령어와 데이터를 주고받는 통로
    - 제어 버스: 제어 신호를 주고받는 통로
- 제어 장치에서 “메모리 읽기”를 보낸다면 버스는?!
    1. 주소 버스로 읽고자 하는 주소를 내보내고
    2. 메모리는 데이터 버스로 CPU가 요청한 주소에 있는 내용을 보냄
