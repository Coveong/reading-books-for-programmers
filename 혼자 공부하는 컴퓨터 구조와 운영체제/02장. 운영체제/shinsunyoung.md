# 운영체제 정리

- 지금까지 배운 컴퓨터 구조들을 자원이라고 함
- 실행할 프로그램에 필요한 자원을 할당해서 프로그램이 올바르게 실행되도록 돕는 특별한 프로그램이 **운영체제**

Q. 운영체제도 프로그램?

A. YES! 하지만 “특별한” 프로그램이기 때문에 **커널 영역(kernel space)**이라는 메모리에 따로 적재되어 실행되고, 응용 프로그램은 **사용자 영역(user space)**에 저장됨

# 운영체제

- 하는 일
    - 사용자 영역에 있는 프로그램을 메모리에 적재하고, 더 이상 실행되지 않는다면 메모리에서 삭제하며 **메모리 자원을 관리**함
    - 최대한 공정하게 여러 프로그램에 CPU 자원을 할당함
    - 응용 프로그램 - 하드웨어 간 응용 프로그램에 필요한 자원을 할당, 올바르게 실행되도록 관리
- 알아야 하는 이유
    - 운영체제는 프로그램이기 때문에 대화를 할 수 있고, 이로 인해 문제 해결의 실마리를 찾을 수 있다.
- 커널
    - 운영체제의 핵심 서비스를 담당하는 부분 (심장 역할)
    - 커널이 제공하는 핵심 서비스
        - 프로세스 관리
            - 프로세스?
                - 실행 중인 프로그램
                - 프로세스의 종류
                    - 포그라운드 프로세스(foreground process): 사용자가 보는 앞에서 실행되는 프로세스
                    - 백그라운드 프로세스(background process): 사용자가 보지 못하는 곳에서 실해오디는 프로세스
                        - 그 중 사용자와 상호작용하지 않고 실행하는 프로세스를 유닉스에서는 데몬(daemon), 윈도우에서는 서비스(service)라고 부름
                - **프로세스 제어 블록(PCB, Process Control Block)**
                    - 프로세스와 관련된 정보를 저장하는 자료 구조
                    - 프로세스 생성 시에 만들어지고, 실행이 끝나면 폐기됨
                    - 저장되는 정보? (~= Context)
                        - 프로세스 ID(Process ID, PID): 프로세스를 식별하기 위한 고유 번호
                        - 레지스터 값: 프로세스가 실행하며 사용했던 프로그램 카운터를 비롯한 레지스터 값들을 백업
                        - 프로세스 상태: 입출력 장치를 사용하기 위해 기다리는 상태인지, CPU를 기다리는 중인지, 사용 중인지 등의 사앹
                        - CPU 스케줄링 정보: 프로세스가 언제, 어떤 순서로 CPU를 할당받을지에 대한 정보
                        - 메모리 관리 정보: 프로세스가 저장된 주소, 베이스 레지스터, 한계 레지스터의 정보
                        - 사용한 파일과 입출력장치 목록: 어떤 입출력 장치가 할당되었는지, 어떤 파일을 열었는지에 대한 정보
                - 커널 영역에는 → 프로세스 제어 블록(PCB)가 생성됨
                - 사용자 영역에는 → 코드 영역, 데이터 영역, 힙 영역, 스택 영역으로 나뉘어 저장됨
                    - 코드 영역(Code Segment)
                        - 텍스트 영역(Text Segment)라고도 부름
                        - 말 그대로 **실행할 수 있는 코드 ⇒ 기계어로 이루어진 명령어**가 저장됨
                        - CPU가 실행할 명령어가 담겨 있지 때문에 **쓰기가 금지되어 있음 (only 읽기만 가능)**
                        - 정적 할당 영역
                    - 데이터 영역(Data Segment)
                        - 프로그램이 실행되는 동안 유지할 데이터가 저장되는 공간 (ex. 전역 변수)
                        - 정적 할당 영역
                    - 힙 영역(Heap Segment)
                        - 사용자(프로그래머)가 직접 할당할 수 있는 저장 공간
                        - 반드시 다 쓴 이후에는 공간을 반환해야 함 → 그렇지 않으면 메모리 누수(Memory Leak) 발생
                        - 동적 할당 영역 (일반적으로 낮은 주소부터 할당)
                    - 스택 영역(Stack Segment)
                        - 데이터를 일시적으로 저장하는 공간 (ex. 매개변수, 지역 변수)
                        - 동적 할당 영역 (일반적으로 높은 주소부터 할당)
                - 프로세스의 상태
                    - 생성(new): 이제 막 메모리에 적재되어 PCB를 할당 받은 상태
                    - 준비(ready): 당장이라도 CPU를 할당받아 실행할 수 있지만, 아직 자신의 차례가 아니기 때문에 기다리고 있는 상태
                    - 실행(running): CPU를 할당 받아 실행중인 상태. 타이머 인터럽트가 발생하면 준비 상태가 되고, 입출력 장치 완료까지 기다리면 대기 상태가 됨
                    - 대기(blocked): 입출력 장치의 작업이 끝날때까지 기다리는 상태. 끝나면 다시 준비 상태가 됨
                    - 종료(terminated): 프로세스가 종료된 상태
                - 프로세스 계층 구조
                    - 실행 시 시스템 호출을 통해 다른 프로세스를 생성할 수 있음
                    - 새 프로세스를 생성한 프로세스는 **부모 프로세스**, 부모 프로세스에 의해 생성된 프로세스는 **자식 프로세스**라고 함
                        - 둘의 PID는 다르고, 자식 프로세스 PCB에 부모 프로세스의 PID인 PPID(Parent PID)가 기록 되기도 함
                - 프로세스 생성 기법
                    - 부모 프로세스를 통해 생성된 자식 프로세스는 fork - exec 기법을 사용함
                        - fork: 자신의 복사본을 자식 프로세스로 생성 (메모리 내용, 열린 파일의 목록 등이 상속됨)
                        - exec: 자신의 메모리 공간을 다른 프로그램으로 교체
                - 스레드
                    - 프로세스를 구성하는 실행 흐름의 단위
                    - 하나의 프로세스는 여러 개의 스레드를 가질 수 있음
                    - 프로세스 내에서 **각기 다른 스레드 ID, 프로그램 카운터 값을 비롯한 레지스터 값, 스택**으로 구성
                    - 실행에 필요한 최소한의 정보만 유지한 채 **프로세스 자원(코드, 데이터, 힙 영역, 파일)을 공유**하며 실행됨 (프로세스끼리는 통신만 가능. IPC)
                    - 하나의 공유 자원(코드, 데이터, 힙, 파일)에 문제가 생기면 다른 스레들도 자원을 공유하기 때문에 영향을 받는다.
                - 프로세스 동기화
                    - 프로세스들 사이의 수행 시기를 맞추는 것. 프로세스를 올바른 순서대로 실행해야 함 (실행순서 제어)
                    - 전역 변수, 파일, 입출력장치 등 동시에 접근하면 안 되는 자원을 **공유 자원** 이라고 함
                    - 동시에 실행하면 문제가 발생하는 자원에 접근하는 코드 영역을 **임계 구역**이라고 함
                        - 잘못된 실행으로 여러 프로세스가 동시 다발적으로 임계 구역의 코드를 실행해 문제가 발생하는 것을 **레이스 컨디션 (race condition)**이라고 함
                        - 임계 구역 문제를 해결하기 위해서는 세 가지 원칙이 반드시 지켜져야 함
                            1. **상호 배제(mutual exclusion):** 한 프로세스가 임계 구역에 진입했다면 다른 프로세스는 들어올 수 없다.
                            2. **진행(progress):** 임계 구역에 어떤 프로세스도 진입하지 않았다면 프로세스는 들어갈 수 있다
                            3. **유한 대기(bounded waiting):** 한 프로세스가 임계 구역에 진입하고 싶다면 그 프로세스는 언젠가는 임계 구역에 들어올 수 있어야 한다.
                    - 동기화를 위한 대표적인 도구
                        - 뮤텍스 락(Mutex lock, MUTual EXclusion lock)
                            - 상호 배제를 위한 동기화 도구, 임계 구역에 자물쇠를 걸고, 잠겨 있지 않을 때만 임계 구역에 진입 가능
                            - 자물쇠 역할(전역 변수 lock), 임계 구역을 잠그는 역할(acquire 함수), 임계 구역의 잠금을 해제하는 역할(release 함수)
                            
                            ```java
                            acqure() {
                            	while (lock == true) // 임계 구역이 잠겨 있다면
                            		; // 반복적으로 확인 (바쁜 대기. busy wait라고 함)
                            	lock = true; // 잠겨 있지 않다면 임계 구역 잠금
                            }
                            
                            release() {
                            	lock = false; // 작업이 끝나면 잠금 해제
                            }
                            
                            // 실제로 사용할 때는
                            acqure();
                            작업 진행
                            release();
                            ```
                            
                        - 세마포(Semaphore)
                            - 공유 자원에 접근하는 프로세스를 상정한 방식
                            - 임계 구역에 진입할 수 있는 프로세스 개수를 나타내는 전역 변수 S, 들어갈 수 있는지 알려주는 wait 함수, 앞에서 가도된다고 알려주는 signal 함수
                            
                            ```java
                            wait() {
                            	while (S <= 0) // 임계 구역에 진입할 수 있는 프로세스가 0개 이하라면
                            	; // 반복적으로 확인
                            	S--; // 프로세스가 1개 이상이라면 S를 1 감소시키고 임계 구역에 진입
                            }
                            
                            signal() {
                            	S++; // 작업을 마치면 S를 1 증가 시킴
                            }
                            
                            // 실제로 사용할 때는
                            wait();
                            작업 진행
                            signal();
                            ```
                            
                            - 이것도 바쁜 대기이기 때문에 비효율적임 → 그래서 실제로는 다른 방법을 사용함
                                - wait 함수는 없는 경우 대기 상태로 만들고, PCB를 세마포를 위한 대기 큐에 집어 넣는다.
                                - 작업이 끝나고 signal 함수를 호출하면, 대기 중인 프로세스를 대기 큐에서 제거하고, 프로세스 상태를 준비 상태로 변경한 뒤 준비 큐로 옮겨짐
                        - 모니터(Monitor)
                            - 매번 임계구역 앞뒤로 wait(), signal() 함수를 명시하는 것은 번거로운 일임
                            - 모니터를 사용하면 공유 자원, 공유 자원에 접근하기 위한 인터페이스를 묶어서 관리하고, 프로세스는 인터페이스를 통해서만 공유 자원에 접근하도록 함
                            - 공유 자원을 다루는 인터페이스에 접근하기 위한 큐를 만들고, 모니터 안에는 항상 하나의 프로세스만 들어오도록 함
                            - 조건 변수(wait, signal)를 사용하여 프로세스나 스레드의 실행 순서를 제어함
                                - wait: 조건 변수 큐에 들어가고 프로세스를 일시중지함. 특정 프로세스가 아직 실행될 조건이 되지 않았을 때에는 wait를 통해 실행을 중단함
                                - signal: wait를 호출하여 큐에 삽입된 프로세스의 실행을 재개하는 연산. 특정 프로세스가 실행될 조건이 충족되었을 때 signal을 통해 실행을 재개함
            - 일반적으로 CPU는 한 번의 하나만 프로세스만 실행할 수 있음
                - 프로세스들은 차례대로 돌아가며 한정된 시간 만큼만 CPU를 이용하다가, 타이머 인터럽트가 발생하면 자신의 차례를 양보하고 다음 차례가 올 때까지 기다림
                - 운영체제는 프로세스 제어 블록(PCB, Process Control Block)을 이용해 프로세스의 실행 순서를 관리하고, CPU를 비롯한 자원을 배분함
                - 자신의 차례가 끝나면 **문맥 교환(Context Switching)**이 일어남
                    - 하나의 프로세스 수행을 재개하기 위해 기억해야 할 정보를 **문맥(Context)**이라고 함
                    - 하나의 프로세스 Context = 해당 프로세스의 PCB에 표현되어 있음 (~= PCB에 기록되는 정보를 문맥이라고 함)
                    - **인터럽트가 발생하면 운영체제는 해당 프로세스 PCB에 문맥을 백업하고, 다음 프로세스의 문맥을 복구함**
                    - 프로세스들이 동시에 실행되는 것처럼 보이지만, 사실 끊임없이 빠르게 번갈아가며 Context Switching이 일어나는 것
            - 각각의 프로세스들은 상태도, 사용하고자 하는 자원도 다양하기 때문에 운영체제가 일목요연하게 관리해야 함
        - 자원 접근 및 할당
            - CPU
                - CPU 스케줄링
                    - 우선순위가 높은 순서대로 처리함. 보통 입출력  장치에 많이 접근하는게 우선순위가 높음
                        - 입출력 집중 프로세스(I/O bound process): 실행 상태보다는 입출력을 위한 대기 상태에 더 많이 머무름
                        - CPU 집중 프로세스(CPU bound process):  대기 상태보다는 실행 상태에 더 많이 머무름
                        - 입출력 집중 프로세스를 먼저 실행시켜 입출력장치를 끊임없이 작동시키는게 가장 효율적임
                    - 프로세스마다 우선순위를 부여하고, PCB에 명시함
                    - 스케줄링 큐
                        - CPU를 사용하고 싶은 프로세스들, 메모리에 적재되고 싶은 프로세스들, 특정 입출력장치를 사용하고 싶은 프로세스를 줄세움
                        - 준비 큐(ready queue): CPU를 이용하고 싶은 프로세스들이 서는 줄
                        - 대기 큐(waiting queue): 입출력 장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄
                            - 완료 인터럽트를 받으면 작업이 완료된 PCB를 찾고, 해당 PCB는 준비 큐로 이동
                        - 반드시 FIFO는 아님. 우선 순위가 높으면 더 먼저 실행될 수 있음
                    - 선점형 스케줄링(preemptive scheduling)
                        - 프로세스가 CPU를 비롯한 자원을 사용하고 있더라도 운영체제가 프로세스로부터 자원을 강제로 빼앗아 할당
                        - 타이머 인터럽트하며 컨텍스트 스위칭하는게 선점형 스케줄링 방식임
                        - (장점)한 프로세스의 자원 독점을 막고 프로세스들에 골고루 자원을 배분할 수 있음
                        - (단점) 컨텍스트 스위칭 과정에서 오버헤드가 발생할 수 있음
                    - 비선점형 스케줄링(non-preemptive scheduling)
                        - 프로세스가 종료되거나 대기 상태에 접어들기 전까지 다른 프로세스가 끼어들 수 없는 스케줄링
                        - (장점) 컨텍스트 스위칭 과정에서 발생하는 오버헤드가 적음
                        - (단점) 프로세스가 사용중이면 당장 자원을 사용하더라도 무작정 기다려야 하기 때문에 골고루 자원을 사용할 수 없음
                    - 다양한 스케줄링 알고리즘
                        1. 선입 선처리 스케줄링 (FCFS, First Come First Served Scheduling)
                            - 준비 큐에 삽입된 순서대로 프로세스들을 처리하는 비선점형 스케줄링 방식
                            - 2ms를 실행하기 위해 앞 작업들을 25ms 이상 기다려야 할 수도 있음 (호위 효과)
                        2. 최단 작업 우선 스케줄링 (SJF, Shortest Job First Scheduling)
                            - 호위효과를 방지하기 위해 실행 시간이 짧은 프로세스부터 실행하는 비선점형 스케줄링 방식
                        3. 라운드 로빈 스케줄링 (Round Robin Scheduling)
                            - 선입 선처리 + 타임 슬라이스(정해진 시간만 사용하는 것)인 선점형 스케줄링 방식
                            - 타임 슬라이스 크기를 적절하게 정하는게 핵심!
                        4. 최소 잔여 시간 우선 스케줄링 (SRT, Shortest Remaining Time Scheduling)
                            - 최단 작업 우선 + Round Robin
                            - 정해진 타임 슬라이스만큼 CPU를 사용하되, CPU를 사용할 다음 프로세스는 남아있는 작업 시간이 가장 적은 프로세스가
                        5. 우선순위 스케줄링 (Priority Scheduling)
                            - 프로세스들의 우선순위 중 높은 것부터 실행하는 스케줄링 알고리즘. 같은 경우에는 FCFS로
                            - 우선순위가 낮은 프로세스는 평생 실행이 안 될 수도 있음 (기아 현상, starvation)
                                - 이를 방지하기 위해 aging 기법 사용. 오랫동안 대기하면 우선순위를 점차 높여줌
                        6. 다단계 큐 스케줄링 (Multilevel Queue Scheduling)
                            - 우선순위 스케줄링의 발전된 형태
                            - 우선순위별로 준비 큐를 여러개 설정해서, 우선순위가 높은 큐 먼저 실행, 그 다음에는 다음 큐를 실행하는 방법
                            - 큐를 여러 개로 분리하여 프로세스 유형별로 우선순위를 구분하여 실행하기 편하고, 큐별로 타임 슬라이스를 다르게 지정하거나 스케줄링 방식을 다르게 할 수도 있음
                        7. 다단계 피드백 큐 스케줄링(Multilevel Feedback Queue Scheduling)
                            - 다단계 큐 스케줄링의 발전된 형태
                            - 프로세스들이 큐 사이를 이동할 수 있음
                            - 구현이 가장 복잡하지만, 가장 일반적인 CPU 스케줄링 알고리즘임
                    - 교착 상태
                        - 일어나지 않을 사건을 기다리며 진행이 멈춰버리는 것 (서로 끝나길 기다리는 경우)
                        - **자원 할당 그래프**를 통해 단순하게 표현이 가능
                            1. 프로세스는 원으로, 자원의 종류는 사각형으로 표현
                            2. 사용할 수 있는 자원의 개수는 자원 사각형 내에 점으로 표현
                            3. 프로세스가 어떤 자원을 받아 할당중이라면 자원 → 프로세스를 향해 화살표를 표시
                            4. 프로세스가 어떤 자원을 기다리고 있다면 프로세스 → 자원으로 화살표를 표시
                            - **교착 상태가 발생하는 상황은 자원 할당 그래프가 원의 형태를 띄고 있음**
                        - 교착 상태가 발생하는 조건. 모두 만족해야지만 교착 상태가 발생할 가능성이 생김
                            1. 상호 배제: 해당 자원을 한 번에 하나의 프로세스만 이용 가능하다. 프로세스가 이용하고 있는 자원을 다른 프로세스가 사용 불가능
                            2. 점유와 대기: 자원을 할당받는 상태에서 다른 자원을 기다렸기 때문
                            3. 비선점: 다른 프로세스의 자원을 빼앗지 못하고 기다렸다가 이용해야 하기 때문
                            4. 원형 대기: 프로세스, 할당 받은 자원이 원의 형태를 이루었기 때문
                        - 교착 상태 해결 방법
                            - 예방: 위의 네 가지 가능성을 없애자
                                1. 상호 배제: 모든 자원을 공유 가능하게! → 현실적으로 어려움
                                2. 점유와 대기: 특정 프로세스에 자원을 모두 할당하거나 or 할당하지 않거나 → 자원의 활용률이 낮아짐.. 오랫동안 할당 x 자원이 많아지기 때문, 기아현상
                                3. 비선점: 자원을 뺏어서 사용 → 선점하여 사용할 수 있는 일부 자원에서 효과적(ex. CPU). 다만 범용성이 낮음 (프린터 자원을 뺏을 수 없듯이)
                                4. 원형 대기: 모든 자원에 번호를 붙이고 오름차순으로 자원을 할당 → 가장 현실적이지만, 모든 자원에 번호를 붙이는게 어렵고 번호에 따라 활용률이 낮아질수 있음
                            - 회피: 교착 상태가 발생하지 않을 정도로만 자원 할당
                                - 안전 상태: 교착 상태가 발생하지 않고 모든 프로세스가 정상적으로 자원을 할당받고 종료될 수 있는 상태
                                - 불안전 상태: 교착 상태가 발생할 수도 있는 상태
                                - 안전 순서열: 교착 없이 안전하게 프로세스들에 자원을 할당할 수 있는 순서
                                - 안전 순서열 예시 ⇒ 380p 참고
                            - 검출 후 회복: 교착 상태 발생을 인정하고 사후에 조치하는 방식. 주기적으로 교착 상태 발생 여부를 검사
                                - 선점을 통한 회복: 교착 상태가 해결될 때까지 한 프로세스씩 자원을 몰아주는 방식
                                - 프로세스 강제 종료를 통한 회복: 교착 상태에 놓인 프로세스를 모두 강제 종료하거나, 한 프로세스씩 종료할 수 있음. 가장 확실하게 할건지, 최대로 살릴건지 차이임
                            - (+ 타조 알고리즘이라고 교착상태를 무시하는 방법도 있음)
            - 메모리
                - 스와핑
                    - 현재 실행되지 않는 프로세스 (대기 상태, 오랫동안 사용하지 않는 상태 등…)를 임시로 보조기억 장치로 보내고, 빈 공간에 새로운 프로세스를 적재하여 실행하는 것
                    - 이 때 내보내지는 보조기억장치의 임시 영역 → 스왑 영역
                    - 프로세스가 메모리 → 스왑영역으로 옮겨지면 스왑 아웃(swap-out), 스왑 영역 → 메모리로 복귀하면 스왑 인(swap-in) (다른 메모리 주소에 적재될 수 있음)
                - 메모리 할당 (연속 할당 방식)
                    - 최초 적합
                        - 빈 공간을 검색하다가 적재할 수 있으면 배치하는 방식
                        - 검색 최소화, 빠른 할당 가능
                    - 최적 적합
                        - 빈 공간을 모두 검색해보고 적재될 수 있는 공간 중 가장 작은 공간에 배치하는 방식
                    - 최악 적합
                        - 빈 공간을 모두 검색해보고 적재될 수 있는 공간 중 가장 큰 공간에 배치하는 방식
                - 외부 단편화
                    - 연속 메모리 할당을 하게 되면 생기는 문제
                    - 빈공간이 있지만 연속 메모리할당을 해야해서 적재하지 못하고, 메모리 낭비가 되는 현상
                    - 조각모음을 해 저장된 프로세스를 재배치시켜 여기저기 흩어져 있는 작은 빈 공간들을 하나의 큰 빈 공간으로 만드는 방법
                        - 다만, 하던 일을 중지해야 하고, 재배치 작업이 오버헤드를 야기함
                - 가상 메모리
                    - 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술
                    - 페이징
                        1. 프로세스의 논리 주소 공간을 페이지(ex. 10MB) 단위로 자른다.
                        2. 메모리 물리 주소 공간을 프레임이라는 페이지와 동일한 크기의 일정한 단위로 자른 뒤, 페이지를 프레임에 할당
                        - 스왑할 때 프로세스 전체가 아닌, 페이지 단위로 스왑 아웃/인 됨. 이걸 페이지 아웃/페이지 인이라고 부르기도 함
                        - 프로세스를 실행하기 위해 프로세스 전체가 메모리에 적재될 필요가 없음. 실행에 필요한 일부 페이지만 메모리에 적재하고, 당장 필요없는건 보조 기억 장치에 남겨두기
                    - 페이지 테이블
                        - CPU는 프로세스를 이루는 페이지가 어디 프레임에 적재되었는지 모름. 그래서 다음 실행할 명령어 위치를 찾지 못함
                        - 그래서 페이지 테이블을 이용함. 페이지 테이블은 페이지 번호마다 프레임 번호가 몇번인지 기록해둠
                        - 프로세스마다 각자의 페이지 테이블을 가지고 있고, 각 프로세스의 페이지 테이블들은 메모리에 적재되어 있음
                        - CPU 내의 페이지 **테이블 베이스 레지스터**는 각 프로세스의 페이지 테이블이 적재된 주소를 가르킴
                            - 그럼 CPU → 테이블 베이지 레지스터 → 페이지 테이블 → 프레임의 테이블로 가야되는데 넘 느리지 않음?
                            - 그래서 TLB(Translation Lookaside Buffer)라는 페이지 테이블의 캐시 메모리를 두어서 페이지 테이블의 일부 내용을 저장함 (페이지 번호가 있으면 TLB 히트, 없으면 TLB 미스)
                        - 페이징에서 주소 변환
                            - 어떤 페이지 or 프레임에 접근하고 싶은지 + 얼마나 떨어져있는지를 알아야 함.
                            - 페이징 시스템은 모든 논리 주소가 페이지 번호, 변위(offset)으로 이루어져 있기 때문
                            - 즉, 논리 주소 <페이지 번호, 변위>는 페이지 테이블을 통해 물리 주소 <프레임 번호, 변위>로 변환됨 (예시 411p 참고)
                        - 페이지 테이블 엔트리
                            - 페이지 테이블의 각각의 행을 페이지 테이블 엔트리라고 함. 여기에 담기는 정보는 페이지, 프레임 번호 뿐만이 아님
                            - 유효 비트: 해당 페이지에 접근 가능한지 여부 (메모리에 있으면 1, 스왑영역에 있으면 0)
                                - 0인데 접근하려고 하면 **페이지 폴트(page fault)**라는 Exception이 발생
                                1. CPU는 기존 작업 내역 백업
                                2. 페이지 폴트 처리 루틴 실행
                                3. 페이지 처리 루틴을 통해 원하는 페이지를 메모리로 가져온 뒤 유효 비트를 1로 변경
                                4. CPU는 페이지에 접근
                            - 보호 비트: 읽고 쓰기만 가능 or 읽기만 가능 (읽고 쓰기 가능은 1, 읽기만 가능은 0. 또는 R.W.X로 읽기, 쓰기, 실행(execute)으로 표시할 수 있음, 111, 101, 001 이런식으로)
                            - 참조 비트: CPU가 이 페이지에 접근한 적이 있는지 여부 (한 번이라도 읽거나 쓴 페이지는 1, 아니면 0)
                            - 수정 비트: 데이터를 쓴 적이 있는지 없는 수정 여부 (변경된적 있으면 1, 아니면 0)
                                - 수정된 적이 있는 페이지가 스왑 아웃될 경우, 변경된 값을 보조기억장치에 기록해야 하기 때문에 필요
                    - 요구 페이징
                        - 메모리에 적재할 때 모든 페이지를 적재하지 않고 필요한 페이지만 메모리에 적재하는 기법
                            1. CPU가 특정 페이지에 접근하는 명령어를 실행함
                            2. 현재 메모리에 있는 경우 적재된 프레임에 접근
                            3. 없는 경우 페이지 폴트 발생하여 유효 비트 1로 설정
                            4. 다시 1번을 수행
                        - 요구 페이징을 맨 처음부터 실행하며 페이지 폴트를 계속 발생시키는 것 → 순수 요구 페이징
                        - 요구 페이징 시스템이 안전하게 작동하려면 …
                            - 페이지 교체
                                - 페이지 교체 알고리즘: 메모리가 가득 찼을 때, 필요없는 페이지를 내쫓는 방법
                                    - 좋은 알고리즘은 **페이지 폴트를 적게 일으키는 알고리즘**
                                    - 페이지 폴트 횟수는 페이지 참조열(page reference string, CPU가 참조하는 페이지 중 연속된 페이지를 생략된 페이지열)을 통해 알 수 있음
                                    - 2 2 2 3 5 5 5 3 3 7 이면 2 3 5 3 7 이 페이지 참조열임
                                    1. FIFO 페이지 교체 알고리즘
                                        - 메모리에 가장 먼저 올라온 페이지부터 내쫓는 방식
                                        - 프로그램 실행 내내 사용될 내용이 포함될 수도 있음
                                    2. 최적 페이지 교체 알고리즘
                                        - CPU에 의해 참조되는 횟수를 고려하는 방식
                                        - 가장 오랫동안 사용되지 않”을” 페이지를 교체하는 알고리즘
                                        - 실제로 페이지 폴트 횟수도 가장 적지만, 구현이 어려움 (앞으로 오랫동안 사용되지 않을 페이지를 예측하기가 어렵기 때문에)
                                        - 그래서 실제 운영체제에 사용하기 보다는, 다른 알고리즘의 비교 대상으로 쓰임
                                    3. LRU 페이지 교체 알고리즘
                                        - 가장 오랫동안 사용되지 않”은” 페이지를 교체하는 알고리즘
                    - 스래싱(thrashing)
                        - 메모리 공간이 너무 적어서 페이지 폴트가 너무 자주 발생하고, 실제 실행보다 페이징에 더 많은 시간을 소요해서 성능이 저하되는 문제
                        - 프로세스들이 무리 없이 실행 하기 위한 최소한의 프레임 수를 파악하고 프로세스들에 적절한 수만큼 프레임을 할당해야 함
                            - 균등 할당: 모든 프로세스에 균등하게 프레임을 제공하는 방식
                            - 비례 할당: 프로세스의 크기 따라 프레임을 제공하는 방식
                            - 작업 집합 모델: CPU가 특정 시간동안 주로 참조한 페이지 개수 만큼만 프레임 할당
                            - 페이지 폴트 빈도: 페이지 폴트율에 상한선과 하한선을 정하고, 그 내부 범위 안에서만 프레임을 할당하는 방식. 동적 할당 방식
            - (보조기억장치와) 입출력 장치
                - **인터럽트 서비스 루틴**을 제공해서 입출력 작업을 수행
            - 파일 시스템 관리
                - 파일: 하드 디스크나 보조 기억장치에 저장된 관련 정보의 집합 (의미 있고 관련 있는 정보를 모은 논리적 단위)
                - 파일을 이루는 정보: 속성(또는 메타데이터)을 가짐 (유형, 크기, 보호, 생성 날짜, 마지막 접근 날짜, 마지막 수정 날짜, 생성자, 소유자, 위치)
                    - 파일 유형: 운영체제가 인식하는 파일 종류 (뒤에 확장자를 붙임)
                - 파일 시스템을 다루기 위해서는 시스템 호출을 해야 함 → 운영체제
                - 파일들을 관리하기 위해서 **디렉터리(directory)**를 사용하기도 함
                    - 옛날에는 하나의 디렉터리 아래에 모든 파일들이 있었음 (1단계 디렉터리)
                    - 요즘에는 여러 계층을 가진 트리 구조 디렉터리가 생겨나게 됨
                        - 가장 상위 디렉터리는 루트 디렉터리
                        - 절대 경로: 루트 디렉터리 아래부터 시작하는 경로
                        - 상대 경로: 현재 디렉터부터 시작하는 경로
                    - 디렉터리는 그저 “특별한 형태의 파일”임
                    - 디렉터리는 **보조기억장치**에 테이블 형태의 정보로 저장됨 (디렉터리 엔트리)
                        - 디렉터리 엔트리만 보더라도 해당 디렉터리에 무엇이 담겨 있는지, 어디에 있는지 직간접적으로 알 수 있음
                        - 왜냐면 /home을 입력하면 하위에 어떤 디렉터리, 파일이 있는지 알 수 있고, 이런걸 통해 어떻게 찾아가야 하는지 유추할 수 있기 때문이다.
                - 하드 디스크를 만들면 뭘 해야할까?
                    1. **파**티셔닝: 저장 장치의 논리적인 영역을 구획하는 작업 (나눠서 정리하는것)
                    2. **포**매팅: 파일 시스템을 설정하여 어떤 방식으로 파일을 저장하고 관리할 것인지 결정하고, 새로운 데이터를 쓸 준비를 하는 작업 (파티션마다 다른 파일 시스템도 가능)
                    3. **파**일 할당
                        - 연속 할당
                            - 구현이 단순하지만, 외부 단편화를 야기함
                        - 불연속 할당
                            - 연결 할당
                                - 각 블록의 일부분에 다음 블록의 주소를 저장하여 각 블록이 다음 블록을 가리키는 형태
                                - 외부 단편화 문제는 해결하지만, 단점이 있음
                                    - 반드시 첫 번째 블록부터 하나씩 차례대로 읽어야 함 (임의 접근 속도가 매우 느림)
                                    - 하드웨어 고장이나 오류 발생 시 해당 블록 이후 블록은 접근할 수 없다
                            - 색인 할당
                                - 파일의 모든 블록 주소를 색인 블록이라는 하나의 블록에 모아 관리함
                                - 유닉스 파일 시스템이 색인 할당을 기반으로 만듬
                - 파일 시스템
                    - FAT 파일 시스템
                        - 각 블록에 포함된 다음 블록의 주소를 한데 모아 테이블 형태로 관리 (파일 할당 테이블, File Allication Tabel, FAT)
                        - 파일의 첫 번째 주소만 알면, 파일의 데이터가 담긴 모든 블록에 접근이 가능함
                        - FAT은 파티션 앞부분에 만들어짐
                        - FAT이 메모리에 적재된 채 실행되면 임의 접근의 성능이 개선됨
                        - 464p 참고
                    - 유닉스 파일 시스템
                        - 색인 할당 기반의 유닉스 파일 시스템
                        - 색인 블록을 i-node(index-node)라고 부름
                        - FAT 파일 시스템은 파일 속성 정보가 디렉터리 엔트리에 표현되는 것과 다르게, 유닉스 파일 시스템에서 파일 속성 정보는 i-node에 표현
                            - 즉, i-node는 파일 속성, 블록 주소 0번~14번까지 가지고 있는 것!
                        - 15개라고 했는데 … 블록이 20개, 30개 그 이상이라면?
                            1. 블록 주소 중 열두개에는 직접 블록 주소를 저장(이걸 직접 블록이라고 함)
                            2. 부족하다면 열 세번째에는 단일 간접 블록(파일 데이터가 저장된 블록이 아닌, 파일 데이터를 저장한 블록 주소가 저장된 블록) 주소를 지정
                            3. 이것도 부족하다면 열 네번째에는 이중 간접 블록 주소를 저장
                                1. 데이터 블록 주소를 저장하는 블록 주소가 저장된 블록
                            4. 이것도 부족하다면 열다섯번째는 삼중 간접 블록 주소를 저장
                                1. 이중 간접 블록 주소가 저장된 블록
                            - 470p 참고
                        - 유닉스 파일 시스템의 디렉터리 엔트리도 파일 이름, i-node 번호로 구성됨
                        - 471p 참고
                    - 이외에도 NTFS도 있고.,., ext 파일 시스템도 있음
- 사용자 인터페이스
    - 커널에 포함되지 않는 서비스
    - 그래픽 유저 인터페이스 (GUI): 그래픽 기반으로 상호작용하는 인터페이스
    - 커맨드 라인 인터페이스 (CLI): 명령어 기반으로 상호작용하는 인터페이스
- 이중 모드
    - 응용 프로그램이 반드시 운영체제의 코드를 사용해서 하드웨어에 접근할 수 있도록 해야 함 —> 이중 모드로써 구현
    - CPU가 명령어를 실행하는 모드를 사용자 모드, 커널 모드로 구분하는 방식
    - 사용자 모드(User Mode)
        - 운영체제 서비스를 제공받을 수 없는 실행 모드 (= 커널 영역의 코드를 실행할 수 없음)
        - 일반적인 응용 프로그램은 기본적으로 사용자 모드로 실행됨
        - 하드웨어 자원에 접근할 수 없음
        - 커널 모드로 전환하고 싶다면 **시스템 호출(System Call)**이라는 **소프트웨어 인터럽트**를 통해 전환함
            - 시스템 호출을 처리하는 순서 (ex. 응용 프로그램이 하드 디스크에 데이터를 저장하려 함)
                1. 하드 디스크에 데이터를 저장하는 시스템 호출을 발생시켜 커널 모드로 전환
                2. 운영체제 내의 “하드 디스크에 데이터를 저장하는 코드”를 실행시켜 하드 디스크에 접근
                3. 하드 디스크에 접근이 끝났다면 사용자 모드로 복귀
            
            → 이 과정을 통해 빈번하게 사용자 모드 - 커널 모드를 오감
            
    - 커널 모드 (Kernel Mode)
        - 운영체제 서비스를 제공받을 수 있는 실행 모드 (= 커널 영역의 코드를 실행할 수 있음)
        - 하드웨어 자원에 접근할 수 있음
    - CPU는 플래그 레지스터의 슈퍼바이저 플래그를 보고 커널 모드면 명령어를 실행, 사용자 모드면 명령어를 실행하지 않음