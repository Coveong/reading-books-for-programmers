# 1. 애자일 개발

# 1. 애자일 실천방법

## 애자일 연합

소프트웨어 팀이 빠르게 일하고 변화에 반응할 수 있도록 하는 가치와 원칙을 세우기 위해 이 분야의 전문가들이 모임을 가졌고, 자신을 **애자일 연합**이라고 불렀다. 그리고 그 후에 **애자일 소프트웨어 개발 선언문**이 나왔다.

## 애자일 소프트웨어 개발 선언문

우리는 아래의 것들을 가치있게 여긴다.

- 프로세스와 툴보다 **개인과 상호작용**이 우선이다.
- 포괄적인 문서보다 **동작하는 소프트웨어**가 우선이다.
- 계약 협상보다 **고객 협력**이 우선이다.
- 계획을 따르는 것보다 **변화에 대한 반응**이 우선이다.

### 프로세스와 툴보다 개인과 상호작용이 우선이다.

뛰어난 팀원들이 모여 있다 해도, **그들이 팀으로서 함께 일하지 않으면 비참하게 실패할 수 있다.**

여기서 뛰어난 팀원이란 **다른 동료와 함께 조화롭게 일할 수 있는 사람**이다.

함께 일하고, 대화하고, 상호작용하는 능력은 다듬어지지 않은 프로그래밍 실력보다 더 중요하다.

툴도 중요하다. 하지만 간소하게 시작하는 것이 좋다. 처음부터 고가의 툴을 사용하는 것 보다는 무료 툴을 사용하고, 그것이 부족할 정도로 성장했다면 더 나은 툴을 사자.

팀을 만들기 위해 노력하고 그 뒤에 팀의 필요를 기반으로 환경을 구축하자!

### 포괄적인 문서보다 동작하는 소프트웨어가 우선이다.

문서화되어 있지 않은 소프트웨어는 재앙이다. 그러나 지나친 문서화는 안 하느니만 못하다. 오히려 문서와 코드가 동기화되지 않아 그릇된 방향으로 프로그래머를 유도할 수도 있다.

팀에서 설계 구조와 구조에 대한 문서는 짧고 요약적이여야 한다.

짧고 : 12~24페이지

요약적 : 문서가 포괄적인 설계 원리와 가장 높은 시스템 단계의 구조에 대해서만 논해야 한다.

🤔 그럼 지식을 어떻게 전달하지?

→ 옆에 앉혀놓고 지식을 전수하자! 밀착 훈련과 상호작용을 통해 팀의 일원으로 만든다.

> 그(문서화) 필요가 중요하지 않다면 아무 문서도 만들지 마라.
> 

코드는 유일하게 모호하지 않은 정보의 원천이다.

### 계약 협상보다 고객 협력이 우선이다.

성공적인 프로젝트를 위해서는 **규칙적으로 자주 고객의 피드백**을 받아야 한다. 소프트웨어 고객이 개발 팀과 가까이서 일한다.

최고의 계약서는 개발 팀과 고객이 함께 작업하면서 결정하는 것이다.

### 계획을 따르는 것보다 변화에 대한 반응이 우선이다.

계획을 세울 때에는 그 계획이 탄력적이고 업무와 기술의 변화에 적응할 준비가 되어 있는지 확인해야 한다.

좀 더 바람직한 계획 전략은 다음 2주간의 세부적인 계획을 수립하고, 다음 3개월간의 개략적인 계획을, 그 이후로는 아주 대강의 계획을 세우는 것이다. **계획은 몇 주간의 시간만 통제**할 뿐이고, 계획의 나머지 부분은 탄력적으로 조정할 수 있다.

## 원칙

- 우리의 최고 가치는 유용한 소프트웨어의 빠르고 지속적인 공개를 통해 고객은 만족시키는 것이다.
    - **자주 공개할 수록, 최종 품질도 좋았다.**
    - 기본적인 시스템을 프로젝트 시작 후 처음 몇 주 안에 공개하고, 2주마다 계속 공개하려고 노력하자.
- 개발 후반부에 접어들었다 할지라도, 요구사항 변경을 환영하라. 애자일 프로세스는 고객의 경쟁 우위를 위해 변화를 이용한다.
    - 소프트웨어 구조를 탄력적으로 유지하기 위해 노력하고, 요구사항이 변경되었을 때 시스템에 미치는 영향을 최소한으로 하라.
- 개발 중인 소프트웨어를 2주에서 2달 사이, 혹은 더 짧은 시간 간격으로 자주 공개하라.
    - 우리의 목적은 고객의 요구를 만족시키는 '소프트웨어'를 공개하는 데 맞춰져 있다.
- 업무를 하는 사람과 개발자는 프로젝트를 통틀어 계속 함께 일해야 한다.
    - 고객 - 개발자 - 이해당사자의 빈번한 상호작용이 있어야 한다.
- 의욕적인 개인들을 중심으로 프로젝트를 구성하라. 환경과 필요로 하는 지원을 제공하고, **그들이 그 일을 해낼 것이라고 믿고 맡겨둬라.**
    - 사람이 성공의 가장 중요한 요소이다.
- 개발 팀 내에서 정보를 전달하고 공유하는 가장 효율적이고 효과적인 방법은 직접 일대일로 대화하는 것이다.
    - **의사소통의 일차적 방식은 대화**다.
    - 문서에 대한 큰 필요성을 느낄 경우에는 작성할 수 있겠지만, 필수적인 것은 아니다. 꼭 필요한 것은 대화다.
- 개발 중인 소프트웨어가 진척 상황의 일차적 척도다.
    - 진행 단계, 문서 양, 기반 구조 코드 양으로 측정하는 것이 아닌, 고객의 요구를 충족시키고 있는 소프트웨어 비율이 진척 상황이다.
- 애자일 프로세스는 지속 가능한 개발을 촉진한다. 스폰서, 개발자, 그리고 사용자는 무한히 지속적인 속도(pace)를 유지할 수 있어야 한다.
    - 애자일은 마라톤이다.
- 우수 기술과 좋은 설계에 대한 지속적인 관심은 속도를 향상한다.
    - 소프트웨어를 가능한 한 깨끗하고 튼튼한 상태로 유지하자.
    - 문제가 생긴다면 그날 업무를 끝내기 전에 그것을 해결한다.
- 단순성(아직 끝내지 않은 일의 양을 최대화하는 예술)은 필수적이다.
    - 가장 간단하고 가장 고품질의 작업을 오늘 행하고, 내일 문제가 생긴다면 그때 변경 작업을 하는 편이 쉽다.
- 최고의 아키텍처, 요구사항, 설계는 자기 조직적인 팀에서 나온다.
    - 책임감은 온전히 팀에게 전달되고, 팀은 그것을 충족시키기 위해 제일 좋은 바업ㅂ은 결정한다.
    - 팀 전체가 책임을 공유하고, 영향력을 갖는다.
- 규칙적으로 팀은 좀 더 효과적인 방법을 반영해야 하고, 적절히 그 행위를 조율하고 조정해야 한다.
    - 조직, 규칙, 대화, 관계 등을 계속 조정한다.
    - 자신들을 둘러싼 환경이 계속 변하고 있다는 사실을 알고, 함께 변하려고 한다.

빠른 속도!

피드백!

책임감!

## 결론

애자일 소프트웨어 개발의 원칙과 가치는 개발 팀이 프로세스 증가 악순환을 깨고 그들의 목표에 다다르기 위해 간단한 테크닉에 초점을 맞추는 것을 돕기 위한 방법으로서 만들어졌다.

# 2. 익스트림 프로그래밍 소개

## 익스트림 프로그래밍 실천방법

### 고객 팀 구성원

거리가 멀어질수록, 고객이 진정한 팀원이 되기 어려워진다.

고객이 가까운 곳에 있을 수 없다면 어떻게 해야 할까? 실제 고객을 대신할 수 있고 그럴 의지가 있는 사람을 찾자.

### 사용자 스토리

일정을 세울 때에는 요구사항을 대략적으로만 알면 된다. 요구사항의 구체적인 세부 내용은 시간이 지남에 따라 바뀌기 쉽다. 실제로 구현되기 한참 전에 요구사항의 구체적인 세부 내용을 기록하는 것은 의미가 없다.

사용자 스토리란 현재 진행 중인 요구사항에 관한 대화의 연상 기호다. 이것은 고객이 우선순위와 추정 비용에 근거해 요구사항의 구현 일정을 수립하게 해주는 계획 툴이다.

### 짧은 반복

개발 중인 소프트웨어를 2주마다 공개하라. 2주마다 피드백을 처리한 소프트웨어를 만들고, 시스템을 시연한다.

- 반복 계획
    - 이전 반복을 바탕으로 반복의 예산으로 세운다.
    - 반복이 시작되면 반복 동안에는 스토리 정의나 우선순위를 바꾸지 않는다.
    - 개발자는 자유롭게 태스크에 나눠 넣고 기술적, 업무적으로 가장 합리적인 순서로 태스크를 수행한다.
- 릴리즈 계획
    - 6번의 반복 일정을 정밀하게 표현한다. 대개 3개월을 의미하며, 메이저 공개를 뜻한다.
    - 고객은 요구 내용을 언제든지 변경할 수 있다.

### 인수 테스트

이 테스트는 시스템이 고객이 명시한 대로 동작하는지 여부를 검증한다.

### 짝 프로그래밍

짝의 한 멤버는 코드를 입력하고, 다른 멤버는 입력되는 코드를 보며 에러와 개선점을 찾는다. 이렇게 두 명은 긴밀한 상호작용을 한다. 짝의 역할은 자주 바뀔 수 있다.

이런 방식은 팀 내부에서 지식이 더 빨리 확산되게 한다.

### 테스트 주도 개발

테스트 케이스의 완성된 본문은 코드와 함께 발전된다. 테스트는 프로그래머로 하여금 프로그램이 잘 동작하는지 점검할 수 있게 해준다. 이런 방식은 리팩토링을 굉장히 용이하게 만든다.

### 공동 소유권

전문 분야에만 발이 묶여있는 것이 아닌, 다른 분야의 전문가와도 페어 프로그래밍을 요청할 수 있다.

### 지속 가능한 속도

소프트웨어 프로젝트는 단거리 경주가 아닌 마라톤이다. 빨리 골인하려면 팀이 지속 가능한 속도로 달려 에너지와 경각심을 보존해야만 한다.

릴리즈의 마지막 주를 제외하면 초과 근무를 하지 않는 것이 좋다.

### 열린 작업 공간

팀은 열린 공간에서 함께 일한다.

조용한 공간보다 두 배 정도 생산성이 더 향상된다.

### 계획 세우기 게임

개발자는 최근의 반복이나 릴리즈에 완성할 수 있는 양을 기준으로 예산을 세워 고객에게 제출하고, 고객은 총 비용의 합이 예산을 넘지 않는 정도로 스토리를 선택한다.

### 단순한 설계

설계를 가능한 한 단순하고 표현적으로 만든다. 현재 반복에서 작업하기로 계획했던 스토리에만 초점을 맞추어 공략하고, 다음에 작업할 스토리에 대해 걱정하지 않는다. 단, 다음 반복에서 시스템의 설계를 마이그레이션해서 현재 구현하고 있는 스토리에 가장 적합한 설계가 되도록 한다.

첫 번째 행동은 DB, 프레임워크를 선택하는 것이 아닌 가능한 한 가장 단순한 방식으로 동작하는 스토리의 첫 묶음을 얻어내는 것이다.

- 어떻게든 동작하는 가장 단순한 것을 생각한다.
    - DB를 사용하지 않을 수도 있다.
    - 멀티스레딩을 사용하지 않을수도 있다.
- 필요하지 않을 것이라는 가정에서 시작한다.
    - 언젠가는 필요할텐데... 바로 컷
    - 지금 기반구조를 추가하는 것이 기다리는 것보다 비용 면에서 효과적이라는 확실한 증거가 있거나 강한 근거가 있을 때 기반구조를 추가한다.
- 코드를 중복해서 쓰지 않는다.
    - 중복 코드가 발견될 때마다 제거한다.
    - 중복성을 제거하는 최선의 방법은 추상화다.

### 리팩토링

리팩토링은 프로젝트나 릴리즈, 반복, 일과가 끝날 때에도 계속 수행된다. 리팩토링을 통해 가능한 한 깔끔하고 단순하며 의미 있는 코드를 유지할 수 있다.

## 결론

익스트림 프로그래밍은 애자일 개발 프로세스를 구성하는 단순하고 구체적인 방식의 집합이다. 이 프로세스는 많은 팀에서 좋은 결과를 낳는다.

# 3. 계획 세우기

## 초기 탐색

스토리마다 몇 포인트인지 측정한다. 포인트가 어느 정도 시간을 필요로 하는지는 몰라도 괜찮다.

### 스파이크, 분할, 속도

지나치게 큰 스토리는 너무 크지 않은 조각으로 분할해야 하고, 지나치게 작은 스토리는 다른 작은 스토리들과 합쳐야 한다.

예를 들어 '사용자는 계좌에 안전하게 돈을 넣고, 꺼내고, 이체할 수 있어야 한다'는 너무 큰 스토리이다. 이걸 분해해보자

- 사용자는 로그인할 수 있다.
- 사용자는 로그아웃할 수 있다.
- 사용자는 자신의 계좌에 돈을 입금할 수 있다.
- 사용자는 자신의 계좌에서 돈을 인출할 수 있다.
- 사용자는 자신의 계좌에서 다른 계정으로 돈을 이체할 수 있다.

스토리의 정확한 크기를 알기 위해서는 속도(velocity)라는 요소가 필요하다. 예를 들어 속도가 스토리의 포인트당 2일이고, 추정 포인트가 4이면 스토리 구현에는 8일이 걸린다.

반복을 통해 스토리의 포인트 수는 더 정확하게 측정할 수 있다. 하지만 처음에는 어렵기 때문에 한 두개의 프로토타입을 만들어보며 팀의 속도를 알 수 있다. 이런 단계를 스파이크(spike)라고 한다.

## 릴리즈 계획 세우기

릴리즈 계획은 속도가 점점 더 정확해짐에 따라 조정될 수 있다.

## 반복 계획 세우기

반복의 크기는 보통 2주이다. 한 반복 안에서 스토리의 순서를 결정하는 것은 기술적인 결정이다. 개발자는 기술적으로 가장 합리적인 순서에 따라 스토리를 구현한다.

반복이 시작되면 스토리를 바꿀 수 없다. 프로젝트에 포함된 스토리나 순서는 변경할 수 있지만, 현재 작업 중인 것은 안 된다.

모든 스토리 구현이 완료되지 않은 경우에도 반복은 정해진 날짜에 끝난다. 완료한 스토리의 추정 소요 시간을 모두 더하여, 반복의 속도를 계산한다.

속도에 대한 피드백은 팀이 계획을 유지할 수 있도록 도와준다. 팀의 전문적지식이나, 팀원의 수나, 아키텍처에 따라 속도가 변동될 수 있다.

## 태스크 계획 세우기

새롭게 반복을 시작할 때, 스토리를 분할해 개발 태스크로 만든다.

태스크는 개발자가 4~16시간동안 구현할 수 있어야 한다.

각 개발자가 한 태스크에 참여할 때, 개발자는 그 태크를 임의의 태스크 포인트로 추정한다.

### 반환점

반복이 반쯤 됐을 때에는 미팅을 가진다. 반복에 계획된 스토리의 반 정도가 진행이 되어있어야 한다.

만약 반이 완료되어 있지 않다면, 태스크와 책임을 재분배하여 반복이 끝날 때 모든 스토리가 완료되도록 해야 한다.

만약 그것이 불가능하다면 가장 낮은 우선순위의 태스크나 스토리를 회피시킨다.

ex. 24개의 스토리 포인트를 가진 8개의 스토리가 있다. 이것은 42개의 태스크로 나눌 수 있다.

그럼 미팅 때에는 21개의 태스크와 12개의 스토리 포인트가 완료되기를 기대한다. 이 12개의 포인트는 완전히 완료된 스토리가 되어야 한다. 우리는 태스크가 완료되는 것이 아닌 '스토리'가 완료되는 것이 중요하다.

가장 최악은 90%의 태스크는 완료되었지만 어떤 스토리도 완료하지 못한 경우다.

## 반복

반복에 마지막에는 시연을 한다. 이런 식으로 고객은 진행 상호아을 수시로 알 수 있고, 속도도 측정할 수 있다. 우선순위가 높은 스토리를 처리하도록 일정을 잡을 수도 있다.

## 결론

반복에서 반복으로, 릴리즈에서 릴리즈로 넘어가면서 프로젝트는 예측 가능하고 안정적인 리듬을 찾아간다.

다이어그램과 계획으로 가득 찬 노트를 보여주는 것보다, 직접 만져보면서 느끼고 피드백을 제공할 수 있는, 동작하는 소프트웨어를 보여주는 것이 바람직하다.

개발자는 스스로 측정한 속도에 의해 제어되는 합리적인 계획을 알 수 있다. 편한 마음으로 작업할 수 있는 태스크를 선택하고, 자신의 기량을 최상으로 유지할 수 있다.



# 4. 테스트

## 테스트 주도 개발

테스트를 먼저 작성하고, 그 이후에 테스트를 구현하는 로직을 작성한다.

TDD를 하게 되면?

- 프로그램의 모든 단일 함수가 그 동작을 검증하는 테스트를 가지게 된다.
- 프로그래머가 훨씬 자유롭게 프로그램을 수정하거나 개선할 수 있다.
- 프로그래머가 다른 관점에서 문제를 해결할 수 있다.
  - 테스트는 호출자의 관점이기 때문이다.
  - 편리하게 호출할 수 있는 소프트웨어를 설계할 수 있다.
- 자신이 반드시 테스트 가능한 프로그램을 설계하도록 강제할 수 있다.
  - 프로그래머가 소프트웨어를 다른 환경과 분리하도록 강제하는 것이다.
- 테스트가 문서화의 귀중한 한 형태로 기능할 수 있다.

프로그래머는 구현하기 전에, 의도를 가능한 단순하고 읽기 편하게 만들어 테스트로 제시하면, 단순하고 명쾌한 프로그램의 구조를 설계할 수 있다.

테스트를 먼저 작성하는 것은 설계 의사결정의 차이를 식별하는 것이다.

## 인수 테스트

단위 테스트는 시스템의 작은 구성 요소가 기대하는 대로 동작하는지 여부는 검증하지만, 시스템이 전체로서 제대로 작동하는지는 검증하지 않는다.

단위 테스트는 시스템의 개별적인 메커니즘을 검증하는 '화이트 박스 테스트'

인수 테스트는 고객의 요구사항이 충족되고 있는지를 검증하는 '블랙박스 테스트'

인수테스트는 시스템의 기능 요소를 위한 컴파일 가능하고 실행 가능한 문서로서의 역할을 수행한다. 인수 테스트는 프로그래머로 하여금 큰 단위에서 뛰어난 아키텍처 의사결정을 할 수 있게 해준다.

### 인수 테스트의 예

코드를 작성하기 전, 설계를 생각하기 전에 하는게 가장 좋다.

스크립트나 텍스트 파일로 작성하는 것이 좋다.

## 결론

검증은 테스트 작성이 주는 이점 중 하나일 뿐이다. 단위 테스트, 인수 테스트 모두 컴파일 및 실행 가능한 문서화의 한 형태이므로, 정확하고 신뢰성있다.

테스트 가능해질 수도록 더욱 주위 환경으로부터 분리된다.



# 5. 리팩토링

모든 소프트웨어 모듈에는 세 가지 기능이 있다.

1. 실행 중에 동작하는 기능
   - 모듈의 존재 이유
2. 변경 기능
   - 대부분 생명주기 동안 변경 과정을 겪는다.
   - 가능한 간단하게 변경을 할 수 있도록 만드는 것이 좋다.
3. 읽는 사람과 의사소통하는 기능
   - 개발자가 쉽게 읽고 이해할 수 있어야 한다.

## 결론

작성한 모든 모듈과 유지보수하는 모든 모듈에 대해 항상 리팩토링 과정을 적용하는 것이 좋다. 여기에 투자하는 시간은 가까운 미래에 다른 사람이나 자신이 들여야 할 수고에 비하면 극히 적은 것이다.



# 6. 프로그래밍 에피소드

## 볼링 게임

- 게임 규칙의 개요
  - 프레임
    - 게임은 10개의 프레임으로 이루어진다.
    - 각 프레임이 시작할 때마다 핀 10개가 세워지고, 플레이어는 핀을 모두 쓰러트릴 수 있는 두 번의 기회가 주어진다.
  - 스트라이크
    - 플레이어가 첫 번째 기회에서 모든 핀을 쓰러트리면 스트라이크이고, 프레임은 끝난다.
    - 이전 프레임까지의 스코어에 10을 더하고, 다음 2개의 공으로 쓰러뜨린 핀의 개수를 더하여 계산된다.
    - 10번째 프레임에서 스트라이크가 나오면, 플레이어는 스트라이크의 스코어를 완결 짓기 위해 2개의 공을 더 던진다.
  - 스페어
    - 첫 번째에는 모두 쓰러트리지 못했으나, 두 번째에 성공하면 스페어이다.
    - 이전 프레임까지의 스코어에 10을 더하고, 다음 1개의 공으로 쓰러뜨린 핀의 개수를 더한다.
    - 10번째 프레임에서 스페어가 나오면, 플레이어는 스페어의 스코어를 완결 짓기 위해 1개의 공을 더 던진다.
- 게임의 요구사항
  - 모든 게임의 결과를 저장해야한다.
  - 팀의 순위를 결정해야 한다.
  - 매주 열리는 시합에서 승자와 패자를 결정해야 한다.
  - 각 게임의 스코어를 정확히 기록할 수 있어야 한다.

1. 한 게임의 스코어를 계산한다.

입력 : 10개의 프레임 투구(throw) (투구: 공이 몇 개의 핀을 쓰러트렸는지 알려주는 정수)

출력 : 각 프레임의 스코어

여기서 테스트 코드는 아래와 같이 나온다.

```java
throwBall(6);
throwBall(3);
assertEquals(0, getScore());
```

UML 다이어그램은 아래와 같이 나온다.

> Game 객체는 Frame 10개의 나열로 이루어져 있다. 각 Frame 객체는 1번, 2번 혹은 3번은 'Throw'를 포함하고 있다.

```
Game` -10→ `Frame` -1..3→ `Throw
```

여기서 의존성 사슬의 끝 부터(Throw) 작업하는 것이 테스트할 때 더 쉽다.

하지만 Throw는 핀의 수를 저장하는 것 이외에는 아무 일도 하지 않는다.

→ 데이터 저장소가 아닌 실제 행위를 하는 객체에 집중하는 것이 좋다.

그러면 그 다음 객체인 Frame의 테스트 코드를 작성해보자!

```java
// TestFrame.java
public void testAddObeThrow() {
	Frame f = new Frame();
	f.add(5);
	assertEquals(5, f.getScore());
}

// Frame.java
getScore()는 있지만, add()는 없는 상태
```

→ add()가 없기 때문에 컴파일에 실패한다.

```java
// Frame.java
public void add(Throw t) {
}
```

→ Throw가 없기 때문에 컴파일에 실패한다.

오잉? 그런데 테스트에서는 정수를 넘겨주는데, 여기에서는 객체(Throw)를 파라미터로 받고 있다.

→ 결국 Throw는 int값으로 대체할 수 있는거 아닐까?

```java
// Frame.java
public void add(int pins) {
}
```

이제 컴파일은 성공, 테스트에는 실패하는 상태가 되었다.

이제 로직을 테스트 성공하게 수정하면 된다!

```java
// Frame.java
public class Frame {
	private int itsScore = 0;

	public int getScore() {
		return itsScore;
	}

	public void add(int pins) {
		itsScore += pins;
	}
}
```

→ 하지만 여기에는 문제가 있다. `add()`의 인자로 11을 넘기게 된다면 어떻게 될까? (최고점은 10이다.) 그리고 `add()`는 스트라이크나 스페어를 처리하지 않는다.

지금 상황에서 Game은 Frame에 의존하고, Frame은 거꾸로 Game에 의존한다.

하지만 Frame을 linked list 형태로 정렬될 수 있다. Frame의 스코어를 얻기 위해 이전 Frame의 스코어를 확인하고, 스페어나 스트라이크가 있을 때 추가되는 공의 개수를 알기 위해 계속 나아가면서 찾으면 된다.

Game을 위한 테스트 케이스를 만들자!

→ 지금 Frame에 대한 테스트 케이스를 만들고 있는데?

→ Game 테스트 케이스에 Frame의 Linked list가 필요하다는 사실을 입증해야한다. Frame에 대한 작업을 멈추고 Game에 대한 작업을 시작하자.

```java
// TestGame.java
public class TestGame extends TestCase {
	public TestGame(String name) {
		super(name)
	}

	public void testOneThrow() {
		Game g = new Game();
		g.add(5)
		assertEquals(5, g.score());
	}
}
```

→ 여기에는 리스트가 없는데?

```java
// Game.java
public class Game {
	public int score() {
		return 0;
	}

	public void add(int pins) {
	}
}
```

→ 이렇게 하면 테스트가 실패함! 이제 테스트를 통과하게 만들려면

```java
// Game.java
public class Game {
	private int itsScore = 0;

	public int score() {
		return itsScore;
	}

	public void add(int pins) {
		itsScore += pins;
	}
}
```

→ 테스트를 통과하는 것까지는 ㅇㅋ. 그런데 도대체 Frame의 Linked list는 왜 필요한 것?

→ 스트라이크와 스페어를 처리하는 테스트를 작성하면 필요하게 된다. 하지만 지금 당장 테스트에 대해서는 스트라이크와 스페어를 처리하지 않으므로 작성하지 않은 것.

스페어가 없는 2개의 Throw를 테스트하는 코드

```java
// TestGame.java
public void testThrowsNoMark() {
	Game g = new Game();
	g.add(5);
	g.add(4);
	assertEquals(9, g.score());
}
```

통과함!

각 프레임에 대해 스코어를 가져오는 테스트 코드

```java
// TestGame.java
public void testFourThrowsNoMark() {
	Game g = new Game();
	g.add(5);
	g.add(4);
	g.add(7);
	g.add(2);
	assertEquals(18, g.score());
	assertEquals(9, g.scoreForFrame(1));
	assertEquals(18, g.scoreForFrame(2));
} 
```

→ `scoreForFrame()`이 없기 때문에 컴파일이 실패한다.

```java
// Game.java
public int scoreForFrame(int frame) {
	return 0;
}
```

→ 컴파일엔 성공하지만, 테스트는 실패한다.

테스트를 통과하게 하려면

1. Frame 객체를 만든다.
2. **Game 내부에 정수 배열을 만들고, add를 호출할 때마다 배열에 새 정수를 추가한다.**

```java
// Game.java
public class Game {
	private int itsScore = 0;
	private int[] itsThrows = new int[21];
	private int itsCurrentThrow = 0;

	public int score() {
		return itsScore;
	}

	public void add(int pins) {
		itsThrows[itsCurrentThrow++] = pins; // add
		itsScore += pins;
	}

	public int scoreForFrame(int frame) { // add
		int score = 0;
		for (int ball = 0; frame > 0 && (ball < itsCurrentThrow);
					ball += 2, frame--) {
						scroe += itsThrows[ball] + itsThrows[ball + 1];
				}
				return score;
	}
}
```

→ 동작하지만, 이 코드는 문제점이 있다.

<이 코드의 문제점>

1. 알아보기 어렵다.
2. Game이 단일 책임 원칙을 위반하고 있다.
   - Throw를 받고 프레임의 스코어를 기록하는 Scorer 객체를 만드는 것이 더 낫지 않나?

→ 일단 모든걸 자리잡게 하고 SRP를 논해보자, 루프를 먼저 단순화해보자.

```java
// Game.java
public int scoreForFrame(int theFrame) {
	int ball = 0;
	int score = 0;
	for (int currentFrame = 0; currentFrame < theFrame; currentFrame++) {
		score += itsThrows[ball++] + itsThrows[ball++];
	}

	return score;
}
```

→ 하지만 이 코드는 스페어, 스트라이크에 대해서는 제대로 동작하지 않는다. 또한 컴파일러에 따라 순서 문제가 생길 수도 있다.

```java
// Game.java
public int scoreForFrame(int theFrame) {
	int ball = 0;
	int score = 0;
	for (int currentFrame = 0; currentFrame < theFrame; currentFrame++) {
		int firstThrow = itsThrows[ball++];
		int secondThrow = itsThrows[ball++];
		score += firstThrow + secondThrow;
	}

	return score;
}
```

이제 스페어를 처리해보자! 그 전에, 테스트를 리팩토링해보자

```java
// TestGame.java
public class TestGame extends TestCase {
	public TestGame(String name) {
		super(name)
	}

	private Game g; // 추가해서 게임 생성하는 중복 코드가 들어가지 않게!
	
	public void setUp() {
		g = new Game();
	}

	public void testOneThrow() {
		g.add(5) // 이렇게!
		assertEquals(5, g.score());
	}

	// ...
}
```

스페어 처리 테스트 케이스

```java
// TestGame.java
public void testSimpleSpare() {
	g.add(3);
	g.add(7);
	g.add(3);
	assertEquals(13, g.scoreForFrame(1));
}
```

→ 테스트에 실패한다.

```java
// Game.java
public int scoreForFrame(int theFrame) {
	int ball = 0;
	int score = 0;
	for (int currentFrame = 0; currentFrame < theFrame; currentFrame++) {
		int firstThrow = itsThrows[ball++];
		int secondThrow = itsThrows[ball++];
		score += firstThrow + secondThrow;

		// 스페어일 경우에 다음 프레임의 첫 번째 Throw의 점수를 추가로 저장한다.
		if (frameScore == 10) {
			score += frameScore + itsThrows[ball++];
		} else {
			score += frameScore;
		}
	}

	return score;
}
```

→ 이렇게 하면 성공한다.

하지만 공의 개수를 증가시키는 부분이 저기에 있다면 안될 것 같은데?

```java
// TestGame.java
public void testSimpleFrameAfterSpare() {
	g.add(3);
	g.add(7);
	g.add(3);
	g.add(2);
	assertEquals(13, g.scoreForFrame(1));
	assertEquals(18, g.score());
}
```

무언가 로직이 잘못되었다. score()를 볼까??

```java
// Game.java
public int score() {
	return itsScore;
}
```

→ 게임은 실제 스코어가 아니라, 넘어뜨린 핀수의 합을 반환하는 것 뿐이다. score는 현재 프레임으로 scoreForFrame()을 호출해야한다.

그러면 현재 핀을 가져오게 바꾸어보자

```java
// Game.java
private int itsCurrentFrame = 1;
private boolean firstThrow = true;

public int getCurrentFrame() {
	return itsCurrentFrame;
}

public void add(int pins) {
	itsThrow[itsCurrentThrow++] = pins;
	itsScore += pins;
	adjustCurrentFrame();
}

private void adjustCurrentFrame() {
	if (forstThrow == true) {
		firstThrow = false;
	} else {
		firstThrow = true;
		itsCurrentFrame++;
	}
}
// TestGame.java
public void testTwoThrowsNoMark() {
	g.add(5);
	g.add(4);
	assertEquals(9, g.score());
	assertEquals(2, g.getCurrentFrame());
}

public void testFourthorwsNoMark() {
	g.add(5);
	g.add(4);
	g.add(7);
	g.add(2);
	assertEquals(18, g.score());
	assertEquals(9, g.scoreForFrame(1));
	assertEquals(9, g.scoreForFrame(2));
	assertEquals(3, g.getCurrentFrame());
}
```

→ 이제 잘 동작한다. getCurrentFrame을 스페어가 나오는 2개의 테스트로 시험해보자

```java
// TestGame.java
public void testSimpleSpare() {
	g.add(3);
	g.add(7);
	g.add(3);
	assertEquals(13, g.scoreForFrame(1));
	**assertEquals(2, g.getCurrentFrame());**
}

public void testSimpeFrameAfterSpare() {
	g.add(3);
	g.add(7);
	g.add(3);
	g.add(2);
	assertEquals(13, g.scoreForFrame(1));
	assertEquals(18, g.scoreForFrame(2));
	**assertEquals(3, g.getCurrentFrame());**
}
```

그리고 score()를 바꿔보자

```java
// TestGame.java 
public void testSimpeFrameAfterSpare() {
	g.add(3);
	g.add(7);
	g.add(3);
	g.add(2);
	assertEquals(13, g.scoreForFrame(1));
	assertEquals(18, g.scoreForFrame(2));
	**assertEquals(18, g.score());**
	assertEquals(3, g.getCurrentFrame());
}
// Game.java 
public int score() {
	return scroeForFrame(getCurrentFrame() - 1);
}
```

→ 하지만 이렇게 하면 실패하는 테스트 케이스가 있다.

```java
// TestGame.java 
public void testOneThrow() {
	g.add(5);
	assertEquals(5, g.score());
	assertEquals(1, g.getCurrentFrame());
}
```

→ 이 코드에서는 scoreForFrame(0)을 부르고 있기 때문이다.

→ 음 ... 하지만 끝나지 않은 프레임에서 호출할 일은 없다. 즉, 중요하지 않은 테스트 케이스인 것.

→ 이 테스트 케이스는 목적에 부합한 기능을 하지 않다고 생각하고 삭제.

이제 스트라이크를 테스트하는 코드를 작성해보자!

```java
// TestGame.java 
public void testSimpleStrike() {
	g.add(10);
	g.add(3);
	g.add(6);
	assertEquals(19, g.scoreForFrame(1));
	assertEquals(28, g.score());
	assertEquals(3, g.getCurrentFrame());
}
```

이걸 통과하도록 만들어보자

```java
// Game.java

public class Game {
	public void add(int pins) {
		itsThrows[itsCurrentThrow++] = pins;
		itsScore += pins
		adjustCurrentFrame(**pins**);
	}

	private void adjustCurrentFrame(**int pins**) {
	if (forstThrow == true) {
		if (pins == 10) { // 스트라이크
			itsCurrentFrame++;
		} else {
			firstThrow = false;
		}
	} else {
		firstThrow = true;
		itsCurrentFrame++;
	}

	public int scoreForFrame(int theFrame) {
		int ball = 0;
		int score = 0;
		for (int currentFrame = 0; currentFrame < theFrame; currentFrame++) {
			int firstThrow = itsThrows[ball++];

			**if (firstThrow == 10) { // 스트라이크
				score += 10 + itsThrows[ball] + itsThrows[ball + 1];
			} else {**
				int secondThrow = itsThrows[ball++];
				score += firstThrow + secondThrow;
		
				// 스페어일 경우에 다음 프레임의 첫 번째 Throw의 점수를 추가로 저장한다.
				if (frameScore == 10) {
					score += frameScore + itsThrows[ball++];
				} else {
					score += frameScore;
				}
			**}**
		}
	
		return score;
	}
}
```

테스트를 통과한다!

이제 퍼펙트 게임의 스코어를 기록하는지 확인해보자

```java
// TestGame.java 
public void testPerfectGame() {
	for (int i = 0; i < 12; i++) {
			g.add(10);
	}
	assertEquals(300, g.score());
	assertEquals(10, g.getCurrentFrame());
}
```

→ 현재 프레임이 12까지 증가하기 때문에 스코어가 330이 나오고, 테스트가 실패한다.

```java
// Game.java
private void adjustCurrentFrame(**int pins**) {
	if (forstThrow == true) {
		if (pins == 10) { // 스트라이크
			itsCurrentFrame++;
		} else {
			firstThrow = false;
		}
	} else {
		firstThrow = true;
		itsCurrentFrame++;
	}
	itsCurrentFrame = Math.min(11, itsCurrentFrame); // getCurrentFrame에서 1을 빼기 때문에 10번째가 아닌 9번째 프레임의 스코어를 준다. 즉, 11로 제한해야하는 것이다.
}
// TestGame.java 
public void testPerfectGame() {
	for (int i = 0; i < 12; i++) {
			g.add(10);
	}
	assertEquals(300, g.score());
	assertEquals(11, g.getCurrentFrame());
}
```

오히려 ... Throw 말고 Game부터 하는게 좋았을 수도 있다.

(하향식. 테스트우선 설계!)

이제 리팩토링을 하면~! (Scorer를 추가하고, 코드를 읽기 쉽게 바꾸자!)

```java
// Game.java
public class Game {
	private int itsCurrentFrame = 0;
	private boolean firstThrowInFrame = true;
	private Scorer itsScorer = new Scorer();

	public int score() {
		return scroeForFrame(itsCurrentFrame);
	}

	public void add(int pins) {
		itsScorer.addThrow(pins); // 책임을 Scorer에게 넘긴다.
		adjustCurrentFrame(pins);
	}

	private void adjustCurrentFrame(int pins) {
		if (lastBallInFrame(pins)) {
			advanceFrame();
		} else {
			firstThrowInFrame = false;
		}
	}

	private boolean lastBallInFrame(int pins) {
		return strike(pins) || !firstThrowInFrame;
	}

	private boolean strike(int pins) {
		return (firstThrowInFrame && pins == 10);
	}

	private void advanceFrame() {
		itsCurrentFrame = Math.min(10, itsCurrentFrame + 1);
	}

	public int scoreForFrame(int theFrame) {
		return itsScorer.scoreForFrame(threFrame);
	}
}
// Scorer.java
public class Scorer {
	private int ball;
	private int[] itsThrows = new int[21];
	private int itsCurrentThrow = 0;

	public void addThrow(int pins) {
		itsThrows[itsCurrentThrow++] = pins;
	}

	public int scoreForFrame(int theFrame) {
		ball = 0;
		int score = 0;
		for (int currentFrame = 0; currentFrame < theFrame; currentFrame++) {
			if (strike()) {
				score += 10 + nextTwoBallsForStrike();
				ball++;
			} else if (spare()) {
				scroe += 10 + nextBallForSpare();
				ball += 2;
			} else {
				score += twoBallsInFrame();
				ball += 2;
			}
		}
		return score;
	}

	private boolean strike() {
		return itsThrows[ball] == 10;
	}

	private boolean spare() {
		return (itsThrows[ball] + itsThrows[ball + 1]) == 10;
	}

	private int nextTwoBallsForStrike() {
		return itsThrows[ball + 1] + itsThrows[ball + 2];
	}

	private int nextBallForSpare() {
		return itsThrows[ball + 2];
	}

	private int twoBallsInFrame() {
		return itsThrows[ball] + itsThrows[ball + 1];	
	}
}
```

## 결론

객체 지향 설계를 모든 애플리케이션에 적용하지 않아도 괜찮다.

다이어그램은 때로는 불필요할 때도 있다. (확인할 코드 없이 다이어그램을 만들고, 그것을 따르려고 할 때에)

테스트를 먼저 작성하여 작은 단계를 밟아나가면서 최적의 설계를 개선하자!