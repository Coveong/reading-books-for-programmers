# 1. 애자일 개발

## 1. 애자일 실천방법

### 애자일 선언문

소프트웨어의 개발팀이 빠르게 일하고 변화에 반응할 수 있또록 하는 가치와 원칙을 세우기 위해 모임

중요히 여기는 가치

- 프로세스와 툴보다 개인과 상호작용이 우선이다.
- 포괄적인 문서보다 동작하는 소프트웨어가 우선이다.
- 계약 협상보다 고객 협력이 우선이다.
- 계획을 따르는 것보다 변화에 대한 반응이 우선이다.

-- 즉 왼쪽 항목보다 오른쪽 항목에 더 가치를 부여한다는 뜻이다.



#### 프로세스와 툴보다 개인과 상호작용 우선이다.

뛰어난 팀원은 에이스 프로그래머가 아닌 다른 동료와 함께 조화롭게 일할 수 있는 사람이여야 한다.

프로그래밍 실력보다 상호작용하는 능력이  더 중요하다.

성공을 위해 알맞은 툴은 중요하지만 툴이 강조되는 만큼 통제할수 없는 양만큼의 툴은 좋지 않다.

좋은 팀을 만들기 위해 최우선으로 노력하고 그런 뒤에 팀의 피룡를 기반으로 환경을 구축하자.



#### 포괄적인 문서보다 동작하는 소프트웨어가 우선이다.

문서화 되어 있지 않은 소프트웨어는 재앙이다.( 정말 공감되는 말.)

코드는 이상적인 매체가 아니다. 설꼐 의사결정의 이유와 시스템을 설명하는 사람이 읽을 수 있는 형태로 된 문서를 만들어야 한다.

지난친 문서는 안하느니만 못하다.

설계 원리와 구조에 대한 문서는 짧고 요약적이여야 한다.

새로운 팀원은 문서와 동시에 팀원과 상호작용을 통해 일원이 되어 가야 한다.

새로운 팀원에게 정보를 전할 수 있는 제일 좋은 기록은 Code & Team 이다.

##### 마틴 문서화 제 1법칙

**계약 협상보다 고객 협력이 우선이다.**

- 프로젝트 요구사항, 일정, 비용을 명시한 계약서는 근본적으로 문제가 있기 때문에 프로젝트 기한만료 전에 개발팀과 고객이 함께 작업하면서 결정하는 것이다.

**계획을 따르는 것보다 변화에 대한 반응이 우선이다.**

- 소프트웨어의 성공과 실패를 좌우하는 것은 변화에 대한 반응 능력인데 이는 프로젝트 과정은 먼 미래까지 계획될수 없기 때문이다.

### 원칙

앞서 말한 가치들이 이끌어낸 원칙

1. 우리의 최고의 가치는 유용한 소프트웨어의 빠르고 지속적인 공개를 통해 고객을 만족시키는 것이다.
   - 공개본에서 기능하는 부분이 적을수록 최종 공개본의 품질이 높아 진다.
2. 개발  후반부에 접어들었다 할지라도, 요구사항 변경을 환영하라. 애자일 프로세스는 고객의 경쟁 우위를 위해 변화를 이용한다.
3. 개발 중인 소프트웨어를 2주에서 2달 사이, 혹은 더 짧은 시간 간격으로 자주 공개하라.
4. 업무를 하는 사람과 개발자는 프로젝트를 통틀어 계속 함께 일해야 한다.
5. 의욕적인 개인들을 중심으로 프로젝트를 구성하라. 환경과 필요로 하는 지원은 제공하고, 그들이  그 일을 해낼 것이라 믿고 맡겨둬라.
6. 개발 팀 내에서 정보를 전달하고 공유하는 가장 효율적으로 효과적인 방법은 직접 일대일로 대화하는 것이다.
7. 개발 중인 소프트웨어가 진척 상황의 일차적 척도다.
8. 애자일 프로세스는 지속 가능한 개발을 촉진한다. 스폰서, 개발자, 그리고 사용자는 무한히 지속적인 속도를 유지할 수 있어야 한다.
9. 우수 기술과 좋은 설계에 대한 지속적인 관심은 속도를 향상한다.
10. 단순성(아직 끝나지 않은 일의 양을 최대화하는 예술)은 필수적이다.
11. 최고의 아키텍처, 요구사항, 그리고 설계는 자기 조직적인 팀에서 나온다.
12. 규칙적으로 팀은 좀 더 효과적인 방법을 반영해야 하고, 적절히 그 행위를 조율하고 조정해야 한다.



#### 결론

모든 소프트웨어 개발자와 모든 개발 팀의 직업적 목표는 그들의 고용인과 고객에게 가능한 가장 높은 가치로 전달하는 것이다.

애자일 소프트웨어 개발의 원칙과 가치는 개발 팀이 프로세스 증가 악순환을 깨고 그들의 목표에 다다르기 위한 방법이다.





## 2. 익스트림. 프로그래밍 소개

### 익스트림 프로그래밍 실천방법



### 고객과 팀 구성원

우리는 고객과 개발자가 서로 긴밀하게 작업하면서 서로 문제를 인식하고 이를 해결하기 위해 노력해야 한다.

고객과 같은 공간에서 일하는것이 가장 좋지만 그럴수 없다면 가까이 있을 수 있는 고객을 대신할수 있고 그럴 의지가 있는 사람을 찾아라.



### 사용자 스토리

사용자 스토리란 현재 진행중인 요구사항에 관한 대화의 연상 기호다. 고객이 우선순위와 추정 비용에 근거해 요구사항의 구현 일정을 수립하게 해주는 계획툴이다.



### 짧은 반복

프로젝트는 개발 중인 소프트웨어를 2주마다 공개한다.

**반복 계획**

개발자가 세운 예산에 따라 고객이 선택한 사용자 스토리의 집합

반복이 시작되면 개발자는 스토리를 자유롭게 태스크에 기술적, 업무적으로 합리적인 순서로 테스크를 수행

**릴리즈 계획**

릴리즈는 3개월 동안을 의미하며 보통 최종 제품에 포함되는 메이저 공개를 뜻한다.

릴리즈는 절대적인 것이 아니다. 요구 내용을 언제든 변경할 수 있다.



### 인수테스트

사용자 스토리의 세부 상항은 고객이 명시한 인수 테스트의 형태로 기록된다.

이테스트는 시스템이 고객이 명시한 대로 동작하는지 여부를 검증한다.

시스템이 인수 테스트를 통과하면 통과한 테스트의 본문에 추가되고 다시 실패하는 것이 허용되지 않는다.



### 짝 프로그래밍

운영 코드는 같은 워크스테이션으로 일하는 프로그래머 짝들에 의해 작성된다.

한 사람은 키보드를 잡고 코드를, 다른 사람은 코드를 보면서 에러와 개선점을 찾는다.

이런 방식은 팀 내부에서 지식이 더 빨리 확산되게 한다.



### 테스트 주도 개발

테스트 케이스의 완성본은 단위테스트를 통과하기 위해 작성하기 때문에 완성된 테스트 케이스는 본문 코드와 함께 발전한다.

프로그래머로 하여금 프로그램의 동작을 점검할수 있게 하는데 이는 리팩토링을 굉장히 용이하게 만든다.

객체 지향 설계 원칙은 이런 비간섭화를 구현하는 데 큰 역할을 한다.



### 공동 소유권

짝은 어떤 모듈이라도 저검하고 개선할 권리를 갖는다. 모듈이나 기술에 대해 다른 사람보다 더한 권한을 갖지 않는다.



### 지속적인 통합

비차단 소스 제어 방식을 사용한다.아무때나 어떤 모듈이라도 체크아웃을 허용한다는 뜻이다.

긴 병합 과정을 피하기 위해, 모듈을 빈번히 체크인 한다.

새 코드와 병합할 부분이 있으면 하고 필요하면 먼저 체크인 한 프로그래머와 상의해 새 시스템을 빌드한다. 통합되면 망가진 부분을 수정한다.

따라서 처음부터 끝까지 전체 시스템을 빌드한다.



### 지속 가능한 속도

xp규칙은 초과 근무를 하지 않도록 해야 한다는 것이다.

소프트웨어는 단거리가 아니라 마라톤이기 때문에 지속 가능한 속도로 에너지와 경각심을 보존해야 한다.



### 열린 작업 공간

 낮은 웅성거림으로 차있는 공간에서 각각의 문제가 생겼을때 들을 수 있는 위치에서 서로 상태를 잘 알고 집중적으로 대화할수 있는 위치에서 일해라.



### 계획 세우기 게임

 개발의 책임 분리에 있다. 고객은 기능 요소의 중요성을 결정하고 개발자는 구현비용이 얼마나 들것인지 결정한다.이 스토리를 반복해 진행 감을 잡고 기간과 비용을 정할수 있게 되어야 한다.



### 단순한 설계

설계를 가능한 단순하고 표현적으로 만든다. 작업하기로 했던 스토리에 초점을 맞추어 한다. 다음 반복으로 넘어갈때 마이그레이션 해서 스토리에 가장 적합한 설계가 되도록 한다. 가장 단순한 방식으로 동작하는 스토리의 첫 묶음을 얻어내는 것이 될것이다.

- 어떻게든 동작하는 가장 단순한 것을 생각한다.
- 필요하지 않을 것이라는 가정에서 시작한다.
- 코드를 중복해서 쓰지 않는다.



### 리팩토링

코드는 부패하기 쉽다. 이런 퇴화를 리팩토링은 행위에 영향을 주지 않고 시스템의 구조를 개선하는 방식인데 이것을 결합하면 아키텍처에 있어 중요 변환이 된다.

작은 변환이 끝나고 나면, 단위테스트를 하고 변환을 수행한다. 이를 통해 가능한 깔끔하고 단순하며 의미있는 코드를 유지할 수 있다.



### 메타포

전체를 하나로 묶는 큰 그림이다.개별의 모듈위치와 형태를 명백하게 만드는 시스템 비전으로 메타포와 일치하지 않는다면 그 모듈이 잘못되었음을 알수 있다.

퍼즐로 따졌을때 메타포는 전체 그림이고 모듈은 퍼즐이다 모듈과 메타포를 비교해서 문제점을 알수 있다.



### 결론

 익스트림 프로그래밍은 애자일 개발의 단순하고 구체적인 방식의 집합이다.



## 3. 계획 세우기



### 초기 탐색

프로젝트를 시작하면 개발자와 고객은 각자의 스토리를 써가지만 확실하지 않다.하지만 대략정인 포인트를 정해볼수 있다.



### 스파이크, 분할, 속도

너무 크거나 작은 스토리는 추정하기 어렵다.

따라서 큰 스토리는 조각내야 하고 작은 스토리는 병합해야한다.

이에 따라 다시 추정야한다.

다시 추정된 스토리의 정확한 크기를 알기 위해 속도를 필요로 한다.

프로젝트의 진행에 따라 스토리의 포인트를 측정할수 있기 때문에 조금씩 정확한 측정치를 낳게 된다.

이런 단계를 스파크라고 한다.



### 릴리즈 계획 세우기

속도를 기준으로 각 스토리 비용, 우선도를 알수있게 된다.

여기서 중요한 것을 결정해 내는 것이 업무 의사결정이다.

릴리즈의 계획은 속도가 점점 더정확해 짐애 따라 조정 될 수 있다.



### 반복 계획 세우기

한 반복안에서의 스토리 순서를 결정하는 것은 기술적인 결정이다.

일단 반복되면 스토리를 바꿀수 없다.

스토리가 완료되지 않아도 반복은 정해진 날에 끝난다.



### 테스크 계획 세우기

개발자와 고객은 계획을 세워 스토리를 분할해 개발 테스크로 만든다. 

테스크 포인트가 그들 개인적인 예산이고  예산을 다상활때까지 남는다.



### 반환점

스토리의 진행 정도를 확인해여 재분배를 통해 완료되도록 해야 한다



### 반복

반복에 마지막에는 고객앞에서 시연하고 프로젝트의 외관 느낌을 평가해 피드백을 제공받는다.

원하는 대로 프로젝트를 관리하는 모든 데이터와 제어 장치를 갖게 된다.



### 결론

안정적인 리듬을 찾아 모두가 무엇을 기대하고 진행상황을 파악하며 피드백을 재공하는 것이 바람직하다.



## 4. 테스트

### 테스트 주도 개발

테스트를 하면 좋은 점이 무엇일까? 에대한 효과는 모든 단일 함수가 동작검증하는 테스트를 갖게 되어 이후 기능이 망가질때마다 사실을 알고 수정 개선이 용이하는 것이다.

또 테스트를 먼저 작성할 경우 프로그래머가 다른 관점에서 문제를 해결할 수 있다는 것이다.

테스트 가능한 프로그램을 설계하도록 강제할 수 있다.



### 테스트 우선 방식 설계의 예

프로그래머는 자신의 의도 구현하기 전에, 먼저 그 의도를 가능한 단순하고 읽기 편하게 만들어 테스트로 제시한다.

**테스트를 먼저 작성하는 것은 설계 의사결정의 차이를 식별하는 것이다.**



### 운좋게 얻은 분리

분리 작업이 테스트에 대한 필요에서 촉발되었다.

명백하게 테스트에서 모듈 분리에 대한 필요성은 프로그래머가 프로그램 전체 구조에 이득이 되는 방식으로 분리 작업을 하도록 강제한다.

코드보다 테스트를 먼저 작성하면 설계가 개선된다.



### 인수 테스트

단위테스트는 시스템의 작은 구성 요소가 기대한 대로 동작하는지 검증하지만 시스템 전체는 아니다.

단위테스트는 시스템 개별 메커니즘 검증하는 화이트 박스

인수테스트는 고객의 요구사항이 충족됙 있는지 검증하는 블랙박스 테스트다.



인수 테스트는  기능 요소의 궁극적 문서화기 떄문에 이를 보고 기능 요소를 이해할수 있다.

인수 테스트 프레임 워크를 만드는 일이 기운 빠지는 작업처럼 보일지도 모른다. 그러나 프로그래머가단 한번의 반복 동안에 작업할 기능 요소를 택하고 테스트 필요 프레임 워크를 만든 다면 어렵지 않을 것이다.



### 결론

테스트를 많이 실행할수록 어긋나는 것들을 빨리 찾게 된다.

검증은 테스트 작성이 주는 이점중 하나일 뿐이다.

이모든 테스트 작업에서 가장 중요한 이점은 설계에 미치는 효과일 것이다.



## 5. 리팩토링

모든 소프트웨어에는 3가지 기능이 있다.

1. 실행중 동작
2. 변경
3. 읽는 사람과 소통하는 기능



위의것들을 만드는데에는 원칙과 패턴도 중요하지만 주의력과 훈련이 필요하다.



###  결론

책으로 볼경우 코드를 총 4단계로 바꾸어서 설명하는데 코드를 모두 작성할수 없기에 결론에 정리한다.

한번만 호출되는 함수를 추출해 내었다. 이게 성능에 부정적이라고 생각할수 있지만 향상된 가독성이 가치가 있다라고 필자는 설명한다. 무제가 되지않는한 그것이 문제가 없을 때까지 증명해 보아라.

모든 모듈의 유지보수 ,향상등을 위한 리팩토링 과정을 적용하라.

오늘 쉽게 생략한다면 추후에 굉장히 힘들게 될것이다.

리팩토링의 목표는 코드를 매일 청소하는 것이다. 문제가 쌓이고 쌓여 나중에 한번에 처리하는 것을 원치 않는다. 최소한 노력으로 시스템을 만질수 있기 위해 코드의 깔끔함을 유지하자.



## 6.프로그래밍 에피소드

내용이 대화 형식이라 내용은 생략

### 결론

테스트를 먼저 작성하여 작은 단계를 밝아나가면서 그 최적 설계란 것이 개선될수 있다는 걸 알게  것이다.



> ps . 다이어그램은 떄로는 불필요 할수 있고 다이어 그램이 있다고 그것이 과업에 가장 최적의 설계라고 생각하면 안된다.









