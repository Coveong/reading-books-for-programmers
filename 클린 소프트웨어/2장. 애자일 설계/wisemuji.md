# 애자일 설계

# 애자일 설계란 무엇인가?

## 설계와 악취: 부패하고 있는 소프트웨어의 냄새

1. 경직성: 변경하기 어려움
1. 취약성: 관련 없는 부분이 망가지기 쉬움
1. 부동성: 재사용하기 어려움
1. 점착성: 제대로 동작하기 어려움
1. 불필요한 복잡성: 과도한 설계
1. 불필요한 반복: 단일 추상 개념으로 통합이 가능함
1. 불투명성: 혼란스러운 표현

## 애자일 팀은 소프트웨어가 부패하도록 내버려두지 않는다.

시스템의 설계를 가능한 단순하게 유지하고 테스트로 뒷받침한다. 각 반복마다 개선한다.

만약 소프트웨어의 설계가 요구사항 변경 때문에 퇴화한다면, 우리는 애자일 방식대로 하고 있지 않은 것이다.

## 가능한 좋은 상태로 설계 유지하기

설계는 명료한 상태로 유지되어야 하고 설계의 가장 중요한 표현인 소스 코드 역시 명료한 상태로 유지되어야 한다.

## 결론

애자일 설계는 과정이지 결과가 아니다.

모든 시점에서 시스템의 설계를 가능한 한 간단하고, 명료하고, 표현적으로 유지하려는 노력이다.

# 단일 책임 원칙(SRP)

> 한 클래스는 단 한 가지의 변경 이유만을 가져야 한다.

응집도라고도 불린다.

## 책임이란 무엇인가?

SRP의 맥락에서 우리는 책임을 변경을 위한 이유로 정의한다.

불필요한 복잡성: 책임이 두 가지 이상이 아니라면 굳이 분리할 필요는 없다. 변경의 축은 변경이 실제로 일어날 때만 변경의 축이다.

## 결론

SRP는 가장 간단한 원칙 중 하나이지만 동시에 제대로 적용하기 가장 어려운 원칙 중 하나다.

# 개방 폐쇄 원칙 (OCP)

> 소프트웨어 개채는 확장에 열려 있어야 하고 수정에는 닫혀 있어야 한다.

> 모든 시스템은 생명주기 동안에 변화한다. 이것은 개발 중인 시스템이 첫 번째 버전보다 오래 남길 원한다면 반드시 염두에 두어야 할 사실이다.

by 이바르 야콥슨

## 상세 설명

1. 확장에 대해 열려 있다.
  * 이는 모듈의 행위가 확장될 수 있음을 의미한다. 요구사항이 변경되었을 때 변경에 맞게 새로운 행위를 추가할 수 있다.
2. 수정에 대해 닫혀 있다.
  * 어떤 모듈의 행위를 확장하는 것이 그 모듈의 소스 코드나 바이너리 코드의 변경을 초래하지 않는다.
  
## 해결책은 추상화다

모듈은 고정된 추상화에 의존하기 때문에 수정에 대해 닫혀 있을 수 있다. 

그 모듈의 행위는 추상화의 새 파생 클래스들을 만듦으로써 확장이 가능하다.

## 예상과 자연스러운 구조

폐쇄는 완벽할 수 없기 때문에 전략적이어야 한다.

즉, 설계자는 자신의 설계에서 닫혀 있는 변경의 종류를 선택해야 한다.

## 올가미 놓기

변경을 촉진하는 법:
1. 테스트를 먼저 작성한다.
1. 아주 짧은 주기로 개발한다.
1. 기반구조보다 기능 요소를 먼저 개발하고 자주 이 기능 요소를 이해당사자에게 보여준다.
1. 가장 중요한 기능 요소를 먼저 개발한다.
1. 소프트웨어를 빨리, 그리고 자주 릴리즈한다.

## 결론

OCP를 따르면 객체 지향 기술에서 당연하게 요구되는 최상의 효용을 낳는다.

단, 어설픈 추상화를 피하는 일은 추상화 자체만큼이나 중요하다.

# 리스코프 치환 원칙 (LSP)

> 서브타입은 그것의 기반 타입으로 치환 가능해야 한다.

> 타입 S의 각 객체 o1과 타입 T의 각 객체 o2가 있을 때, T로 프로그램 P를 정의했음에도 불구하고, o2를 o1로 치환할 때 P의 행위가 변하지 않으면, S는 T의 서브타입이다.

## LSP 위반 예시

Square <-> Rectangle 의 관계

height, width를 갖는 Rectangle 클래스가 있을 때, is-a 관계인 Square 클래스가 Rectangle을 상속받게 된다면 불필요한 height, width 필드를 갖게 된다.

## is-a는 행위에 대한 것이다

행위 측면에서 봤을 때 Square는 Rectangle이 아니다.

## 계약에 의한 설계

기반 클래스의 인터페이스를 통해 어떤 객체를 사용할 때 사용자는 그 기반 클래스의 사전조건과 사후조건만 알 수 있다.

기반 클래스의 사용자가 파생 클래스의 출력에 의해 혼란스러워해서는 안된다.

## 결론

LSP는 OCP를 가능하게 만들어주는 주 요인 중 하나다. 기반 타입으로 표현된 모듈을 수정 없이도 확장 가능하게 만드는 서브타입의 치환 가능성을 말한다.

is-a 용어는 서브타입의 정의가 되기에는 그 의미가 지나치게 넓다. 서브타입의 진실된 정의는 '치환 가능성'이다.

# 의존 관계 역전 원칙 (DIP)

> 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다. 둘 모두 추상화에 의존해야 한다.
> 추상화는 구체적인 사항에 의존해서는 안된다. 구체적인 사항은 추상화에 의존해야 한다.

## 레이어 나누기

잘 구조화된 모든 객체 지향 아키텍처는 레이어를 분명하게 정의했다.

여기서 각 레이어는 잘 정의되고 제어되는 인터페이스를 통해 일관된 서비스의 집합을 제공한다.

## 추상화에 의존하자

* 어던 변수도 구체 클래스에 대한 포인터나 참조값을 가져서는 안된다.
* 어떤 클래스도 구체 클래스에서 파생되어서는 안된다.
* 어떤 메소드도 그 기반 클래스에서 구현된 메소드를 오버라이드해서는 안된다.

## 결론 

객체 지향 프로그래밍은 구체적인 사항과 정책이 모두 추상화에 의존하고 대개 그 클라이언트가 서비스 인터페이스를 소유하게 만든다.

# 인터페이스 분리 원칙(ISP)

> 클라이언트가 자신이 사용하지 않는 메소드에 의존하도록 강제되어서는 안된다.

응집력이 없는 인터페이스를 필요로 하는 객체가 있지만 클라이언트는 그것을 하나의 단일 클래스로 생각해서는 안된다. 클라이언트는 응집력이 있는 인터페이스를 가지는 추상 기반 클래스에 대해 알고 있어야 한다.

## 인터페이스 변경

인터페이스의 변경을 줄이려면 기존 인터페이스를 변경하는 것이 아니라 기존 객체에 새로운 인터페이스를 추가하면 된다.

## 결론

클라이언트는 자신이 실제로 호출하는 메소드에만 의존해야 하는데 그러려면 비대한 클래스의 인터페이스를 클라이언트 고유의 인터페이스 여러 개로 분해해야 한다.

이를 통해 호출하지 않는 메소드에 대한 클라이언트의 의존성을 끊고 클라이언트가 서로에 대해 독립적이 되게 만들 수 있다.
