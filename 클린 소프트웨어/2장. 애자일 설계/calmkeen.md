# 2.애자일 설계

## 7. 애자일 설계란 무엇인가

### 잘못된 설계의 증상

1. 경직성(Rigidity) : 설계를 변경하기 어려움
2. 취약성(Fragility) : 설계가 망가지기 쉬움
3. 부동성(Immobility) : 설계를 재사용하기 어려움
4. 점착성(Viscosity): 제대로 동작하기 어려움
5. 불필요한 복잡성(Needless Complexity) : 과도한 설계
6. 불필요한 반속(Needless Repetition) : 마우스 남용
7. 불투명성(Opactity) : 혼란스러운 표현



### 원칙

객체 지향 설계의 원칙

1. SRP(Single Responsiblity Principle): 단일 책임 원칙
2. OCP(Open-Close Principle): 개방 폐쇄 원칙
3. LSP(Liskov Substitution Principle): 리스코프 치환 원칙
4. DIP(Dependency Inversion Principle):  의존 관계 역적 원칙
5. ISP(Interface Segregatioin Principle): 인터페이스 분리 원칙



## 7.애자일 설계란 무엇인가?

### 설계의 악취: 부패하고 있는 소프트웨어의 냄새

문제를 알리는 몇가지와 그  이유

1. 경직성: 변경을 하려면 다른 부분까지 변경되어야 함
2. 취약성: 변경을 할면 아무 관계 없는 부분이 망가진다.
3. 부동성: 다른 시스템에서 재사용 할수 있는 컴포넌트로 구분하기 어렵다.
4. 점착성: 옳은 동작을 하는 것이 잘못된 동작을 하는 것보다 더 어렵다.
5. 불필요한 복잡성: 효용이 전혀 없는 기반구조가 설계에 포함되어 있다.
6. 불필요한 반복: 단일 추상 개념으로 통합할수 있는 구조가 있다.
7. 불투명성: 읽고 이해가 어렵다. 의도를 모른다.



### 무엇이 소프트웨어의 부패를 촉진하는가?

애자일이 아닌 환경에서는 예상 외 요구사항때문에 설계가 퇴화한다.

### 애자일 팀은 소프트웨어가 부패하도록 내버려 두지 않는다.

시스템의 설계를 명로하고 단순하게 유지하고 많은 단위 테스트와 인수 테스트로 뒷바침한다.

이 반복이 적합한 설계를 가진 시스템을 이끌어 낸다.



### COPY  프로그램

초기설계 : 설계를 그려 차트를 따고 코드로 옮긴다. 확인하고 중간 중간 문제에 대응한다.

요구사항 변경 : 변경된 추가 요구사항을 반영하려 한다. 문제가 생길수 있음에도 불구하고 하게 된다.

한 치를 주니 :  또 다른 설계와 요구사항으로 인해 설계가 깨진다고 해보지만 변경하라고 지시 받고 프로그램이 비틀거리는 걸 느낀다.

변활르 예상하라 : 위에서 말한 악취를 풍기기 시작한다.

위 상황은 애자일 방식이 아닐 경우다.



**애자일 버전**

새 요구 사항을 만족시키기 위해 땜질 대신 설계를 개선해 탄력적으로 만든다.( 개방폐쇄 원칙을 따라)

설계를 시작할 때 가장 간단하게 작성해 요구사항이 변경 된 다음에 탄력적이 되도록 설계를 바꾼다.



### 애자일 개발자는 해야 할 일을 어떻게 알았는가?

애자일 개발자는 반경에 대응하기 위해 추상 클래스를 만들었다.

이는 객체 지향 설계의 기본 주의를 따랐기 때문이다.

1. 애자일 실천 방법을 따라 문제를 찾는다.
2. 설계 원칙을 적용해 문제를 진단한다.
3. 적절한 디자인 패턴을 적용한다.



### 가능한 좋은 상태로 설계유지하기

설계는 명료한 상태로 유지되어야 한다.그리고 설계의 가장 중요한 표현인 소스 역시 명료하게 유지해야 한다.



### 결론

애자일 설계는 과정이지 결과가 아니다. 원칙 패턴, 소프트웨어 구조와 가독성 향상을 위한 방식의 연속 적용이다.

설계를 간단 하고 명료하고 표현적으로 유지하려는 노력이다.



## 8. 단일책임원칙(SRP)

단일책임원칙(SRP: Single-Responsibility Principle) = 응집도(conhension) 라고 부르기도 하지만 이번에는 모듈이나 클래스의 변경을 야기하는 응집력에 대한 언급



### 단일 책임 원칙(SRP)

책임을 별개의 클래스로 분리하는 건 중요하다. 그것이 각 책임이 변경의 축이기 때문이다.

한 책임에 대한 변경은 다른 책임 클래스의 능력을 떨어뜨리거나 저하 시킬수도 있다.



### 책임이란 무엇인가?

SRP의 맥락에서는 ,책임을 변경을 위한 정의로 생각한다.

하지만 애플리케이션이 서로 다른 시간에 두가지 책임의 변경을 유발하는 방식으로 바뀌지 않는 다면 이들을 분리할 필요는 없다. 이런경우 오히려 불피룡한 복잡성이라는 악취를 풍기게 할 것이다.



### 결합된 책임 분리하기

#### 영속성

어울리지 않는 책임끼리는 묶지 않아야 한다.

영속성과 업무 규칙같은 것들이 분리가 되게 하여야 하고 경직성과 취약성의 악취가 심해진 경우는 빠르게 리팩토링 해야 한다.



### 결론

SRP는 간단하면서 적용하기 어렵다. 책임을 결합하는 것을 우리는 자연스럽게 하고 있따. 이런 책임을 찾고 하나씩 분리하는 것이 실제 설계에서 하는 일의 대부분이다.



## 9. 개방폐쇄원칙(OCP)



### 개방폐쇄 원칙(OCP)

소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.



### 상세 설명

1. 확장에 대해 열려 있다.
   - 모듈의 행위가 확장될 수 있음을 의미한다. 즉, 모듈이 하는 일을 변경할 수 있다.
2. 수정에 대해 닫혀 있다.
   - 어떤 모듈의 행위를 확장하는 것이 소스나 바이너리 코드 변경을 초래하지 않는다.

- 뭔가 상반된거 같다.계속 일어보자.



### 해결책은 추상화다.

모듈은 추상화를 조작할 수 있다.

그 모듈의 행위는 취상화의 새 파생클래스들을 만듦으로 써 확장이 가능하다.

클라이언트는 어떤 일이 처리되어야 할 때 제공하는 추상 인터페이스의 형식으로 그 일을 설명할 수 있다.

추상클래스 이름짓기: 자신을 구현하는 클래스 보다 클라이언트에 더 밀접하게 관련되어 있기 떄문에 이름 지을때 고려해야 한다.

개방 폐쇄 원칙을 따르는 흔한 패턴 : 스트래터지 패턴, 템플릿 메소드 패턴



### OCP 위반

코드 간략 설명: drawAllShapes함수가 포인터 배열을 따라가면서, 형태 코드를 검사하고 적절한 함수를 호출한다.

shape.h

Circle.h

square.h

drawllShapes.cc

```java

void DrawAllShapes(ShapePointer list[], int n) {
	int i;
	for (i = 0; i < n; i++) {
		struct Shape* s = lists[i];
		switch (s -> itsType) {
			case square:
				DrawSquare((struct Square*) s);
				break;
			case circle:
				DrawCircle((struct Circle*) s);
				break;
		}
	}
}
```



- 새롭게 그려야 할 도형에 대해 함수를 수정해야 한다.

- shape에 의존하는 모든 모듈도 다시 컴파일 해야 한다.



### OCP 따르기

추상클래스를 작성해서  단일 추상 메소드를 가지고  circle square를 shape의파생 클래스로 한다.

경직성이 없다. 수정할 소스 모듈도 없고 바이너리 모듈도 없다.

부동성이 없다. = 재사용 가능



### 그래, 거짓말 했다.

예시에서 circle은 모두 square앞에 그려지도록 결정했따면 변경에 대해 닫혀 있찌 않고 circle 검색 후 square에 대해 재검색해야한다.



### 예상과 '자연스러운' 구조

모든 상황에서 자연스러운 모델은 없기에 모든것을 하고 변경이 일어날때까지 기다려보자. 



### '올가미' 놓기

우리가 자신을 보호하는  방법

첫 번째 총알은 맞고, 다른총알을 확실히 보호하자

첫번째 총알에서 가능한 많은 정보를 알아내자.



### 결론

ocp는 객체지향 설계의 심장이라 할수 있따.

어설픈 추상화를 피하는 일은 추상화 자체만큼이나 중요한다.


## 10. 리스코프 치환 원칙(LSP)

LSP : Liskov Substitution Principle

 ocp(개방폐쇄원칙)이 내포하는 일차적 메커니즘은 추상화와 다형성이다.

다형성을 지원하는 주요 메커니즘 중 하나가 상속이다.

이런 상속의 특별한 사용을 규율하느 설계법칙은  무엇일까?

이런것들을 LSP를 다루는 원칙이다.



LSP를 한줄로 설명하면 다음과 같다.

서브타입은 그것의 기반 타입으로 치환 가능해야 한다.



이 원칙의 중요성은 이것을 위반한 결과를 보면 분명해진다.



### LSP위반의 간단한 예

한 함수가 클래스의 모든 파생 클래스를 알아야 하고, 또한 새로운 파생 클래스가 생길 때 마다 변경 되어야 한다. = 옳지 않은 설계

한 클래스가  다른 클래스를 대체할수 없는 것은 LSP위반이며 이위반은  사용되는 객체의 OCP 위반을 유발한다.

```c#
class rectagle{
  public :
    void setwidth(double w){
	    itsWidth = w;
    }
    void setheight(double h){
  	  itsHeight = h;
    }
    double getwidth() const {
       return itsWidth;
    }
    double getheight() const {
    return itsHeight();
    }
private :
	Point itsTopLeft;
	double itsWidth;
	double itsHeight;
};
```

위 코드를 정사각형으로도 변경해 달라고 요구해 왔다.

일반적으로 모든 정사각형은 직사각형이다. 그러므로 Square 클래스가 Rectangle클래스에서 파생된다고 보는것이 합리적이다.

하지만 이것은 뭔가 잘못되었다.

스퀘어 클래스는 멤버 변수를 필요로 하지 않는다.(굉장히 낭비적, 소모적)

이문제는 사실 설계에 결점이라고 볼수도 있지만 굉장히 미묘하다.



### 유효성은 본래 갖추어진 것이 아니다.

 LSP는 모델만 별개로 보고, 그 모델의 유효성을 충분히 검증할 수 없다. 

모델의 유효성은 오직 그 고객의 관점에서만 표현될 수 있다.

모든게 완벽한 프로그램을 설계하려고 하면 불필요한 복잡성으로 악취가 날수도 있다. 그러므로 다른원칙처럼 취약성의 악취를 맡을 때까지 명백한 LSP위반을 제외한 나머지의 처리는 연기하는 게 최선이다.



### 계약에 의한 설계

파생된 객체는 사용자가 기반 크랠스가 요구하는 것보다 더 강한 사전조건을 따를 것이라고 기대할 수 없다.

파생된 객체는 기반클래스가 받아들일 수 있는 것은 모두 받아들여야 한다.

기반 클래스의 사용자가 파생 클래스의 출력에 의해 혼란스러워해서는 안된다.



### 단위 테스트에서의 계약사항 구체화하기

계약은 또한 단위테스를 작성함으로써 구체화 될 수 있다.



### 휴리스틱과 규정

LSP 위반의 단서를 보여주는 간단한 휴리스틱이 있다.

기반 클래스에서 어떻게든 가능성을 제거한 파생 클래스에 대해 적용해야 한다.

기반 클래스보다 덜한 동작을 하는 파생 클래스는 보통 그 기반 클래스와 치환이 불가능하므로 LSP를 위반



### 파생 클래스에서의 예외 발생

기반 클래스가 발생시키지 않는 예외를 파생 클래스의 메소드에 추가하는 것이다.

예외에 기대하지 않는다면 파생 클래스의 메소드에 예외를 추가했을 떄 치환 가능하지 않다.



### 결론



LSP 는 OCP를 가능하게 해주는 요인중 하나다.이것은 모듈을 수정 없이도 확장 가능하게 만드는 서브탕비의 치환 가능성을 말한다.

기반타입의 계약사항은 명시적으로 강재되지 않은 경우, 코드에서 분명하고 뚜렷해야 한다.

IS-A라는 용어는 서브타입의 정의가 되기에는 지나치게 넓다. 서브타입의 진실된 정의는 치환 가능성이다.



## 11. 의존관계 역전원칙(DIP)



a. 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다. 둘 모두 추상화에 의존해야 한다.

b. 추상화는 구체적인 사항에 의존해서는 안 되나. 구체적인사항은 추상화에 의존해야 한다.



잘 설계된 객체 지향 프로그램의 의존성 구조는 전통적인 절차적 방법에 의해 일반적으로 만들어진 의존성 구조가 '역전'된 것이다.



### 레이어 나누기

의존성은 이행적이다.

미숙한 레이어

```
policy layer -> mechanismlayer -> utility layer
```



- 조금 더 적절한 모델

각 상위 수준레이어는 추상 인터페이스를 선언해서 의존성을 줄인다.



### 소유권의 역전

우리는 대개 유틸리티 라이브러리가 고유 인터페이스를 소유했다고 생각하지만 DIP가 적용된 경우 클라이언트가 추상 인터페이스를 소유하는 경향이 있고 이들의 서버가 그것에서 파생해 나온다는 것을 알게된다.

하위 수준의 모듈은 상위 수준의 모듈 안에 선언되어 호출되는 인터페이스의 구현을 제공한다.



### 추상화에 의존하자

DIP의 간단한 접근 방식은 구체 클래스에 의존해서는 안되고 어떤 프로그램의 모든 관계는 어떤 추상 클래스나 인터페이스에서 맺어져야 한다.

- 어떤 변수도 구체 클래스에 대한 포인터나 참조값을 가져선 안 된다.
- 어떤 클래스에서 파생되어서는 안 된다.
- 어떤 메서드도 그 기반 클래스에서 구현된 메소드를 오버라이드해서는 안 된다.



완벽한 해결책은 아니지만 추상 클래스의 변경은 클라이언트에 영향을 주지 않는다.



### 결론

좋은 객체 지향 설계의 증명이 의존성의 역전이다. 프로그램의 의존성이 역전되어 있다면 이것은 객체 지향 설계이며, 의존성이 역전되어 있지 않다면 절차적 설계이다.

의존성 역전의 원칙은 객체 지향 기술에서 당연하게 있는 메커니즘이다. 재사용을 위한 적절한 응용이 필수적이다. 이 원칙은 변경에 탄력적인 코드를 작성하는 데 있어 결정적으로 중요하다.



## 12. 인터페이스 분리(ISP)

ISP는 응집력이 없는 인터페이스를 필요하는 객체가 있따는 것을 인정하지만 클라이언트는 그것을 하나로 단일클래스로 생각해서는 안됨을 시사한다. 오히려, 클라이언트는 응집력이 있는 인터페이스를 가지는 추상 기밪 클래스에 대해 알고 있어야 한다.



### 인터페이스 분리 원칙

클라이언트가 자신이 사용하지 않는 메소드에 의존하도록 강제되어서는 안 된다.

클라이언트가 자신이 사용하지 않는 메소드에 의존하도록 강제될 때,  클라이언트는 변경에 취약하다. 어떤 클라이언트가 자신은 사용하지 않지만 다른 클라이언트가 사용하는 메소드를 포함하는 클래스에 의존할 떄, 그 클라이언트는 다른 클라이언트가 그 클래스에 가하는 변경에 영향을 받게 된다.



### 클래스 인터페이스와 객체 인터페이스

객체의 분리

객체의 클라이언트는 그 객체의 인터페이스를 통해 접근할 필요가 없다. 위임이나 객체의 기반 클래스를 통해 접근할 수 있다.



### 결론

비대한 클래스는 클라이언트들 간에 기이하고 해가 되는 결합도를 유발한다.한 클라이언트가 이 비대한 클래스에 변경을 가하면, 모든 나머지 클래스가 영향을 받게 된다.그러므로 클라이언트는 실제 호출하는 메소드에만 의존해야 하는데 , 클래스의 인터페이스를 고유의 인터페이스로 분류해야 한다.

클라이언트 고유의 각 인터페이스는 자신의 특정 클라이언트나 클라이언트 그룹 호출함수만 선언한다. 그러면 비대한 클래스가 모든 클라이언트 고유의 인터페이스를 상속하고 그것을 구현할 수 있게 된다.



**인터페이스를 분리하면!**

**호출하지 않는 메소드에 대한 클라이언트의 의존성을 끊고, 클라이언트가 서로에 대해 독립적이 되게 만들 수 있다,**

ps. 소단락 '클라이언트가 인터페이스에 미치는 반대 작용'~'복합체와 단일체'의 경우 결론에 정리가 잘되 있어 작성하지 않았지만 예시 코드가 좋아 한번 책에서 보기를 추천. 코드를 다적기에는 정리느낌을 벗어난거 같










