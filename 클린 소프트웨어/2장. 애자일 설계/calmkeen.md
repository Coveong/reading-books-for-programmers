# 2.애자일 설계

## 7. 애자일 설계란 무엇인가

### 잘못된 설계의 증상

1. 경직성(Rigidity) : 설계를 변경하기 어려움
2. 취약성(Fragility) : 설계가 망가지기 쉬움
3. 부동성(Immobility) : 설계를 재사용하기 어려움
4. 점착성(Viscosity): 제대로 동작하기 어려움
5. 불필요한 복잡성(Needless Complexity) : 과도한 설계
6. 불필요한 반속(Needless Repetition) : 마우스 남용
7. 불투명성(Opactity) : 혼란스러운 표현



### 원칙

객체 지향 설계의 원칙

1. SRP(Single Responsiblity Principle): 단일 책임 원칙
2. OCP(Open-Close Principle): 개방 폐쇄 원칙
3. LSP(Liskov Substitution Principle): 리스코프 치환 원칙
4. DIP(Dependency Inversion Principle):  의존 관계 역적 원칙
5. ISP(Interface Segregatioin Principle): 인터페이스 분리 원칙



## 7.애자일 설계란 무엇인가?

### 설계의 악취: 부패하고 있는 소프트웨어의 냄새

문제를 알리는 몇가지와 그  이유

1. 경직성: 변경을 하려면 다른 부분까지 변경되어야 함
2. 취약성: 변경을 할면 아무 관계 없는 부분이 망가진다.
3. 부동성: 다른 시스템에서 재사용 할수 있는 컴포넌트로 구분하기 어렵다.
4. 점착성: 옳은 동작을 하는 것이 잘못된 동작을 하는 것보다 더 어렵다.
5. 불필요한 복잡성: 효용이 전혀 없는 기반구조가 설계에 포함되어 있다.
6. 불필요한 반복: 단일 추상 개념으로 통합할수 있는 구조가 있다.
7. 불투명성: 읽고 이해가 어렵다. 의도를 모른다.



### 무엇이 소프트웨어의 부패를 촉진하는가?

애자일이 아닌 환경에서는 예상 외 요구사항때문에 설계가 퇴화한다.

### 애자일 팀은 소프트웨어가 부패하도록 내버려 두지 않는다.

시스템의 설계를 명로하고 단순하게 유지하고 많은 단위 테스트와 인수 테스트로 뒷바침한다.

이 반복이 적합한 설계를 가진 시스템을 이끌어 낸다.



### COPY  프로그램

초기설계 : 설계를 그려 차트를 따고 코드로 옮긴다. 확인하고 중간 중간 문제에 대응한다.

요구사항 변경 : 변경된 추가 요구사항을 반영하려 한다. 문제가 생길수 있음에도 불구하고 하게 된다.

한 치를 주니 :  또 다른 설계와 요구사항으로 인해 설계가 깨진다고 해보지만 변경하라고 지시 받고 프로그램이 비틀거리는 걸 느낀다.

변활르 예상하라 : 위에서 말한 악취를 풍기기 시작한다.

위 상황은 애자일 방식이 아닐 경우다.



**애자일 버전**

새 요구 사항을 만족시키기 위해 땜질 대신 설계를 개선해 탄력적으로 만든다.( 개방폐쇄 원칙을 따라)

설계를 시작할 때 가장 간단하게 작성해 요구사항이 변경 된 다음에 탄력적이 되도록 설계를 바꾼다.



### 애자일 개발자는 해야 할 일을 어떻게 알았는가?

애자일 개발자는 반경에 대응하기 위해 추상 클래스를 만들었다.

이는 객체 지향 설계의 기본 주의를 따랐기 때문이다.

1. 애자일 실천 방법을 따라 문제를 찾는다.
2. 설계 원칙을 적용해 문제를 진단한다.
3. 적절한 디자인 패턴을 적용한다.



### 가능한 좋은 상태로 설계유지하기

설계는 명료한 상태로 유지되어야 한다.그리고 설계의 가장 중요한 표현인 소스 역시 명료하게 유지해야 한다.



### 결론

애자일 설계는 과정이지 결과가 아니다. 원칙 패턴, 소프트웨어 구조와 가독성 향상을 위한 방식의 연속 적용이다.

설계를 간단 하고 명료하고 표현적으로 유지하려는 노력이다.



## 8. 단일책임원칙(SRP)

단일책임원칙(SRP: Single-Responsibility Principle) = 응집도(conhension) 라고 부르기도 하지만 이번에는 모듈이나 클래스의 변경을 야기하는 응집력에 대한 언급



### 단일 책임 원칙(SRP)

책임을 별개의 클래스로 분리하는 건 중요하다. 그것이 각 책임이 변경의 축이기 때문이다.

한 책임에 대한 변경은 다른 책임 클래스의 능력을 떨어뜨리거나 저하 시킬수도 있다.



### 책임이란 무엇인가?

SRP의 맥락에서는 ,책임을 변경을 위한 정의로 생각한다.

하지만 애플리케이션이 서로 다른 시간에 두가지 책임의 변경을 유발하는 방식으로 바뀌지 않는 다면 이들을 분리할 필요는 없다. 이런경우 오히려 불피룡한 복잡성이라는 악취를 풍기게 할 것이다.



### 결합된 책임 분리하기

#### 영속성

어울리지 않는 책임끼리는 묶지 않아야 한다.

영속성과 업무 규칙같은 것들이 분리가 되게 하여야 하고 경직성과 취약성의 악취가 심해진 경우는 빠르게 리팩토링 해야 한다.



### 결론

SRP는 간단하면서 적용하기 어렵다. 책임을 결합하는 것을 우리는 자연스럽게 하고 있따. 이런 책임을 찾고 하나씩 분리하는 것이 실제 설계에서 하는 일의 대부분이다.



## 9. 개방폐쇄원칙(OCP)



### 개방폐쇄 원칙(OCP)

소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.



### 상세 설명

1. 확장에 대해 열려 있다.
   - 모듈의 행위가 확장될 수 있음을 의미한다. 즉, 모듈이 하는 일을 변경할 수 있다.
2. 수정에 대해 닫혀 있다.
   - 어떤 모듈의 행위를 확장하는 것이 소스나 바이너리 코드 변경을 초래하지 않는다.

- 뭔가 상반된거 같다.계속 일어보자.



### 해결책은 추상화다.

모듈은 추상화를 조작할 수 있다.

그 모듈의 행위는 취상화의 새 파생클래스들을 만듦으로 써 확장이 가능하다.

클라이언트는 어떤 일이 처리되어야 할 때 제공하는 추상 인터페이스의 형식으로 그 일을 설명할 수 있다.

추상클래스 이름짓기: 자신을 구현하는 클래스 보다 클라이언트에 더 밀접하게 관련되어 있기 떄문에 이름 지을때 고려해야 한다.

개방 폐쇄 원칙을 따르는 흔한 패턴 : 스트래터지 패턴, 템플릿 메소드 패턴



### OCP 위반

코드 간략 설명: drawAllShapes함수가 포인터 배열을 따라가면서, 형태 코드를 검사하고 적절한 함수를 호출한다.

shape.h

Circle.h

square.h

drawllShapes.cc

```java

void DrawAllShapes(ShapePointer list[], int n) {
	int i;
	for (i = 0; i < n; i++) {
		struct Shape* s = lists[i];
		switch (s -> itsType) {
			case square:
				DrawSquare((struct Square*) s);
				break;
			case circle:
				DrawCircle((struct Circle*) s);
				break;
		}
	}
}
```



- 새롭게 그려야 할 도형에 대해 함수를 수정해야 한다.

- shape에 의존하는 모든 모듈도 다시 컴파일 해야 한다.



### OCP 따르기

추상클래스를 작성해서  단일 추상 메소드를 가지고  circle square를 shape의파생 클래스로 한다.

경직성이 없다. 수정할 소스 모듈도 없고 바이너리 모듈도 없다.

부동성이 없다. = 재사용 가능



### 그래, 거짓말 했다.

예시에서 circle은 모두 square앞에 그려지도록 결정했따면 변경에 대해 닫혀 있찌 않고 circle 검색 후 square에 대해 재검색해야한다.



### 예상과 '자연스러운' 구조

모든 상황에서 자연스러운 모델은 없기에 모든것을 하고 변경이 일어날때까지 기다려보자. 



### '올가미' 놓기

우리가 자신을 보호하는  방법

첫 번째 총알은 맞고, 다른총알을 확실히 보호하자

첫번째 총알에서 가능한 많은 정보를 알아내자.



### 결론

ocp는 객체지향 설계의 심장이라 할수 있따.

어설픈 추상화를 피하는 일은 추상화 자체만큼이나 중요한다.









