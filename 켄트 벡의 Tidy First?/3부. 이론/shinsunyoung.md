# 3. 이론

# 22. 요소들을 유익하게 관계 맺는 일

- 소프트웨어 설계의 의미
    - **요소**들을 **유익**하게 **관계 맺는** 일
    - 요소
        - 요소에는 경계가 있음 (token → expression → statement → function → object/module → system). 그래서 어디서 시작하고 끝나는지 알 수 있음
        - 하위 요소를 포함힘
    - 관계 맺기
        - 호출, 발행, 대기, 참조 같은 것
    - 유익하게
        - 중간 요소들이 관계 맺는데 도움을 줌
        - 예를 들어 함수 A는 함수 B가 계산의 복잡한 부분을 덜어가는 것
    - 따라서 설계자는 요소들을 유익하게 관계 맺는 일을 해야 한다.
        - 요소를 만들고 삭제한다.
        - 관계를 만들고 삭제한다.
        - 관계의 이점을 높인다.
- 시스템의 구조
    - 요소 계층 구조
    - 요소 사이의 관계
    - 이러한 관계가 만들어내는 이점

# 23. 구조와 동작

- 시스템의 동작을 규정하는 방식
    - 입출력 쌍
    - 불변 조건
- 동작은 가치를 만든다 (일일이 손으로 계산할 필요 없어짐)
- 더 나은 기계에 도달하는 방법
    - 선택 가능성
    - 특정 방식으로 동작하는 시스템이 있다는 것만으로도, 시스템이 어떻게 동작해야 하는지에 대한 욕구가 달라짐
    - 굳이 동작을 바꿀 필요 없음
- 옵션은 소프트웨어로 만들어내는 경제적인 마법이며 환경의 변동성이 클수록 가치가 커짐
- 선택 가능성을 앗아가는 요소
    - 핵심 직원이 퇴사함
    - 고객과 거리가 멀어짐
    - **변경에 따른 비용 ← 이것은 코드 정리로 대응할 수 있음**
- 선택가능성을 위해 구조에 투자해야 함
- 구조 변경, 동작 변경은 모두 가치를 만들어내지만, 근본적으로 다르다. (**가역성**)

# 24. 경제 이론: 시간 가치와 선택 가능성

- 돈의 본성
    - 오늘의 1달러가 내일의 1달러보다 가치있기 때문에 버는 것은 빨리, 쓰는 것은 뒤로 미루자
    - 혼란스러운 상황에서는 물건에 대한 옵션이 물건보다 낫기 때문에 불확실성에 맞서는 옵션을 만들어라

# 25. 오늘의 1달러보다 내일의 1달러가 크다

- 돈의 시간 가치는 코드 정리를 먼저 하기보다는 나중에 하기를 권장

# 26. 옵션

- “다음에 어떤 동작을 구현할 수 있을까?” 라는 질문은 자체로도 가치가 있다.
- 위 잘문은 후보 목록이 많을수록 더 가치가 있다.
- 어떤 항목이 가장 가치 있을지는 구현할 수 없는 옵션을 열어두는 한 신경 쓸 필요 없음
- 가치에 대한 예측이 불확실할수록 바로 구현하는 것보다 옵션이 지닌 가치가 더 커진다
- 소프트웨어 설계를 옵션의 관점에서 생각
    - 잠재적인 동작 변경의 가치가 변동성이 클수록 더 좋다
    - 개발 기간이 길면 길수록 더 좋다
    - 앞으로 더 저렴하게 개발할 수 잇으면 좋지만, 극히 일부분
    - 더 작은 설계 작업으로 옵션을 만들 수 있으면 더 좋다

# 27. 옵션과 현금흐름 비교

- 현금흐름할인: 코드 정리를 먼저 하지 마라
- 옵션: 옵션이 생길 일이 명백하다면, 코드 정리를 선행하라
- 코드 정리부터 해야 할 때
    - 비용(코드 정리) + 비용(코드 정리 후 동작 변경) < 비용(바로 동작 변경)
- 이럴때는?
    - 비용(코드 정리) + 비용(코드 정리 후 동작 변경) > 비용(바로 동작 변경)
    - 개인이 판단해서 정해야되는 영역

# 28. 되돌릴 수 있는 구조 변경

- 되돌릴 수 없는 결정은 면밀히 검토하고 두 번, 세 번 확인해야 하는 가치 있는 일
- 그런게 아니면 실수를 피하는 것이 신경 쓸 정도로 큰 일이 아니기 때문에, 지나치게 노력할 필요가 없다.

# 29. 결합도

- 결합도 분석은 가능한 한 다양한 방식으로 표현하고 시각화
- 결합도의 성질
    - 1:N이라서 어떤 변경이 일어나면, 다른 요소와 결합이 일어남
    - 변경이 다른 요소로 파급되고, 또 다른 요소의 변경을 촉발할 수도 있음
- 결합도는 소프트웨어 비용을 좌우함

# 30. 콘스탄틴의 등가성

- 소프트웨어의 비용은 그것을 변경하는데 드는 비용과 거의 같음
- 멱법칙 분포의 특징은 소스의 큰 이상값을 발생 시키는 일이 매우 중요함. 그것들을 합치면 훨씬 더 많은 정상 사건보다 더 큰 영향을 미침. 즉, 가장 큰 다섯 폭풍이 작은 폭풍 만 개보다 더 큰 피해를 입힘
    - 가장 비용이 많이 드는 하나의 변경이 나머지 변경을 모두 합친 것보다 훨씬 더 많은 비용이 듬
- 소프트웨어 비용은 결합도와 같음
- 콘스탄틴의 등식
    - 비용(소프트웨어) ~= 비용(전체 변경) ~= 비용(큰 변경틀) ~= 비용(결합도)
    - 비용(소프트웨어) ~= 비용(결합도)
- 따라서 소프트웨어 비용을 줄이려면 결합도를 줄여야 함

# 31. 결합도와 결합도 제거

- 한 종류의 코드 변경에 대한 결합도를 줄일수록 다른 종류의 코드 변경에 대한 결합도가 켜짐
- 모든 결합을 색출하듯 없애려고 애쓰지 말자
- 절충점을 찾아 해결하기

# 32. 응집도

- 결합된 요소들은 둘을 포함하는 같은 요소의 하위 요소
- 10개의 함수가 포함된 모듈이 있고, 3개와 결합되어 있을때 7개는 어디로 갈까?
    - 결합된 요소를 자체 하위 요소로 묶기
    - 결합되지 않은 요소를 가져와 다른 곳에 배치

# 33. 결론

- 코드 정리가 먼저인가?
    - 비용
    - 수익
    - 결합도: 변경에 필요한 요소의 수가 줄어드나?
    - 응집도: 변경을 더 작고 좁은 범위로 집중시켜 적은 수의 요소만 다룰 수 있는가?
    - 이것들을 생각해보고 정해라