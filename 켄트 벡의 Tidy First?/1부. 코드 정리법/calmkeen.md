## part 1. 코드 정리법

**CHAPTER 01. 보호 구문**

```jsx
if (condition) {} 
or
if (condition) {
	if (조건 부정코드) {} }
	
중첩은 헷갈립니다. 위 코드 대신
if (condition) {}
if (조건부정코드) {}
이와 같이 쓰는게 더 읽기 쉽습니다.
```

보호 구문이 있는 코드라면 전제조건이 명시적으로 드러날 때 분석하기가 쉽습니다.

**chapter .02: 안 쓰는 코드**

**지워버려라. 그게 다입니다.**

주석으로 비활성화를 하거나 나중의 필요할 경우를 생각하지마세요.

이는 형상관리 도구로 관리하는것이다.

**각  정리 과정에서는 코드를 ‘조금만’ 삭제하라.**

**chapter .03: 대칭으로 맞추기**

코드를 작성할때 여러가지 방식이 있다 (한줄로 최대한 줄여 쓰는 사람, 보기 좋게 쓰는 사람, 정직하게 다 작성하는 사람, 내장함수(클로저,람다)를 쓰는 사람)

한가지 방식을 선택해서 코드를 작성하라.

이는 패턴의 혼란스러움을 줄이고, 한가지 코드 방식은 익숙함과 루틴을 찾기 쉽게 만듭니다.

**chapter .04: 새로운 인터페이스로 기존 루틴 부르기**

루틴을 호출해야 하는데 기존 인터페이스 때문에 어렵거나, 복잡하거나, 혼란스러울떄.

→ 인터페이스를 새롭게 구현해서 호출해라. → 새로만든 인터페이스를 기존 인터페이스를 호출하는 방식으로 만들수 도 있다.

이러하면 동작 변경이 쉬워지고 이 인터페이스가 작은 단위의 중추 역할을 해줄 수 있습니다.

통로 인터페이스를 만들때 비슷한 느낌이 드는 케이스

- 거꾸로 코딩하기: 루틴의 마지막 줄부터 시작해 보세요.
- 테스트 우선 코딩: 테스트 부터 작성하여 통과 요건을 정합니다.
- 도우미 설계: 나에게 특정 업무를 주는 루틴, 객체, 서비스가 있다면 나머지가 쉬워집니다.

**chapter .05:읽는 순서**

코드를 읽기 쉬운 순서로 다시 정렬하면 그 순서대로 코드를 만날 수 있습니다.

완벽한 순서는 없습니다. 본인의 경험에 맞춰 판단해라.

**chapter .06: 응집도를 높이는 배치**

이미 결합도가 높은 코드를 만났을때.

→ 코드의 순서를 바꿔서 변경할 요소들을 가까이 두면 됩니다.

→ 결합도가 높은 코드를 제거 할수 있으면 그게 가장 좋지만 현실적으로는 쉽지 않습니다.

```jsx
결합도제거 비용 + 변경 비용 < 결합도에 따른 비용 + 변경 비용
```

주로

- 팀이 변경하고 있다면 방향이 달라 갈등으로 번질수 있다.
- 시간적 여유
- 너무 복잡한 결합도

이러한 경우 변경에 매달리지 말고 응집도를 높이는 순서로 정리를 해라.

이러한 경우를 수행하다 결합도가 줄어 들어  코드가 명확해 질 수 도 있다.

**Chapter .07: 선언과 초기화를 함께 옮기기**

변수 선언과 초기화는 가까이 두자.

코드를 이해하기 어느쪽이 편할까를 생각해자.

**But!**

변수와 변수사이에 데이터 종속이 있을수 있음을 존중하자.

데이터 종속의 순서도 유지하면서 작업하자.

데이터 종속을 수작업으로 분석하면 실수를 하고, 동작에 영향 혹은 변경을 미칠 수 있습니다.

작은 단계로 작업하세요. 최대한 안전한 단위까지 줄여서 작업을 시작하자!

**chapter .08: 설명하는 변수**

긴 표현식을 발견하고 이해했다면 의도가 드러내도록 변수화 해보자.

```jsx
return new Point(
something long function
something more longer function
)
이러한 표현식을 이해했다면 분리작업을 실해해 줍니다.
x = something long function
y = something more longer function
return new Point(x,y)
```

**Chapter .09: 설명하는 상수**

“상징적인 상수를만드세요. 리터럴 상수로 사용된 곳은 상징적인 상수로 바꿉니다.”

```jsx
if response.code = 404
  ...Code...
```

```jsx
PAGE_NOT_FOUND := 404
if response.code = PAGE_NOT_FOUND
	... Code ...
```

```jsx
ONE = 1
... ONE ... # 하나가 필요할 떄 어디든 등장
```

이런거 하지 말라십니다..

**Chapter .10 명시적인 매개변수**

명시적으로 전될다지 않는 코드를 발견했을때..

→ 루틴을 나누어 앞에서 매개변수를 채우고, 뒤에 명시적으로 전달합니다.

MAP에서는 주로 매개변수 블록으로 전달됩니다.

→ 코드를 읽기 어렵게 합니다.

```jsx
parmas = {a:1, b:2}
foo(params)

function foo(params)
	...params.a...    ...params.b...
```

foo를 명시적으로 나누는것이 좋다.

```jsx
function foo(params)
	foo_body(params.a, params.b)
	
	function foo_body(a,b)
	
```

**CHAPTER .11: 비슷한 코드끼리**

코드에서 구분이 될때 빈 줄을 넣어 분리합니다.

소프웨어 설계는 유연성을 확보하지만, 그렇지 못한 경우는 자칫 변화 자체를 망각하고 스프트웨어 설계의 소용돌이에 빠질 수 있습니다.

**CHAPTER .12: 도우미 추출**

목적이 분명하고 나머지 코드와는 상호작용이 적은 코드 블록을 만날때가 있는데 이를 추려내어 도우미로 이름을 붙입니다. 이떄 이름은 동작 방식이 아닌 목적에 따라 짓습니다.

도구를 적극 사용하세요!(21세기 기때문에)

**CHAPTER .13: 하나의 더미**

코드를 만드는데 가장 큰 비용이 들어가는건 작성이 아닌 읽고 이해하는 비용입니다.

코드정리를 선행하면 작은 조각 단위로 결합을 제거하는 길을 통해 응집도를 높일수 있습니다.

작은 코드 조각을 지향하는 목적은 한번에 조금씩 이해할수 있도록입니다.하지만 너무 과하면 방식을 알수 없게 합니다. 이때 코드를 모아서 이해하기 어려운 부분은 추출하면 도움됩니다.

- 길고 반복되는 인자
- 반복되는코드의 반복 조건문
- 도우미에 대한 부적절한  이름
- 공유되어 변경에 노출된 데이터 구조

**CHAPTER .14: 설명하는 주석**

코드분석중 로직이 이해된 순간 기록하라.

결합에 문제가 있는 코드를 발견하거나 복잡한 코드를 봤을 때 바로 해결할 수 없으면 주석으로 명시해두는 것이 도움될 수 있다.

**CHAPTER .15:  불필요한 주석 지우기**

코드로 이해가 가는 내용은 주석이 필요하지 않다.
