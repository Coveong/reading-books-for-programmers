# 들어가며
### 이 책에서 다루는 내용
- 지저분한 코드를 정리한 후 프로그램 연산을 변경하는 시점
- 지저분한 코드를 안전하고 효율적으로 정리하는 방법
- 지저분한 코드 정리를 멈추는 시점
- 코드 정리가 작동하는 이유

+) 소프트웨어 설계의 기본 이론인 결합도, 응집도, 현금흐름할인, 선택 가능성을 다룬다.

### 이 책을 다 읽고 이해할 수 있는 내용
- 시스템의 동작을 변경하는 일과 구조를 변경하는 일의 근본적인 차이점
- 각자가 스스로 코드를 변경하는 프로그래머로서 구조 변경과 동작 변경에 대한 투자를 병행하는 비법
- 소프트웨어 설계가 작동하는 방식과 이에 작용하는 힘에 대한 이론의 기본 사항
- 큰 변경을 작고 안전한 단계로 시작하는 방법

# 1부. 코드 정리법

코드 변경을 위해 지저분한 코드를 마주칠 때마다 적용할 수 있는 작은 설계 움직임을 모아둔 카탈로그 형식으로 서술된다.

## Chapter 1 보호 구문
중첩된 조건을 다음과 같이 작성하기보다는,
```kotlin
if (조건)
   if (다른 조건 부정)
       (코드)
```
아래와 같이 정리하여 코드의 세부 사항을 살펴보기 전 전제 조건을 드러내듯 작성해라.
```kotlin
if (조건 부정) return
if (다른 조건) return
(코드)
```
**항상** 그리고 **반드시** 작은 단계를 거쳐 코드를 정리하자

## Chapter 2 안 쓰는 코드
실행되지 않는 코드라면 그냥 지우자.

"지웠다가 나중에 필요한 경우 어떡하지?" -> VSC 도구가 해결해 줄 것이다.

## Chapter 3 대칭으로 맞추기
코드를 작성할 때 두 가지 이상의 패턴(기교)을 섞어 쓰지 말자.

때로는 공통성이 있는데도 세부 사항에 묻혀 드러나지 않는다. 비슷해 보이지만 같지 않은 루틴을 찾아낸다. 그리고 같은 부분들 속에 다른 부분이 끼어 있다면 분리한다.

## Chapter 4 새로운 인터페이스로 기존 루틴 부르기
**Pass-through-interface**을 활용하여 어떤 동작이 변경되었을 때 변경사항을 최소화한다.
> 기존 인터페이스를 호출하는 코드를 새 인터페이스를 호출하도록 모두 이전한 후에는 이전 인터페이스를 제거하고 새 인터페이스가 직접 루틴을 호출하도록 변경할 수 있습니다.

예시 참고: https://tidyfirst.substack.com/p/request-for-examples-pass-through/comments

## Chapter 5 읽는 순서
코드를 읽는 독자의 입장이 되어 읽기 좋은 순서로 정렬하자.

## Chapter 6 응집도를 높이는 배치
코드의 순서를 바꿔서 변경할 요소들을 가까이 둔다.
```
결합도 제거(decoupling) 비용 + 변경 비용 < 결합도(coupling)에 따른 비용 + 변경 비용
```
즉, 응집도를 개선하여 코드가 명확해지면 코드를 더 쉽게 변경할 수 있도록 만든다.

## Chapter 7 선언과 초기화를 함께 옮기기
변수 초기화는 해당 변수의 이름이 주는 의미를 더 강화한다.

이를테면 다음과 같은 상황을 지양하자:
```kotlin
var foo: Int
(foo를 사용하지 않는 100만줄의 코드)
foo = 123
```

## Chapter 8 설명하는 변수
시간에 따라 커지는 코드의 의미를 한 눈에 파악할 수 있도록, 표현식의 의도가 드러나도록 변수 이름을 만들어 할당해보자.
```kotlin
return Point(
  ...긴 표현식...
  ...다른 긴 표현식...
)
```
위를 아래와 같이 개선해본다.
```kotlin
val x = ...긴 표현식...
val y = ...다른 긴 표현식...
return Point(x, y)
```
> 여러분이 힘들게 파악한 내용을 다시 코드에 넣는 것이다.

## Chapter 9 설명하는 상수
> 상징적인 상수를 만드세요. 리터럴 상수로 사용된 곳은 상징적인 상수로 바꿉니다.
```kotlin
const val PAGE_NOT_FOUND = 404
if (response.code == PAGE_NOT_FOUND)
```

## Chapter 10 명시적인 매개변수
매개변수를 명시적으로 드러나게 만든 다음, 함수를 연쇄적으로 호출할 수 있게 하여 읽기와 테스트 분석을 쉽게 한다.

## Chapter 11 비슷한 코드끼리
서로 관련 있는 코드끼리 뭉쳐두고 공백을 활용하여 구분한다.

> 제대로 된 소프트웨어 설계는 유연성을 확보하지만 그렇지 못한 경우는 자칫 변화 자체를 망각하고 소프트웨어 설계의 소용돌이에 빠질 수 있습니다.

## Chapter 12 도우미 추출
루틴 속 코드 중에서 목적이 분명하고 나머지 코드와는 상호작용이 적은 블록을 만날 때가 있다.

이러한 코드 블록을 추려내고, 도우미(helper)로 추출한 뒤에 이름을 붙인다. 이때 도우미의 이름은 작동 방식이 아니라 목적에 따라 짓는다.

## Chapter 13 하나의 더미
> 코드를 작성할 때 가장 큰 비용이 들어가는 일은 코드 작성이 아니라 읽고 이해하는 데 드는 비용입니다.
지나치게 작은 조각으로 모아져있는 코드는 하나의 더미처럼 느껴질 때까지 모아 정리한다.

다음과 같은 증상을 찾아 정리한다.
- 길고 반복되는 인자 목록
- 반복되는 코드, 그 중에서도 반복되는 조건문
- 도우미에 대한 부적절한 이름
- 공유되어 변경에 노출된 데이터 구조

## Chapter 14 설명하는 주석
코드에서 명확하지 않은 내용만 골라 주석으로 작성한다.
> 결국, 이를 제거하는 방법을 배워야 하겠지만 그 때까지는 주석을 달아서 결합도 문제를 미리 지적해 두는 것이 모래 속에 묻듯 그냥 두는 것보다 훨씬 나을 것입니다.

## Chapter 15 불필요한 주석 지우기
코드만으로 내용을 모두 이해할 수 있다면 주석은 삭제한다. 어떠한 주석은 읽는 사람의 시간만 뺏기도 한다.
> 코드를 작성하는 목적은 다른 프로그래머에게 컴퓨터에게 해야 할 일을 설명하는 데 있습니다. 주석과 코드는 작성할 때와 나중에 볼 때, 시간이 흐르고 나면 서로 맞지 않는 경우가 있습니다.
