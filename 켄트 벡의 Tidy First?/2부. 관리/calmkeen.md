**CHAPTER.16 - 코드 정리 구분**

코드 정리는 별도의  PR을 만들어  몇개의 코드 정리만 넣습니다.

코드 정리에서 겪는 단계

- 다양한 변경 필요성을 구분하지 않은 상태에서 변경 시도
- 동작 변경과 구조 변경
- 순서를 부여한 동작 변경과 구조 변경
- 별도의 PR에 포함된 동작 변경과 구조 변경

코드 정리에 익숙해지고 , 작은단위로 작업하고 , 절대적으로 안전하게 작업하는데 익숙해지면

코드정리  PR을 검토하지 않는 시도를 해보아라.

**CHAPTER.17 - 연쇄적인 정리**

- 보호 구문 - 도우미나 변수 추출을 가능하게 함
- 안쓰는 코드 - 정렬 방법과 응집도를 높힘
- 대칭으로 맞추기 - 코드에 대한 일종의 목차 형태를 띄게 해줌
- 새로운 인터페이스로 기존 루틴 부르기
- 읽는 순서 - 대칭을 맞출 기회를 제공하면서 요소를 읽는 순서로 정리할 수 있음
- 응집도를 높이는 배치 - 큰 규모 설계 변경 및 동작 변경이 쉬워짐
- 설명하는 변수 - 불필요한 주석 삭제 가능
- 설명하는 상수 - 응집도를 높이는 배치를 만듬
- 명시적인 매개 변수 - 집함을 묶어 객체로 만들고 코드 이동이 가능하게 됨
- 비슷한 코드끼리 - 주석을 한번에 붙이거나 도우미로 변경
- 도우미 추출 - 추출 및 주석 삭제
- 하나의 더미 - 비슷한 코드끼리 정리, 설명, 추출등을 선택 가능
- 설명하는 주석
- 불필요한 주석 지우기 - 읽는 속도 개선

코드 구조를 대대적으로, 빠르게 변경하지 않고 순차적으로 성공하게 변경하라.

**CHAPTER.18 - 코드 정리의 일괄 처리량**

충돌 - 처리하는 코드가 많을 수록 과정이 지연되고 충돌 가능성이 올라갑니다.

상호작용 -  코드 정리 중 동작 변경 위험

추측 - 코드가 크면 정리 코드에 비용이 커진다.

코드 정리는 고정 비용이 큰 일입니다. → 코드 정리 개수를 늘려 동작 변경에 소용되는 비용을 줄이세요.

**CHAPTER.19 - 리듬**

구조변경에 걸리는 시간이 드는 요소

- 원하는 동작변경을 위한 최소 시기를 놓친 경우
- 코드가 너무 엉망인 경우

소프트웨어 설계는 길을 닦는 성격이 강합니다.

**동작 변경은 코드 안에 뭉쳐서 나타나는 경향이 있습니다.**

뭉친 코드는 동작 변경에 가장 좋은 위치에 뭉쳐져 있습니다.

계속 하다보면 정리가 끝나고 그안에서 또다시 정리하고 싶어 질것입니다. → 자동적으로 정리를 하다보면 언젠가 길이 보일것이다.( 사람들이 많이 밟은 잔디는 결국 길이 된다는 걸로 생각하시면 됩니다.)

**CHAPTER.20 - 얽힘 풀기**

코드를 짜고 수정하고 정리하다 보면 원치않게 꼬이는 경우가 있다. 

정리 순서, 동작 변경 등을 수정하다 전환 시점을 놓칠수 있지만 걱정하지 마세요. 코드 정리와 동작변경은 시간이 지나면 해결됩니다. chp.21에서 계속

**CHAPTER.21 - 코드 정리 시점**

3가지 타입

- 아예 안하기
    - 변경이 없는 프로그램이면 합리적으로 통할지도.
    - 설게 개선해도 의미 && 배울것이 없을 때 안해도 됩니다.
- 나중에 정리하기
    - 묶음으로 여러번 나눠서 코드 정리 가능할때(리스트 업 해두는것도 좋다.
    - 보상이 바로 보이지 않는데 양이 많을 때 나중에 합니다.
- 동작 변경 후 코드 정리
    - 방금 고친 코드를 다시 변경할 예정일때
    - 지금 정리하는 것이 저렴할때
    - 코드 정리에 시간이 동작 변경에 드는 시간과 비슷할 때
- 코드 정리 후 동작 변경 - 일반적으로 코드 정리 선행을 선호하지만 그 자체가 목적이 되지 않게 경계해야합니다.
    - 이해가 쉬워지거나 동작 변경이 쉬워지는 효과를 바로 얻을때
    - 어떻게 정리할지 바로 알수 있을 때


결론 :하지만 이 전체의 답에 대한 정답은 상황에 따라 다르다는 그런 진부한..
