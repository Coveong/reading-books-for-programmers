# 09장. LSP: 리스코프 치환 원칙

- Child 타입의 객체 c에 대응하는 Parent타입 객체 p가 있다.
- Parent 타입을 이용해서 정의한 모든 프로그램 Parent에서 p의 자리에 c을 치환해도 Parent의 행위가 변하지 않는다면, Child는 Parent의 하위 타입이다.

# 상속을 사용하도록 가이드하기

서로 다른 알고리즘을 이용해서 라이선스 비용 계산

Billing → License

.                     |

.              . ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ.

.         PersonalLisense            BusinessLicense

→ LSP를 준수한다.

왜?

Billing 어플리케이션의 행위가 License 하위 타입 중 무엇을 사용하는지에 전혀 의존하지 않기 때문이다.

하위 타입들은 모두 License 타입을 치환할 수 있다.

# 정사각형/직사각형 문제

User → Rectangle

.                    |

.               Square



→ LSP를 준수하지 않는다.

왜?

Rectangle의 높이와 너비는 서로 독립적으로 변경될 수 있는 반면, Square의 너비와 높이는 반드시 함께 변경된다.

```java
Rectangle r = ...
r.setW(5);
r.setH(2);
assert(r.area() == 10);
```

...에 Square를 생성하면 실패한다.

# LSP와 아키텍처

- LSP는 인터페이스와 구현체에도 적용되는 광범위한 소프트웨어 설계 원칙
- 아키텍처 관점에서 LSP를 이해하는 최선의 방법은 이 원칙을 어겼을 때 시스템 아키텍처에서 무슨 일이 일어나는지 관찰하는 것이다.

# LSP 위배 사례

LSP를 위배했을때 아키텍트는 REST 서비스들의 인터페이스가 서로 치환 가능하지 않다는 사실을 처리하는 중요하고 복잡한 매커니즘을 추가해야 하는 상황도 생긴다.

# 결론

- LSP는 아키텍처 수준까지 확장할 수 있고, 반드시 확장해야만 한다.
- 치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어 상당량의 별도 메커니즘을 추가해야 할 수 있기 때문이다.