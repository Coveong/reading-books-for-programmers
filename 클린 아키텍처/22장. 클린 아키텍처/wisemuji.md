# 클린 아키텍처

시스템 아키텍처에 관한 여러 가지 아이디어를 수십년간 우리는 계속 고민해왔다.

이들의 공통적인 목표는 바로 '관심사의 분리'다.

이들은 모두 시스템이 다음과 같은 특징을 갖도록 한다:
* 프레임워크 독립성
* 테스트 용이성
* UI 독립성
* 데이터베이스 독립성
* 모든 외부 에이전시에 대한 독립성

![image](https://user-images.githubusercontent.com/32327475/122688129-714f2f00-d255-11eb-80d2-3b4ac4049463.png)

## 의존성 규칙

> 소스 코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다.

내부 원에 속한 요소는 외부 원에 속한 어떤 것도 알지 못한다.

## 엔티티

엔티티는 전사적인 핵심 업무 규칙을 캡슐화한다. (가장 일반적이며 고수준인 규칙)

운영 관점에서 특정 애플리케이션에 무언가 변경이 필요하더라도 엔티티 계층에는 절대로 영향을 주어서는 안된다.

## 유스케이스

유스케이스 계층의 소프트웨어는 애플리케이션에 특화된 업무 규칙을 포함한다. 엔티티가 자신의 핵심 업무 규칙을 사용해서 유스케이스의 목적을 달성하도록 이끈다.

이 계층에서 발생한 변경이 엔티티에 영향을 주어서는 안된다. DB, UI, 프레임워크와 같은 외부 요소에서 발생한 변경으로부터 격리되어 있다.

하지만 운영 관점에서 에플리케이션이 변경된다면 유스케이스가 영향을 받는다.

## 인터페이스 어댑터

인터페이스 어댑터 계층은 일련의 어댑터들로 구성되고 어댑터는 데이터를 유스케이스와 엔티티에게 가장 편리한 형식에서 데이터페이스나 웹 같은 외부 에이전시에게 가장 편리한 형식으로 변환한다.

프레젠터, 뷰, 컨트롤러는 모두 인터페이스 어댑터 계층에 속한다.

또 이 계층에는 데이터를 외부 서비스와 같은 외부적인 형식에서 유스케이스나 엔티티에서 사용되는 내부적인 형식으로 변환하는 또 다른 어댑터가 피룡하다.

## 프레임워크와 드라이버

세부사항이 위치하는 곳이다. 모두 외부에 위치시켜서 피해를 최소화한다.

> 웹, 데이터베이스 모두 세부사항이다

## 원은 네 개여야만 하나?

항상 네 개만 사용해야 하는 규칙은 없지만 어떤 경우에도 의존성 규칙은 적용된다.

## 경계 횡단하기

제어흐름과 의존성의 방향이 명백히 반대여야 하는 경우, 대체로 의존성 역전 원칙을 사용하여 해결한다.

### 경계를 횡단하는 데이터는 어떤 모습인가 

내부의 원에서 외부 원의 무언가를 알지 못하도록 항상 내부의 원에서 사용하기에 가장 편리한 형태를 가져야만 한다.

## 전형적인 시나리오

![image](https://user-images.githubusercontent.com/32327475/122688389-ecfdab80-d256-11eb-9676-1ead38a53a7c.png)

# 결론
소프트웨어를 계층으로 분리하고 의존성 규칙을 준수한다면 본질적으로 테스트하기 쉬운 시스템을 만들게 될 것이며 그에 따른 이점을 누릴 수 있다. 


