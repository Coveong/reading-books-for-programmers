# 12장. 컴포넌트

# 컴포넌트란?

- 시스템의 구성 유소로 배포할 수 있는 가장 작은 단위

컴포넌트는 배포단위입니다. 자바의 jar 파일, 루비의 gem 파일, 닷넷의 DLL 등이 있습니다.

언어에 따라 컴포넌트에 대한 정의가 달라지는데요

- 컴파일형 언어 : 바이너리 파일의 결합체
- 인터프리터형 언어 : 소스 파일의 결합체

또한, 여러 컴포넌트를 서로 링크하여 실행 가능한 단일 파일로 생성할 수 있습니다.

컴포넌트가 마지막에 어떤 형태로 배포되든, 잘 설계된 컴포넌트라면 반드시 독립적으로 배포 가능한, 독립적으로 개발 가능한 능력을 갖춰야 합니다.

# 컴포넌트의 역사

소프트웨어 개발 초창기

- 메모리에서의 프로그램 위치, 레이아웃을 프로그래머 직접 제어
- 프로그램을 로드할 메머리의 위치를 정하는 일 → 프로그래머가 가장 먼저 결정해야하는 사항 중 하나
- 프로그래머가 라이브러리 함수의 소스 코드를 애플리케이션 코드에 직접 포함시켜 단일 프로그램으로 컴파일!

→ 😱 메모리가 너무 작아서 소스 코드 전체를 메모리에 상주시킬 수 없는 문제 발생

애플리케이션이 커지면서...

- 컴파일 시간 단축을 위해 함수 라이브러리의 소스 코드를 애플리케이션 코드로 분리
- 애플리케이션을 두 개의 주소 세그먼트로 분리해 함수 라이브러리 공간을 사이에 두고 동작하게 배치

→ 😱함수 라이브러리가 커지면서 메모리를 넘어가는 문제 발생

🤔그럼 어떻게 해결해야 할까요?

→ 해결책은 재배치가 가능한 바이너리 입니다!

# 재배치성

지능적인 로더를 사용해서 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정하는 것입니다.

로더는 바이너리를 입력받은 후, 단순히 차례로 메모리로 로드하면서 재배치하는 작업을 처리합니다.

→ 프로그래머는 오직 필요한 함수만을 로드할 수 있게 되었습니다.

라이브러리 함수를 정의하는 프로그램이라면 컴파일러는 해당 이름을 외부 정의로 생성합니다.

외부 정의를 로드할 위치가 정해지기만 하면 로더가 외부 참조를 외부 정의에 링크시킬 수 있게 됩니다.

→ 이렇게 링킹 로더가 탄생했습니다.

# 링커

링킹 로더의 등장 → 프로그램을 개별적으로 컴파일하고 로드할 수 있는 단위로 분할할 수 있게 되었습니다.

하지만, 프로그램이 커지면서 링킹 로더는 느려지게 되고 마침내 로드와 링크가 두 단계로 분리됩니다.

링크는 링커라는 별도의 애플리케이션으로 작업 처리합니다.

- 링커는 링크가 완료된 재배치 코드 만들어 주고 로딩 과정 빨라짐

하지만, 각 모듈을 컴파일하는 과정은 상대적으로 빨랐지만, 전체 모듈을 컴파일하는 일은 꽤 시간이 걸렸습니다.

→ 액티브 X와 공유라이브러리, 컴퓨터와 장치가 빨라지면서 또다시 로드와 링크를 동시에 할 수 있게 되어 다수의 .jar 파일또는 다수의 공유 라이브러리를 순식간에 서로 링크한 후, 링크가 끝난 프로그램을 실행할 수 있게 되었습니다.

바로, 컴포넌트 플러그인 아키텍처가 탄생했습니다.

오늘날에는 기존 애플리케이션에 플로그인 형태로 배포하는 것이 일상적인 일이 되었습니다.

# 결론

런타임에 플러그인 형태로 결합할 수 있는 동적 링크 파일이 소프트웨어 컴포넌트에 해당합니다.