# 12장. 컴포넌트

컴포넌트 = 시스템의 구성 요소로 **배포할 수 있는 가장 작은 단위** 

자바 → jar

그 외에 dll, exe .. 으로 배포 할 수도 있다.

잘 설계된 컴포넌트 = 독립적으로 배포, 개발 가능해야 한다.

# 컴포넌트의 간략한 역사

- 소프트웨어 개발 초창기에는 메모리에서의 파로그램 위치, 레이아웃을 프로그래머가 직접 제어
- 구시대에는 라이브러리 함수에 접근하려면 라이브러리 함수의 소스 코드를 애플리케이션 코드에 직접 포함 시켜서 단일 프로그램으로 컴파일

    → 컴파일 과정은 너무 오래 걸리고, 메모리는 너무 비싸 한정적

- 컴파일 시간을 단축시키기 위해 함수 라이브러리를 개별적으로 컴파일하고, 라이브러리를 로드한 다음 메모리 주소에 접근하는 방식으로 라이브러리를 사용
- 점점 프로그램과 라이브러리의 크기가 커지면서 사용하는 메모리가 늘어가 단편화가 심해짐

→ 지속 가능하지 않음

# 재배치성

- 재배치가 가능한 바이너리로 해결책을 제시
    - 지능적인 로더를 사용해서 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러 수정
- 프로그래머는 함수 라이브러리를 로드할 위치와 애플리케이션을 로드할 위치를 로더에게 지시할 수 있게 됨

    → 프로그래머는 오직 필요한 함수만 로드할 수 있게 됨

- 재배치 가능한 바이너리 안의 함수 이름을 메타데이터 형태로 생성하도록 수정되었음
    - 프로그램이 라이브러리 함수를 호출 : 컴파일러는 라이브러리 함수 이름을 **외부 참조**
    - 라이브러리 함수를 정의하는 프로그램 : 해당 이름을 **외부 정의**로 생성

    → 외부 정의를 로드할 위치가 정해지면, **외부 참조를 외부 정의에 링크시킬** 수 있다.

    → **링킹 로더 탄생**

# 링커

- 프로그램을 개별적으로 컴파일하고 로드할 수 있는 단위로 분할할 수 있게 되었음
    - 하지만, 프로그램이 커지면서 링킹 로더도 느려짐
    - 프로그래머가 느린 부분인 링크 과정을 맡아 **링커**라는 별도의 애플리케이션으로 이 작업을 처리하게됨

        → 링커는 링크가 완료된 재배치 코드를 만들어 주었고, 그 결과 로더의 로딩 과정이 아주 빨라지게 됨

- C나, 고수준 언어를 사용하면서 코드가 수십만 라인을 넘어서며 결국 컴파일과 링커에서 걸리는 시간이 다시 늘어남
    - 무어(Moore)가 등장해 이를 해결하자 디스크는 작아지기 시작했고, 놀랄 만큼 빨라지게 됨
    - 컴퓨터 메모리도 저렴해짐
    - 액티브 X와 공유 라이브러리의 시대가 열리며 .jar 파일도 등장

    → **컴포넌트 플러그인 아키텍처**의 탄생