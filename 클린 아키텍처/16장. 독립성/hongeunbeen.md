# 16장. 독립성

좋은 아키텍처는 다음을 지원해야 합니다.

- 시스템의 유스케이스
- 시스템의 운영
- 시스템의 개발
- 시스템의 배포

# 유스케이스

시스템의 아키텍처는 시스템의 의도를 지워해야 합니다.

아카텍트의 최우선 관심사는 유스케이스이며, 아키텍처에서도 유스케이스가 최우선 입니다.

가장 중요한 사항은 행위를 명확히 하고 외부로 드러내며, 이를 통해 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있도록 만들어야 합니다.

해당 시스템의 유스케이스는 시스템 구조 자체에서 한눈에 들어나 행위는 일급요소로 시스템의 최상위 수준에서 알아볼 수 있어 개발자가 일일이 찾아 해매지 않아도 됩니다.

클래스이거나 함수 또는 모듈로서 아키텍처 내에서 핵심적인 자리를 차지하며 자신의 기능을 분명하게 설명하는 이름을 가지게 됩니다.

# 운영

운영 지원 관저멩서 아키텍처는 덜 피상적인 역할입니다. 

하지만 시스템에 따라 다양한 의미를 가지게 되는데요

시스템이 단일체로 작성되어 모노리틱 구조를 갖는다면, 다중 프로세스, 다중 스레드, 또는 마이크로서비스 형태가 필요해질 때 개선하기 어려워집니다. 

 만약, 아키텍처에서 각 컴포넌트를 적절히 격리하여 유지하고 컴포넌트 간 통신 방식을 특정 형태로 제한하지 않는다면 요구사항이 변경되어도 스레드, 프로세스, 서비스로 구성된 기술 스펙트럼 사이를 전환하는 일이 훨씬 쉬워질 것입니다.

# 개발

아키텍처는 개발환경을 지원하는데 있어 핵심적인 역할을 수행합니다.

```java
시스템을 설계하는 조직이라면 어디든지 그 조직이 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다.
```

이들 컴포넌트를 독립적으로 작업할 수 있는 팀에 할당하기 위해서는

잘 격리되어 독립적으로 개발 가능한 컴포넌트 단위로 시스템을 분할 할 수 있어야 합니다.

# 배포

아키텍처는 배포 용이성을 결정하는 데 중요한 역학을 합니다.

목표는 '즉각적인 배포'로 시스템이 빌드된 후 즉각 배포할 수 있도록 지원해야 합니다.

시스템을 컴포넌트 단위로 적절하게 분할하고 결리시켜야 합니다. 마스터 컴포넌트 또한, 시스템 전체를 하나로 묶고, 각 컴포넌트를 올바르게 구동하고 통합하고 관리해야 합니다.

# 선택사항 열어놓기

좋은 아키텍처는 컴포넌트 구조와 관련된 관심사들 사이에서 균형을 맞추고 각 관심사 모두를 만족시킵니다.

하지만 이는 쉽지 않습니다. 바로, 시스템이 생명주기의 단계를 하나씩 거쳐감에 따라 사항들도 반드시 변해가기 때문입니다.

→ 이때, 이러한 변화 속에서 사라지지 않는 것들도 있습니다. 

시스템을 제대로 격리된 컴포넌트 단위로 분할 하고 선택사항을 가능한 한 많이 오랫동안 열어두는 것입니다.

선택사항을 열어 둠으로써, 향후 시스템에 변경이 필요할 때 어떤 방향으로든 쉽게 변경할 수 있도록 해야 합니다.

# 계층 결합 분리

아키텍트는 필요한 모든 유스케이스를 지원할 수 있는 시스템 구조를 원하지만 유스케이스 전부를 알지는 못합니다.

하지만 `기본적인 의도`는 알고 있으니 단일 책임 원칙과 공통 폐쇄 원칙을 적용해 그 의도의 맥락에 따라서 다른 이유로 변경되는 것들은 분리하고, 동일한 이유로 변경되는 것들을 묶어야 합니다.

🤔  서로 다른 이유로 분리되는 것은 무엇인가요?

→ 사용자 인터페이스가 변경되는 이유는 업무 규칙과는 아무런 관련이 없습니다.

서로 다른 두 유형의 규칙은 각자 다른 속도로, 다른 이유로 변경되기에 서로 분리하고, 독립적으로 변경할 수 있도록 만들어야 합니다.

시스템을 서로 결합되지 않은 수평적인 계층으로 분리해야 합니다.

# 유스케이스 결합 분리

서로 다른 이유로 변경되는 것에는 유스케이스 그 자체도 있습니다.

유스케이스는 수평적인 계층을 가로지르도록 자른, 수직으로 좁다란 조각입니다. 각 유스케이스는 UI의 일부, 업무 규칙의 일부 DB 기능의 일부 등을 사용합니다.

따라서 우리는 시스템을 수평적 계층으로 분할하면서 동시에 해당 계층을 가로지르는, 얇은 수직적인 유스케이스로 시스템을 분할 할 수 있습니다.

🤔  수평과 수직분할 어떻게 분리해야 할나요?

→ 시스템의 맨 아래 계층까지 수직으로 내려가며 유스케이스들이 각 계층에서 서로 겹치지 않게 해야 합니다.

시스템에서 서로 다른 이유로 변경되는 요소들의 결합을 분리하면 기존 요소에 지장을 주지 않고도 새로운 유스케이스를 계속해서 추가할 수 있습니다.

# 결합 분리 모드

결합을 분리하면 운영 관점에서는 ...

![](image/heb_image1.heic)

유스케이스를 위해 수행하는 작업들은 운영에 도움이 되지만 이점을 살리기 위해선 결합을 분리할때 적절하게 선택해야 합니다.

분리된 컴포넌트를 서로 다른 서버에서 실행해야 한다면 다닝ㄹ 프로세서의 동일한 주소 공간에 함께 상주하는 형태로 만들어서는 안됩니다.

이처럼 때때로 컴포넌트를 서비스 수준가지도 분리해야 할 수 있이기에 좋은 아키텍처는 선택권을 열어 두어야 합니다.

**개발 독립성**과 **배포 독립성**을 가질 수 있습니다.

# 중복

중복에는 여러 종류가 있습니다.

- 진짜 중복
(한 인스턴스가 변경되면, 동일한 변경을 그 인스턴스의 모든 복사본에 반드시 적용해야 함)
- 거짓된 또는 우발적인 중복

주의할 점은 서로 다른 속도와 다른 이유로 변경된다면 이 두 코드는 진짜 중복이 아닙니다.🥲

중복이 진짜 중복인지 확인하고 유스케이스를 통합하거나 계층을 수평으로 분리해야 합니다.

# 결합분리 모드(다시)

계층과 유스케이스의 결합을 분리하는 방법은 다양합니다.

- 소스 코드 수준에서 분리

    → 소스 코드 무듈 사이의 의존성을 제어하고 재컴파일하지 않도록 만들 수 있습니다.

    → 모든 컴포넌트가 같은 주소 공간에서 실행되고 통신시 간단한 함수만 호출합니다. 

    → 컴퓨터 메모리에는 하나의 실행파일만 로드됩니다.(모노리틱 구조)

- 바이너리 코드(배포) 수준에서 분리

    → 배포 가능한 단위(.jar, DLL, 공유 lib)들 사이의 의존성을 제어하고 재배포하지 않도록 만들 수 있습니다.

    → 대부분의 컴포넌트가 같은 주소 공간에서 실행되고 통신시 간단한 함수만 호출합니다. 

    → 결합이 분리된 컴포넌트가 독립적으로 배포할 수 있는 단위로 분할되어 있습니다.

- 실행 단위(서비스) 수준에서 분리

    → 데이터 구조 단위까지 의존하는 수준을 낮춥니다.

    → 순전히 네트워크 패킷을 통해서만 통신하도록 만들 수 있스빈다.

    → 모든 실행 간으한 단위는 소스와 바이너리 변경에 대해 서로 독립적이게 됩니다.

🤔  언제 무슨 분리를 사용해야 하나요?

→ 시스템이 한 서버에서 실행되는 동안은 결합을 소스 수준에서 분리하는 것만으로도 충분합니다.

단순히 서비스 수준에서의 분리를 기본 정책으로 삼는 것이 인기가 많습니다.

하지만, 개발 시간이나 시스템 자원 특면에서 비용이 많이 들기 때문에 컴포넌트가 서비스화될 가능성이 있다면 컴포넌트 결합을 분리하되 서비스가 되기 직전에 멈추는 방식을 선호합니다.

이렇게 된다면 초기에는 컴포넌트가 소스 코드 수준에서 분리되고 서비스가 늘어나면 서비스 수준으로 전환할 배포 단위들을 신중하게 선택한 후 시스템을 변경해 나갑니다.

좋은 아키텍처는 시스템이 모노리틱 구조로 태어나서 다닝ㄹ 파일로 배포되더라도 이후에는 독립적으로 배포 간으한 단위들의 집합으로 성장하고, 또 독립적인 서비스나 마이크로서비스 수준까지 성장할 수 있도록 만들어져야 합니다.

# 결론

📌 시스템의 결합 분리 모드는 시간이 지나면서 바뀌기 쉬우며, 뛰어난 아키텍트라면 이러한 변경을 예측하여 큰 무리 없이 반영할 수 있도록 만들어 합니다.