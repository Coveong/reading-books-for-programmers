# 10장. 인터페이스 분리 원칙

![10%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%B5%E1%86%A8%200ce27885220a403b9ebdc786f11cd9c5/IMG_264C3623489A-1.jpeg](10%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%B5%E1%86%A8%200ce27885220a403b9ebdc786f11cd9c5/IMG_264C3623489A-1.jpeg)

위와 같은 다이어그램에서 ISP의 이름이 유래되었습니다.

다수의 사용자가 `OPS` 클래스의 오퍼레이션을 사용하는데요

만약, `User 1 → op1`만을 사용하고 `User 2 → op2`, `User3 → op3`만을 사용하고, `ops`가 정적 타입 언어로 작성된 클래스라면 `User1`은 `op2, op3`가 필요하지 않음에도 두 메서드에 의존하게 됩니다.

해결방법은 오퍼레이션을 인터페이스 단위로 분리하는 것 입니다.!

![10%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%B5%E1%86%A8%200ce27885220a403b9ebdc786f11cd9c5/IMG_861C399E6691-1.jpeg](10%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%B5%E1%86%A8%200ce27885220a403b9ebdc786f11cd9c5/IMG_861C399E6691-1.jpeg)

# ISP와 언어

정적 타입 언어는 타입 선언문을 사용하도록 강제합니다. 이처럼 소스코드에 포함된 선언문으로 인해 소크 토드 의존성이 발생하고, 이로 인해 재컴파일 또는 재배포가 강제되는 상황이 초래됩니다.

동적 타입 언어를 사용하면 정적 타입 언어를 사용할 때보다 유연하며 결합도가 낮은 시스템을 만들 수 있는 이유가 이 때문입니다.

ISP를 아키텍처가 아닌, 언어와 관련된 문제라고 결론내릴 여지가 있습니다.

# ISP와  아키텍처

필요 이상으로 많은 걸 포함하는 모듈에 의존하는 것은 해로운 일 입니다.

불필요한 재컴파일과 재배포를 강제하기 때문입니다. 하지만 더 고수준인 아키텍처 수준에서도 같은 상황이 발생합니다!🤯

![10%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%B5%E1%86%A8%200ce27885220a403b9ebdc786f11cd9c5/_2021-06-05__1.47.38.png](10%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%8E%E1%85%B5%E1%86%A8%200ce27885220a403b9ebdc786f11cd9c5/_2021-06-05__1.47.38.png)

이런 식으로 시스템 `S` 구축에 `F` 프레임워크를 도임했을 때 `F`는 `D` 데이터베이스를 사용하고 있어 `S → F → D` 이런식으로 의존이 발생하게 됩니다.

→ `S`와 관계없는 기능이 `D`에 포함된다면 `D` 내부의 기능 이 `F` 와 `S`에 영향을 줄 수 있습니다.

# 결론

불필요한 짐을 실은 무언가에 의존하면 예상치도 못한 문제에 빠질 수 있습니다.