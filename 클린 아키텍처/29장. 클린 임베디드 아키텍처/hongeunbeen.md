# 29장. 클린 임베디드 아키텍처

> 소프트웨어는 닳지 않지만, 펌웨어와 하드웨어는 낡아 가므로 결국 소프트웨어도 수정해야 한다.

이 주장에 저자의 의견을 덧 붙이면

> 소프트웨어는 닳지 않지만, 펌웨어와 하드웨어에 대한 의존성을 관리하지 않으면 안으로부터 파괴될 수 있다.

🤔 펌웨어란 무엇인가요?

- 펌웨어는 ROM같은 비휘발성 메모리에 유지된다.
- 펌웨어는 하드웨어 장치에 프로그래밍된 소프트웨어 프로그램 혹은 명령어 집합이다.
- 펌웨어는 개별 하드웨어에 내장되는 소프트웨어다
- 펌웨어는 읽기 전용 메모리에 쓰여진 소프트웨어다

즉, 무엇에 의존하는지, 그리고 하드웨어 발전에 맞춰 수정하기가 얼마나 어려운지에 따라 정의됩니다.

개발자는 펌웨어는 더 적게 만들고, 소프트웨어는 더 많이 만드는 것을 추구합니다.

코드에 SQL을 심어놓거나 개발하는 코드 전반에 플랫폼 의존성을 퍼뜨려 놓는다면, 본질적으로 펌웨어를 작성하는 셈입니다.

소프트웨어를 하드웨어 즉, 펌웨어로두터 분리해야 합니다.

펌웨어를 수업싱 양상하는 일을 멈추고, 코드에게 유효 수명을 길게 늘릴 수 있는 기회를 주어야 합니다.

# 앱-티튜드 테스트

- 먼저 동작하게 만들어라
- 그리고 올바르게 만들어라
- 그리고 빠르게 만들어라

위의 3가지 조건은 켄트백의 소프트웨어를 구축하는 세 가지 활동입니다.

동작하게 하라 와 빠르게 만들어라 라는 목표에 집착하게 되면 안됩니다.

애플리케이션이 동작하도록 만드는 것을 개발자용 앱-티튜드 테스트라고 부릅니다.

애플리케이션은 동작하고 앱-티튜드 테스트를 통과할 수는 있지만 클린 임베디드 아키텍처를 가진다고 말하기는 어렵습니다.

# 타킷-하드웨어 병목현상

임베디드가 지닌 특수한 문제 중 하나는 타깃-하드웨어 병목현상입니다.

코드를 테스트할 수 있는 환경이 해당 특정 타깃으로 국한되고 이 타깃이 테스트가 가능한 유일한 장소라면 타깃-하드웨어 병목현상이 발생해 진척이 느려집니다.

**클린 임베디드 아키텍처는 테스트하기 쉬운 임베디드 아키텍처다**

아키텍처 원칙을 임베디드 소프트웨어와 펌웨어에 적용해 타깃-하드웨어 병목현상을 줄이는 방법을 살펴보겠습니다.

**계층**

하드웨어는 기술의 발전과 무어의 법칙에 따라 변화하고 이 정보가 코드 전체를 오염시키지 못하게 막을 방법이 없어 시스템의 나머지 부분으로부터 반드시 분리되어야 합니다.

소프트웨어와 펌웨어 사이의 경계는 코드와 하므두에어 겅계처럼 잘 정의하기가 어렵습니다.

이렇게 소프트웨어와 펌웨어가 서로 섞이는 일은 안티패턴입니다.

소프트웨어와 펌웨어 사이의 경계는 `하드웨어 추상화계층 HAL` 이라고 부릅니다.

하드웨어는 세부사항입니다.

HAL은 자신보다 위에 있는 소프트웨어를 위해 존재하므로, HAL의 API는 소프트웨어의 필요에 맞게 만들어져야 합니다.

또한, 애플리케이션에서 필요로 하는 서비스를 표현함을 알 수 있습니다. 

계층은 또 다른 계층을 포함할 수 있어 계층의 수가 정해진 상태로 구성되기보다는 프랙털 패턴에 더 가깝습니다.

**HAL 사용자에게 하드웨어 세부사항을 드러내지 말라**

클린 임베디드 아키텍처로 설계된 소프트웨어는 타깃 하드웨어에 관계없이 테스트가 가능합니다.

HAL도 제대로 만들었다면, 타깃에 상관없이 테스트할 수 있는 경계층 또는 일련의 대체 지점을 제공합니다.

**프로세서는 세부사항이다**

클린 임베디드 아키텍처라면 장치 접근 레지스터를 직접 사용하는 코드는 순전히 펌웨어로만 한정해야 합니다.

코드를 프로세서와 직접적으로 묶어버리면 코드를 실행시키고자 할 때 어려움을 겪을 수 있습니다.

마이크로 컨트롤러를 사용할 떄, 펌웨어가 저수준 함수들을 `프로세서 추상화 계층 PAL`의 형태로 격리시켜줄 수 있습니다.

PAL상위에 위치하는 펌웨어는 타깃-하드웨어에 간계없이 테스트할 수 있게 되어, 펌웨어 자체도 덜 딱딱해질 수 있습니다. 

**운영체제는 세부사항이다**

HAL은 필수적이짐나 HAL만으로 충분하지는 않은 상황도 존재합니다.

임베디드 시스템에서 실시간 운영체제를 사용하거나, 임베디드 버전의 리눅스/윈도우를 사용한다면 무조건 운영체제를 세부사항으로 취급하고 운영체제에 의존하는 일을 막아야 합니다.

클린 임베디드 아키텍처는 운영체제 추상화 계층 OSAL을 통해 소프트웨어를 운영체제로부터 격리킵니다. 

OSAL 구현은 함수 이름을 바꿔주는 정도로 단순할 수 있습니다.

OSAL은 OS를 사용하는 데 따른 수많은 중복이 격리되어 있는 장소로 코드 비대화 문제가 염려될 수 있습니다.

하짐나 중복이 그다지 큰 비용을 추가로 초래하지 않고 OSAL을 정의하는 일은 결국 애플리케이션에서도 공통 구조를 가지도록 힘쓰는 일이기도 합니다.

OSAL은 테스트 지점을 만드는 데 도움이 되고, 덕분에 소프트웨어 계층의 귀중한 애플리케이션 코드를 타깃이나 OS에 관계없이 테스트가 가능합니다.

**인터페이스를 통하고 대체 가능성을 높이는 방향으로 프로그래밍하라**

관심사를 분리시키고, 인터페이스를 활용하며, 대체 가능성을 높이는 방향으로 프로그래밍을 유도하기 위해 모든 주요 계층 내부에는 원칙들을 적용할 수 있습니다.

계층형 아키텍처는 인터페이스를 통해 프로그램이하자는 발상을 기반으로 합니다!

세부사항을 알고 있는 부분이 적을수록 추적하고 변경해야 할 코드도 적어집니다.

구현 세부사항의 가시성을 제한하고 구현 세부사항은 변경될거라고 가정합시다.

클린 임베디드 아키텍처에서는 모듈들이 인터페이스를 통해 상호작용하기 떄문에 각각의 계층 내부에서 테스트가 가능합니다. 각 인터페이스를 타깃과는 별개로 테스트할 수 있도록 경계층 또는 대체 지점을 제공합니다.

**DRY 원칙 : 조건부 컴파일 지시자를 반복하지 말라**

코드를 반복하는 일은 `반복하지 말라 DRY 원칙`을 위배합니다.

만약 하드웨어 추상화 계층이 있다면 하드웨어 유형은 HAL 뒤에 가려진 세부사항이 됩니다. 

또한, 만약 HTML이 조건부 컴파일 대신 사용할 수 있는 일련의 인터페이스를 제공한다면, 링커 또는 어떤 형태의 실시간 바인딩을 사용해 소프트퉤어를 하드웨어와 연결할 수 있습니다.

# 결론

📌  임베디드 소프트웨어를 개발하는 사람들은 임베디드 소프트웨어 바깥의 경험에서 많은 것을 배울 수 있습니다.

📌  클린 임베디드 아키텍처는 제품이 장기간 생명력을 유지하는데 도움을 줍니다.
