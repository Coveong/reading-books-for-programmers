# 14장. 컴포넌트 결합

컴포넌트 사이의 관계를 설명하는 세 가지 원칙이 존재합니다.

- ADP : 의존성 비순환 원칙
- SDP : 안정된 의존성 원칙
- SAP : 안정된 추상화 원칙

→ 이 세 가지 원칙을 이용해 개발 가능성과 논리적 설계 사이의 균형을 이루어야 합니다.

# ADP : 의존성 비순환 원칙

```
컴포넌트 의존성 그래프에 순환이 있어서는 안 된다.
```

많은 개발자가 동일한 소스 파일을 수정하는 환경에서 코드를 수정하면 다른 코드가 망가지고 이 망가진 부분을 동작하게 하기 위해 또 수정을 반복하는 작업을 하게 되는 문제가 빈번하게 발생됩니다. 🤯

이 문제의 해결책으로 두 가지 방법이 있습니다.

- 주 단위 빌드
- 의존성 비순환 원칙

### 주 단위 빌드

중간 규모의 프로젝트에서 흔하게 사용됩니다.

방법은 개발자는 일주일의 첫 4일 동안은 서로 신경 쓰지 않고 개발합니다. 전체적인 기준에서 작업을 어떻게 통합할지는 걱정하지 않고 금요일에 이 코드를 모두 통합해 시스템을 빌드합니다.

하지만 이 같은 방법은 프로젝트가 커질수록 프로젝트 통합은 금요일 내에 끝낼 수 업섹 되고 위기를 초래합니다. 효율성을 유지하기 위해 빌드 일정을 계속 늘려야 하고, 빌드 주기가 늦어질수록 프로젝트가 감수할 위험은 커집니다.

### 의존성 비순환 원칙

주 단위 빌드의 문제점을 해결하기 위해 개발 환경을 릴리스 가능한 컴포넌트 단위로 분리해야 합니다.

컴포넌트는 개별 개발자 또는 단일 개발팀이 책임질 수 있는 작업 단위가 되고 각자 자신만의 공간에서 해당 컴포넌트를 지속적으로 수정합니다.

특정 컴포넌트가 변경되더라도 다름 팀에 영향을 주지 않기에 다른 팀에 의해 좌우되지 않게 되어 통합은 작고 점진적으로 이뤄집니다.

하지만 이 작업 절차를 성공적으로 적용하려면 컴포넌트 사이의 의존성 구조를 반드시 관리해야 합니다. 특히, 의존성 구조에 순환이 있어서는 안됩니다.

어느 컴포넌트에서 시작하더라도, 의존성 관계를 따라가면서 최초의 컴포넌트로 되돌아갈 수 없어야 합니다.

즉, 비순환 방향 그래프로 컴포넌트 다이어그램이 생성되어야 합니다.

### 순환이 컴포넌트 의존성 그래프에 미치는 영향

🤔   그럼, 왜 컴포넌트 의존성 그래프에 순환이 있으면 안되나요?

→ 순환이 생기면 컴포넌트를 분리하기가 상당히 어려워지기 때문입니다.

→ 순환이 생기면 단위 테스트를 하고 릴리스를 하는 일도 굉장히 어려워지며 에러도 쉽게 발생하기 때문입니다.

→ 순환이 생기면 모듈의 개수가 많아짐에 따라 빌드 관련 이슈는 기하급수적으로 증가하기 때문입니다.

→ 순환이 생기면 컴포넌트를 어떤 순서로 빌드해야 올바를지 파악하기 힘들어지기 때문입니다.

### 순환 끊기

컴포넌트 사이의 순환을 끊고 의존성을 다시 원상복구하는 일은 언제라도 가능합니다.

- 의존성 역전 원칙 적용한다.
- 순환하는 컴포넌트 모두가 의존하는 새로운 컴포넌트를 만든다.

### 흐트러짐

요구사항이 변경되면 컴포넌트 구조도 변경될 수 있습니다. 따라서 애플리케이션이 성장하면서 컴포넌트 의존성 구조는 흐트러지며 성장하게 됩니다. 

항상 의존성 구조에 순환이 발생하는지 관찰해야 합니다.

# 하향식 설계

컴포넌트 구조는 하향식으로 설계될 수 없다는 결론을 도출했습니다.

컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니며, 오히려 시스템이 성장하고 변경될 때 함께 진화합니다.

즉, 컴포넌트 구조를 프로젝트 초기에 설계를 할 수 없습니다.

빌드하거나 유지보수할 소프트웨어가 없다면 빌드와 유지보수에 관한 지도 또한 필요가 없습니다.

컴포넌트 의존성 구조는 시스템의 논리적 설계에 발맞춰 성장하며 또 진화해야 합니다.

# SDP : 안정된 의존성 원칙

```
안정성의 방향으로(더 안정된 쪽에) 의존하라.
```

변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들어서는 안됩니다.

즉, 모듈을 만들 때는 변경하기 쉽도록 설계했지만, 이 모듈에 누군가 의존성을 매달아 버리며 모듈도 변경하기 어렵게 됩니다.

이때. 안정된 의존성 원칙을 준수해야 합니다.

### 안정성

안정성은 변화가 발생하는 빈도와는 직접적인 관련이 없습니다.

'쉽게 움직이지 않는' 즉, 안정성은 변경을 만드릭 위해 필요한 작업량과 관련됩니다.

### 안정성 지표

컴포넌트 안정성을 측정하는 방법은 컴포넌트로 들어오고 나가는 의존성의 개수를 세어 보는 것입니다.

→ 이 숫자를 통해 컴포넌트가 위치상 어느 정도의 안정성을 가지는지 계산할 수 있습니다.

### 모든 컴포넌트가 안정적이어야 하는 것은 아니다

모든 컴포넌트가 최고로 안정적인 시스템이라면 변경이 불가능합니다.

→ 즉, 이는 바람직하지 않습니다.

우리는 컴포넌트 구조를 설계할 때 불안정한 컴포넌트와 안정된 컴포넌트가 같이 존재하는 상황을 기대합니다.

### 추상컴포넌트

🤔 추상 컴포넌트는 오로지 인터페이스만 포함하는데 왜 생성을 하나요?

→ 추상 컴포넌트는 상당히 안정적이며, 따라서 덜 안정적인 컴포넌트가 의존할 수 있는 이상적인 대상입니다.

# SAP : 안정된 추상화 원칙

```
컴포넌트는 안정된 정도만큼만 추상화되어야 한다.
```

### 고수준 정책을 어디에 위치시겨야 하는가?

시스템에서 자주 변경해서는 안 되는 소프트웨어가 존재합니다.

- 고수준 아키텍처
- 정책 결정과 관련된 소프트웨어

→ 업무 로직이나 아키텍처와 관련된 결정에는 변동성이 없기를 기대합니다.

시스템에서 고수준 정책을 캡슐화하는 소프트웨어는 반드시 안정된 컴포넌트에 위치해야 합니다.

컴포넌트가 최고로 안정된 상태이면서도 동시에 변경에 충분히 대응할 수 있을 정도로 유연하게 만들려면 OCP원칙을 적용하면 됩니다.

그리고 이 OCP 원칙을 준수하는 클래스는 바로 추상 클래스 입니다.

### 안정된 추상화 원칙

안정성과 추상화 정도 사이의 관계를 정의합니다.

안정적인 컴포넌트라면 반드시 인터페이스와 추상 클래스로 구성되어 쉽게 확장할 수 있어야 합니다.

# 결론

📌  의존성 관리 지표는 설계의 의존성과 추상화 정도가 내가 '훌륭한' 패턴이라고 생각하는 수준에 얼마나 잘 부합하는지를 측정한다.

📌  좋은 의존성도 존재하지만 좋지 않은 의존성도 존재한다.