# 컴포넌트 결합

이 장에서는 컴포넌트 사이의 관계를 설명하는 세 가지 원칙을 보면서 개발 가능성과 논리적 설계 사이의 균형을 다룬다.

## ADP: 의존성 비순환 원칙

> 컴포넌트 의존성 그래프에 순환이 있어서는 안된다.

숙취 증후군: 많은 개발자가 동일한 소스 파일을 수정하는 환경에서 발생하는 문제. 다른 개발자의 작업으로 인해 내가 짠 코드가 제대로 동작하지 않는다.

해결책:
1. 주 단위 빌드
2. 의존성 비순환 원칙

### 주 단위 빌드

프로젝트를 통합하는 날을 따로 두고 그때까지 각자 작업한다.

단점: 효율성을 유지하기 위해 빌드 일정을 늘려야 하고 그만큼 감수할 위험이 커진다

### 순환 의존성 제거하기

개발 환경을 릴리스 가능한 컴포넌트 단위로 분리한다.

특정 컴포넌트가 변경되더라도 다른 팀에 영향을 즉각 주지 않는다. 

작업 절차가 단순하며 합리적이여서 널리 사용되는 방식이다. 하지만 컴포넌트 의존성 구조 사이에 순환이 생기면 숙취 증후근을 피해갈 수 없다.

## 하향식 설계

컴포넌트 구조는 하향식으로 설계될 수 없다. 컴포넌트는 시스템에서 가장 먼저 설게할 수 있는 대상이 아니며 오히려 시스템이 성장하고 변경될 때 함께 진화한다.

아직 아무 클래스도 설계하지 않은 상태에서 컴포넌트 의존성 구조를 설계하려고 시도하는 것은 어렵다. 따라서 컴포넌트 의존성 구조는 시스템의 논리적 설계에 발맞춰 성장하며 또 진화해야 한다.

## SOP: 안정된 의존성 원칙

> 안정성의 방향으로(더 안정된 쪽에) 의존하라.

변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들어서는 안된다.

### 안정성

소프트웨어 컴포넌트를 변경하기 어렵게 만드는 확실한 방법 하나는 수많은 다른 컴포넌트가 해당 컴포넌트에 의존하게 만드는 것이다.

### 안정성 지표

컴포넌트 안정성을 측정하는 방법: 컴포넌트로 들어오고 나가는 의존성의 개수를 세어 보는 방법이 있다.

* Fan-in: 안으로 들어오는 의존성
* Fan-out: 바깥으로 나가는 의존성
* I(불안정성): I = Fan-out / (Fan-in + Fan-out)

I 값이 1이면 어떤 컴포넌트도 해당 컴포넌트에 의존하지 않지만 해당 컴포넌트는 다른 컴포넌트에 의존한다는 뜻이다. -> 최고로 불안정한 상태

I 값이 0이면 해당 컴포넌트에 의존하는 다른 컴포넌트가 있지만 해당 컴포넌트 자체는 다른 컴포넌트에 의존하지 않는다. -> 최고로 안정된 상태

SDP에서 컴포넌트의 I 지표는 그 컴포넌트가 의존하는 다른 컴포넌트들의 I보다 커야 한다고 말한다.

### 모든 컴포넌트가 안정적이어야 하는 것은 아니다.

모든 컴포넌트가 안정적이라면 시스템 변경이 불가능하다.

## SAP: 안정된 추상화 원칙

> 컴포넌트는 안정된 정도만큼만 추상화되어야 한다.

안정성과 추상화 정도 사이의 관계를 정의하는 원칙. 안정된 컴포넌트는 추상 컴포넌트여야 하며 이를 통해 안정성이 컴포넌트를 확장하는 일을 방해해서는 안된다.

다른 한편으로는 불안정한 컴포넌트는 반드시 구체 컴포넌트여야 하고 컴포넌트가 불안정하므로 컴포넌트 내부의 구체적인 코드를 쉽게 변경할 수 있어야 하기 때문이다. 

### 추상화 정도 측정하기

* Nc: 컴포넌트의 클래스 개수
* Na: 컴포넌트의 추상 클래스와 인터페이스 개수
* A: 추상화 정도, A = Na / Nc

A가 0이면 컴포넌트에는 추상 클래스가 하나도 없다는 뜻이다.

A가 1이면 컴포넌트는 오로지 추상 클래스만을 포함한다는 뜻이다.

### 안정성과 추상화 정도의 관계 그래프

![image](https://user-images.githubusercontent.com/32327475/120119826-cb1f8480-c1d4-11eb-9e15-1f7eec943021.png)

# 결론

의존성 관리 지표는 설계의 의존성과 추상화 정도가 내가 훌륭한 패턴이라고 생각하는 수준에 얼마나 잘 부합하는지를 측정한다.

하지만 지표는 그저 임의로 결정된 표준을 기초로 한 측정값에 지나지 않으므로 이러한 지표는 불완전하다는 것을 인지해야 한다.

