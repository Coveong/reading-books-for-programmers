# 08장. OCP: 개방-폐쇄 원칙

소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.

# 사고 실험

로직을 처리한 후에 A뷰로 보여주는 기능이 있다고 치자. 이 때 A뷰에 추가적인 사항이 생겨 B뷰로 보여줘야한다면 코드를 얼마나 바꾸는게 좋을까?

→ 소프트웨어 아키텍처가 훌륭하다면 **코드의 양이 가능한 최소화**되어야 한다. 이상적인 변경량은 0

훌륭한 소프트웨어 아키텍처를 만들기 위해서는

- 서로 다른 목적으로 변경되는 요소를 적절하게 분리하고 (SRP)
- 요소 사이의 의존성을 체계화해야한다. (DIP)

클래스는 컴포넌트 단위로 분리해야하고, 컴포넌트 관계는 단방향으로 이루어져있어야한다. (View → Presenter → Controller → Interactor ← Database)

- 어떠한 변경도 Interactor에게는 영향을 주지 않는다.
- 왜? Interactor가 가장 높은 수준의 정책을 포함하기 때문이다.
- 보호의 계층 구조가 수준(level)을 바탕으로 어떻게 생성되는지 주목해야한다.
    - View는 가장 낮은 수준의 개념이다.
    - Presenter은 View보다는 높지만 Controller보다는 낮다.
    - ...
- **아키텍트는 기능이 어떻게(how), 왜(why), 언제(when) 발생하는지에 따라서 기능을 분리하고, 분리한 기능을 컴포넌트의 계층구조로 조직화한다.**
- 컴포넌트 계층구조를 이와 같이 조직화하면 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 **보호**할 수 있다.

## 방향성 제어

- 컴포넌트간 의존성의 방향을 확실히 해야한다.
- 의존성을 역전시켜 고수준의 컴포넌트를 보호한다.

## 정보 은닉

- **추이 종속성**
    - 클래스 A가 클래스 B에 의존하고, 다시 클래스 B가 클래스 C에 의존한다면, 클래스 A는 클래스 C에 의존한다. 이를 추이 종속성이라고 한다.
    - 추이 종속성을 가지게 되면, 소프트웨어 엔티티는 '자신이 직접 사용하지 않는 요소에는 절대로 의존해서는 안 된다'는 소프트웨어 원칙을 위반하게 된다.

## 결론

OCP는 시스템의 아키텍처를 떠받치는 원동력 중 하나다. 다음은 OCP의 목표이다.

- 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 한다.
    - 그러기 위해서는 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조를 이뤄야 한다.