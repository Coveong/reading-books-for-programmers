# SOLID 원칙
 
SOLID는 함수와 데이터 구조를 클래스로 배치하고 결합하는 방법을 설명한다. 
(클래스는 단순히 함수와 데이터를 결합한 집합의 의미를 가지므로 객체 지향에만 적용되는건 아님)

목적은 중간 수준의 소프트웨어 구조가 아래와 같도록 만드는 데 있음:
* 변경에 유연하다
* 이해하기 쉽다
* 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다

# 단일 책임 원칙

아마 SOLID 원칙 중 그 의미가 가장 잘 전달되지 못한 원칙. 모든 모듈이 단 하나의 일만 해야 한다는 의미가 아니다.

> 하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.

이 원칙을 이해하는 가장 좋은 방법은 이 원칙을 위반하는 징후들을 살펴보는 일일것이다.

## 징후1: 우발적 중복

> 특정 함수를 사용하는 곳이 A, B 일때, A에서 함수를 수정하면 B에도 영향이 가게 된다.

서로 다른 액터가 의존하는 코드를 서로 분리해야 한다.

## 징후2: 병합

> 특정 함수를 사용하는 곳이 A, B 일때, A와 B 모두에서 함수를 수정하면 변경사항이 충돌하게 된다.

서로 다른 액터를 뒷받침하는 코드를 서로 분리해야 한다.

## 해결책

퍼사드 기법: 가장 중요한 메서드는 기존의 클래스에 그대로 유지하고, 해당 클래스를 덜 중요한 나머지 메서드들에 대한 퍼사드로 사용한다.

# 결론

단일 책임 원칙은 메서드와 클래스 수준의 원칙이 컴포넌트 수준에서는 공통 폐쇄 원칙, 아키텍처 수준에서는 아키텍처 경계의 생성을 책임지는 변경의 축이 된다.
