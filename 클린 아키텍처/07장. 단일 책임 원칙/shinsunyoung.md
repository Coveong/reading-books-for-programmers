# 07장. SRP: 단일 책임 원칙

SRP는 모듈이 하나의 일만 해야한다는게 아니다!

SRP는 **'하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.'** 이다.

- 액터
    - 해당 변경을 요청하는 한 명 이상의 사람들
- 모듈
    - 소스 파일
    - 또는 응집된 집합

원칙을 위반하는 징후들을 살펴보자

# 징후1: 우발적 중복

급여 애플리케이션 -  Employee

제공하는 메서드 - caclulatePay(), reportHours(), save()

이 클래스(Employee)는 SRP를 위반한다.

왜냐하면 세 가지의 메서드는 서로 다른 액터를 책임지기 때문이다.

- caclulatePay() : 회계팀에서 기능 정의, CFO 보고를 위해 사용
- reportHours() : 인사팀에서 기능 정의, COO 보고를 위해 사용
- save() : DBA가 기능 정의, CTO 보고를 위해 사용

→ CFO 팀에서 결정한 조치가 COO 팀이 의존하는 무언가에 영향을 줄 수도 있다!

# 징후2: 병합

같은 코드를 사용하고 있는데,

CTO팀, COO팀에서 같은 클래스의 다른 메서드를 수정하면? → 충돌, 병합 발생

# 해결책

아무런 메서드가 없는 간단한 데이터 구조 클래스(EmployeeData)를 만들고, 세 개의 클래스가 공유하도록 한다. (PayCalculator, HourReporter, EmployeeSaver)

각 클래스는 서로의 존재를 몰라야한다.

→ 개발자가 세 가지 클래스를 인스턴스화하고 추적해야 한다.

→ 퍼사드 패턴으로 회피 가능

![image](https://user-images.githubusercontent.com/42836576/119272376-875ed500-bc40-11eb-9e85-6ba31ca26b4b.png)

# 결론

SRP는 메서드와 클래스 수준의 원칙이다.