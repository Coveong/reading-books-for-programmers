# 12장. 다형성

상속을 이용하는 목적

- 코드 재사용
- 클라이언트 관점에서 동일하게 행동하는 그룹으로 묶기 위해

→ 코드 재사용의 목적이라면 상속을 사용하지 말자

# 다형성

여러 타입을 대상으로 동작할 수 있는 코드를 작성할 수 있는 방법

- 다형성
    - 유니버셜 다형성
        - 매개변수 다형성
            - 제네릭 프로그래밍과 관련이 높음
            - 타입을 임의의 타입으로 선언한 후 사용 시점에 구체적인 타입으로 지정하는 방식
            - ex. List
        - **포함 다형성**
            - 메시지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 능력
            - 서브타입 다형성이라고도 부름
            - 객체지향에서 가장 널리 알려져있으며, 언급이 없으면 기본적으로 이것을 의미하는 것이다.
    - 임시 다형성
        - 오버로딩 다형성
            - 하나의 클래스 안에 동일한 이름의 메서드가 존재하는 경우 (타입만 다르고!)
        - 강제 다형성
            - 언어가 지원하는 자동적인 타입 변환이나 사용자가 직접 구현란 타입 변환을 이용해 동일한 연산자를 다양한 타입에 사용할 수 있는 방식
            - +의 피연산자가 정수 → 정수에 대한 덧셈 연산자
            - +의 피연산자가 문자열 → 문자열 연결 연산자

# 상속의 양면성

- 데이터 관점의 상속
    - 부모 클래스의 **데이터**를 자식 클래스스에 자동으로 포함시킬 수 있다.
- 행동 관점의 상속
    - 부모 클래스의 **메서드**를 자식 클래스에 포함시킬 수 있다.

상속의 목적은 코드의 재사용이 아니다.

상속은 프로그램을 구성하는 개념들을 기반으로 다형성을 가능하게 하는 타입 계층을 구축하기 위한 것이다.

상속의 매커니즘을 이해하는데 필요한 개념들

- 업캐스팅
- 동적 메서드 탐색
- 동적 바인딩
- self 참조
- super 참조

## 상속을 사용한 강의 평가

동일한 메서드일 때에는 자식 클래스가 실행된다. (우선순위가 더 높음)

자식 클래스 안에 상속받은 메서드와 동일한 시그니처의 메서드를 재정의해서 부모 클래스의 구현을 새로운 구현으로 대체하는 것을 **메서드 오버라이딩**이라고 한다.

부모 클래스에서 정의한 메서드와 이름은 동일하지만 시그니처가 다으면 **메서드 오버로딩**이라고 한다.

## 데이터 관점의 상속

자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스를 포함하는 것

## 행동 관점의 상속

부모 클래스가 정의한 일부 메서드를 자식 클래스의 메서드로 포함시키는 것

# 업캐스팅과 동적 바인딩

## 같은 메시지, 다른 메서드

- 부모 클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는 것이 가능라다. 이를 업캐스팅이라고 부른다.
- 선언된 변수의 타입이 아니라 메시지를 수신하는 객체의 타입에 따라 실행되는 메서드가 결정된다. 이것은 객체지향 시스템이 메시지를 처리할 적절한 메서드를 컴파일 시점이 아니라 실행 시점에 결정하기 때문에 가능하다. 이를 동적 바인딩이라고 부른다.

## 업캐스팅

부모 클래스의 인스턴스 대신 자식 클래스의 인스턴스를 사용할 때 명시적으로 변환하지 않아도 된다.

업캐스팅을 사용하면 미래의 자식 클래스들도 협력에 참여할 수 있다.

```java
Lecture lecture = new GradeLecture(...);
```

## 다운캐스팅

부모 클래스의 인스턴스를 자식 클래스 타입으로 변환할 때 명시적인 타입 캐스팅이 필요하다.

```java
GradeLecture gradeLecture = (GradeLecture)lecture;
```

## 동적 바인딩

- 전통적인 언어에서 함수 실행 방법
    - 함수 호출
    - 호출된 함수를 컴파일타임에 결정
    - 정적 바인딩, 초기 바인딩, 컴파일타임 바인딩
- 객체지향 언어에서 메서드를 실행하는 방법
    - 메시지를 전송하는 것
    - 호출된 함수를 런타임에 결정
    - 동적 바인딩, 지연 바인딩

# 동적 메서드 탐색과 다형성

실행할 메세지 선택 방법

- 메시지를 수신한 객체는 자신을 생성한 클래스에 적합한 메서드가 있는지 검사하고 있으면 실행 후 종료
- 부모 클래스에서 메서드 탐색. 적합한 메서드를 찾을 때 까지 상속 계층을 올라감
- 최상위 클래스에 올라갔는데도 메서드를 발견하지 못하면 예외 발생

## 자동적인 메시지 위임

적절한 메서드를 찾을 때 까지 자식 → 부모로 상속 계층을 따라 올라감

### 메서드 오버라이딩

자식 클래스가 부모 클래스의 메서드를 오버라이딩하면 자식 클래스에서 부모 클래스로 향하는 메서드 탐색 순서 때문에 자식 클래스의 메서드가 부모 클래스의 메서드를 감추게 된다.

### 메서드 오버로딩

자식 클래스가 부모 클래스에 존재하는 메서드와 다른 시그니처를 가진 메서드를 재정의해서 부모 클래스의 메서드와 공존한다.

## 동적인 문맥

self 참조에 따라 검색 상속 계층이 달라진다.

Lecture를 가리키고 있으면 Lecture - Object

GradeLecture를 가리키고 있으면 GradeLecture - Lecture - Object

```java
public class Lecture {
	public String stats() {
		return "-> " + getEvaluationMethod();
	}

	public String getEvaluationMethod() {
		return "Pass or Fail" + result;
	}
}
```

getEvaluationMethod()를 호출하는 것이 아닌, **현재 객체에게 메시지를 전송하는 것이다.**

여기에 상속이 추가되면 혼란을 초래할 수 있다.

```java
public class GradeLecture extends Lecture {
	@Override
	public String getEvaluationMethod() {
		return "Pass" + result;
	}	
}
```

self 전송이 깊은 상속 계층과 계층 중간중간에 함정처럼 숨겨져있는 메서드 오버라이딩과 만나면 극단적으로 이해하기 어려운 코드가 만들어진다.

## 이해할 수 없는 메시지

상속 계층 정상에 오고나서 메시지를 처리할 수 없다는 사실을 알게되면?

### 정적 타입 언어와 이해할 수 없는 메시지

컴파일 에러

### 동적 타입 언어와 이해할 수 없는 메시지

예외 발생

또는 이해할 수 없다는 메시지에 대한 응답 메서드

## self 대 super

super : 지금 이 클래스의 부모 클래스에서부터 메서드 탐색을 시작하세요

self : 메시지를 수신하는 객체의 클래스에 따라 메서드 탐색을 시작하세요

→ 어떤 클래스에서 메시지 탐색이 시작될지 알지 못한다. (실행시점에 동적으로 결정)

# 상속 대 위임

## 위임과 self 참조

자신이 수신한 메시지를 다른 객체에게 동일하게 전달해서 처리를 요청하는 것을 **위임**이라고 한다.