# 12. 다형성



상속의 목적은 코드 재사용 X 타입 계층을 구조화 하기 위해서!



## 01. 다형성



**다형성(Polymorphism)**이란?

일반적인 의미 : 많은 형태를 가질수 있는 능력

CS적 의미 : 하나의 추상 인터페이스에 대해 코드를 작성하고 이 추상 인터페이스에 대해 서로 다른 구현을 연결할 수 있는 능력



다형성의 종류 

- 유니버설(Universal) 다형성
  - 매개변수(Parametric) 다형성
  - 포함(Inclustion) 다형성
- 임시(Ad Hoc) 다형성
  - 오버로딩(Overloading) 다형성
  - 강제(Coercion) 다형성



오버로딩 다형성이란?

- 하나의 클래스 안에 동일한 이름의 메서드가 존재하는 경우를 가리킨다.
- 유사한 작업을 수행하는 메서드의 이름을 통일할 수 있어 이름의 수를 극적으로 줄일 수 있다.

강제 다형성 이란?

- 언어가 지원하는 자동적인 타입 변환이나 사용자가 직접 구현한 타입 변환을 이용해 동일한 연산자를 다양한 타입에 사용할 수 있는 방식

매개변수 다형성이란?

- 제네릭 프로그래밍과 관련이 높은데 클래스의 인스턴스 변수나 메서드의 매개변수 타입을 임의의 타입으로 선언한 후 사용하는 시점에 구체적인 타입으로 지정하는 방식을 가리킨다.

포함 다형성이란?

- 메시지가 동일하더라도 수신한 객체 타입에 따라 실제로 수행되는 행동이 달라지는 능력
- 포함 다형성은 서브타입 다형성이라고도 부른다   -> 포함 다형성의 전제조건은 자식 클래스가 부모 크랠스의 서브타입이어야 한다는 것이다.
- 언급이 없다면 가장 노멀한 다형성

포함 다형성을 사용하는 이유

- 클래스들을 께층으로 쌓아 올린 후 상황에 따라 적절한 메서드를 선택할 수 있는 메커니즘을 제공하기 때문이다.



## 02. 상속의 양면성



메커니즘을 이해하는데 필요한 몇 가지 개념

- 업캐스팅
- 동적 메서드 탐색
- 동적 바인딩
- self 참조
- super 참조



Super 는  부모 클래스를 가리키도록 설정된 변수이며 일반적으로 자식 클래스 내부에서 부모 크랠스의 인스턴스 변수나 메서드에 접근하는 데 사용된다.

> 정확히 말하면 가시성이 public이나 protec인 인스턴스 변수와 메서드만 접근 가능



실제 쓰이는 메서드 오버라이딩 

- 자식 클래스 안에 상속받은 메서드와 동일한 시그니처의 메서드를 재정의해서 부모 클래스의 구현을 새로운 구현으로 대체하는 것

실제 쓰이는 메서드 오버로딩

- 부모 클래스에서 정의한 메서드와 일므은 동일하지만 시그니처는 다른 메서드를 자식클래스에 추가하는 것



#### 데이터 관점의 상속

데이터 관점에서 상속 = 자식 크랠스의 인스턴스 안에 부모 클래스의 인스턴스를 포함하는 것



#### 행동 관점의 상속

부모 클래스가 정의한 이부 메서드를 자식 클래스의 메서드로 포함시키는 것



부모 클래스에서 구현한 메서드를 자식 클래스 인스턴스 에서 수행할수 있는 것일까?

- 런타임 시스템이 자식 크랠스에 저으이되 않은 메서드가 있을 경우 이 메서드를 부모 클래스 안에서 탐색하기 때문이다.





## 03. 업캐스팅과 동적 바인딩



#### 같은 메세지, 다른 메서드



업캐스팅이란?

- 부모 클래스타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당하는 것이 가능

동적바인딩이란?

- 선언된 변수의 타입이 아니라 메시지를 수신하는 객체의 타입에 따라 실행되는 메서드가 결정되는데 이것은 객체지향 시스템이 메시지를 처리할 적절한 메서드를 컴파일 시점이 아니라 실행 시점에서 결정하는 것



**업캐스팅과 동적 메서드 탐색을 읽다보면  개방 -폐쇄 원칙의 의도 와 비슷하고 느껴진다!**

개방 - 폐쇄 원칙 - 목적

업캐스팅, 동적 메서드 탐색 -목적에 으르는 방법



#### 업캐스팅

![image-20210411144303642](C:\Users\user.DESKTOP-MH5KDIR.000\AppData\Roaming\Typora\typora-user-images\image-20210411144303642.png)

#### 동적 바인딩

코드를 작성하는 시점에 코드가 결정되고 컴파일타임에 호출할 함수를 결정하는 방식을 **정적바인딩,초기바인딩, 커파일타임 바인딩**이라고 부른다.

실행될 메서드를 런타임에 결정하는 방식은 **동적 바인딩,지연 바인딩** 이라고 부른다.



## 04. 동적 메서드 탐색과 다형성



객체지향 시스템 규칙

- 메시지를 수신한 객체는 먼저 자신을 생성한 크랠스에 적합한 메서드가 존재하는지 검사하고 실행하고 종료한다.
- 메서드를 찾지 못했다면 부모 클래스에서 탐색을 계쏙한다.
- 상속 계층의 가장 최상위 클래스에 이르렀지만 발견 못하면 예외 후 종료한다.



> self 와 this
>
> > 정적 타입 언어는 self 참조를 this라고 부른다. 동적 타입 언어는 self 라고 하며 참조 의 이름을 임의로 정할 수 있지만 대부분은 self라는 이름을 사용한다.



메서드 탐색의 두가지 원리

- 자동적인 메시지 위임 : 자식 클래스는 자신이 이해할 수 없는 메시지를 전송받은 경우 상속 계층을 따라 부모 클래스에 처리를 위임한다.
- 동적인 문맥 사용 : 메시지를 수신했을 때 실제  메서드를 실행할 지는 컴파일 시점이 아닌 실행시점이며 self 참조를 이용해서 결정한다.

#### 자동적인 메시지 위임

핵심 : 적절한 메서드를 찾을 때까지 상속 계층을 따라 부모 클래스로 처리가 위임된다.



##### 메서드 오버라이딩

자식 클래스가 부모 클래스의 메서드를 오버라이딩하면 자식 크랠스에서 부모 클래스로 향하는 메서드 탐색 순서 때문에 자식 크랠스의 메서드가 부모 클래스의 메서드를 감추게 된다.

##### 메서드 오버로딩

동일한 이름의 메서드가 공존하는 경우를 이른다.



#### 동적 타입 언어와 이해할 수 없는 메시지



동적 타입의 언어는 이해할 수 없는 메시지를 처리할 수 있는 능력을 가짐으로써 메시지가 선언된 인터페이스와 메서드가 정의된 구현을 분리할 수 있다.



#### self 대 super 

self : 동적메시지를 수신한 객체의 크랠스에 따라 메서드 탐색츨 위한 문맥을 실행 시점에서 결정한다.

super :  부모 클래스의 인스턴스에게 메시지를 전송하는것처럼 보이는 것

​				부모 클래스에서 부터 메서드 탐색을 시작한다.



## 05. 상속 대 위임

위임이란?

자신이 수신한 메시지를 다른 객체에게 동일하게 전달해서 처리를 요청하는 것



프로토 타입 언어처럼 위임을 통해 객체 수준에서 상속을 구현하는 언어도 있다.



중요한것은 클래스 기반의 상속과 객체기반의 위임 사이에 기본 개념과 메커니즘을 공유한다는 점이다.



















