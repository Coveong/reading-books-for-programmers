# 객체, 설계

이론이 먼저일까? 실무가 문저일까? 

> 로버트 L. 글래스: 어떤 분야든 초기 단계에서는 실무를 관찰한 결과를 바탕으로 이론을 정립하는 것이 최선이다.

이 책에서는 객체지향 패러타임을 설명하기 위해 추상적인 개념이나 이론을 앞세우지 않고 코드를 이용해 설명할 것이다.

## 티켓 판매 애플리케이션 구현하기

티켓을 판매하는 애플리케이션을 구현해보자. 다만 다음 요구사항이 존재한다:
```
이벤트에 당첨된 관람객과 그렇지 못한 관람객은 다른 방식으로 입장시켜야 한다
```
(코드 생략)

## 문제점 파악하기

로버트 마틴에 따르면
* 모든 모듈은 제대로 실행돼야 하고
* 변경에 용이해야 하며
* 이해하기 쉬워야 한다

위에서 구현한 코드는 예상을 빗나가며, 변경에 취약하다는 단점이 있다.

### 의존성

객체지향 설계는 서로 의존하면서 협력하는 객체들의 공동체를 구축하는 것이다.
우리의 목표는 애플리케이션의 기능을 구현하는데 필요한 최소한의 의존성만 유지하고 불필요한 의존성은 제거해야 한다.

### 결합도

객체 사이의 의존성이 과한 경우를 가리켜 결합도가 높다고 말한다. 설계의 목표는 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만드는 것이여야 한다.

## 코드 개선하기

각각의 객체(판매원, 관람객)가 자율적인 존재가 되도록 설계를 변경한다.

### 캡슐화

개념적이나 물리적으로 세부적인 사항을 감추는 것을 캡슐화라고 한다. 변경하기 쉬운 객체를 만드는 것이 목적이다.

캡슐화를 통해 객체와 객체 사이의 결합도를 낮출 수 있으므로 설계를 좀 더 쉽게 변경할 수 있다.

객체를 인터페이스와 구현으로 나누고 인터페이스만 공개하는 것은 가장 기본이다.

### 응집도

밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 응집도가 높다고 말한다.

객체의 응집도를 높이기 위해서는 객체 스스로 자신의 데이터를 책임져야 한다.

### 결론

외부의 간섭을 최대한 배제하고 메시지를 통해서만 협력하는 자율적인 객체들의 공동체를 만드는 것이 훌륭한 객체지향 설계를 얻을 수 있는 지름길이다.

## 절차지향과 객체지향

근본적인 차이는 '책임의 이동'이다. 객체지향 설계의 핵심은 적절한 객체에 적절한 책임을 할당하는 것이다.

### 절차지향

프로세스와 데이터를 별도의 모듈에 위치시키는 방식

* 각각의 객체가 수동적인 존재가 된다.
* 의존성이 꼬여 있다.
* 변경에 취약하다.

### 객체 지향

데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식

* 캡슐화를 이용해 의존성을 철저히 관리함으로써 객체 사이의 결합도를 낮추는 것이 핵심이다. 
  * 변경에 유연한 이유다.
* 자신의 문제를 스스로 처리하므로 이해하기 쉽다.
* 객체 내부의 변경이 객체 외부에 파급되지 않도록 제어할 수 있다.

### 요약

설계를 어렵게 만드는 것은 **의존성**, 불필요한 의존성을 제거함으로써 객체 사이의 **결합도**를 낮춰 해결할 수 있다. 
이때 **캡슐화**를 통해 결합도를 낮출 수 있다. -> 객체의 **자율성**을 높이고 **응집도** 높은 객체들의 공동체를 창조할 수 있게 한다.

## 객체지향 설계

1. 어떤 기능을 설계할 수 있는 방법은 한 가지 이상일 수 있다.
2. 동일한 기능을 한 가지 이상의 방법으로 설계할 수 있기 때문에 결국 설계는 트레이드오프의 산물이다.

### 좋은 설계란

* 오늘 완성해야 하는 기능을 구현하는 코드를 짜야 하는 동시에
* 내일 쉽게 변경할 수 있는 코드를 짜는 것

요구사항 변경은 필연적으로 코드 수정을 초래하고 코드 수정은 버그가 발생할 가능성을 높인다.

### 결론

즉, 변경에 유연하게 대처할 수 있는(= 이해하기 쉬운 코드)를 짜야 한다.

객체 간의 의존성은 애플리케이션을 수정하기 어렵게 만드는 주범이다.
