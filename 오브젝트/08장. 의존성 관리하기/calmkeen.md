# 08.의존성 관리하기

작고 응집도 높은 객체란?

- 책임의 초점이 명확하고 한 가지 일만 잘 하는 객체



## 01. 의존성 이해하기

### 변경과 의존성

 의존성

- 실행 시점 : 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다.
- 구현 시점 : 의존 대상 객체가 변경될 경우 의존하는 객체도 변경된다.
- 

의존성이 존재한다 -> 어떤 객체가 예저오딘 작업을 정상저으로 수행하기 위해 다른 객체를 필요로 하는 경우

의존성은 방향성을 가지며 항상 단반향이다.



UML과 의존성

- 실체화 관계
- 연관관계
- 의존 관계
- 일봔화/특수화 관계
- 합성 관계
- 집합 관계



의존성 전이

![image-20210405015038542](https://user-images.githubusercontent.com/78361650/115144294-e7cd8600-a086-11eb-9627-d47017f30caa.png)

의존성의 종류

- 직접 의존성(direct dependency)
- 간접 의존성(indirect dependency)



### 런타임 의존성과 컴파일타임 의존성

**런타임 의존성**과 **컴파일타임 의존성**

런타임 - 애플리케이션이 실행되는 시점

컴파일 타임 -작성된 코드를 컴파일하는 시점 or (문맥에 따라) 코드 자체



컴파일 의존성이 중요시 하는 것

- 시간이 아니라 작성한 코드의 구조이기 때문이다.



런타임 의존성과 컴파일타임 의존성이 다를 수 있다.

사실 유언하고 재사용 가능한 코드를 설계하기 위해서는 두 종류의 의존성을 서로 다르게 만들어야 한다.

컴파일 구조와 런타임 구조 사이의 거리가 멀면 멀수록 설계가 유연해지고 재사용 가능해진다.



### 컨텍스트 독릭성

컨텍스트 독립성

- 클래스가  특정한 문맥에 강하게 결합될수록 다른 문맥에서 사용하기는 더어려워 진다.
- 클래스가 사용 될 특정한 문맥에 대해 최소한의 가정만 이뤄져 있따면 다른 문맥에서 재사용하기가 수월하다.



### 의존성 해결하기



의존성을 해결하기 위해서 사용하는 방법

- 객체를 생성하는 시점에 생성자를 통해 의존성 해결
- 객체 생성 후 setter메서드를 통해 의존성 해결
- 메서드 실행 시 인자르 이용해 의존성 해결



## 02 .유연한 설계



### 의존성과 결합도

바람직한 의존성

- 재사용성
- 다양한 환경
- 특정 컨텍스트에 강하게 결합되지 않음 
- 컨텍스트에 독립적인 의존성을 의미



바람직함 - 느슨함/약함 결합도

바람직하지 않음 - 단단한/ 강한 결합도



### 추상화에 의존하라

추상화란?

- 양상, 세부사항, 구조를 좀더 명확하게 이해하기 위해 절차나 물체를 의도적으로 생략하거나 감춰 복잡도를 극복하는 방법

추상화의 의존 대상이 결합도가 낮아지는 목록 (아래로 갈수록 낮아짐)

- 구체 클래스 의존성
- 추상 클래스 의존성
- 인터페이스 의존성



결합도를 느슨하게 만들기 위해 구체적인 클래스보다 추상 클래스에 추상 클래스 보다 인터페이스에 의존하도록 하는것이 효과적이다.

정리 : 의존 대상이 추상적일수록 결합도는 낮아진다.



### 명시적인 의존성

- 명시적인 의존성이란?

모든 경우에 의존성은 명시적으로 퍼블릭 인터페이스에 노출되는 것

- 숨겨진 의존성이란?

의존성이 퍼블릭 인터페이스에 표현되지 않는 것



의존성이 명시적이지 않으면 파악하기 위해 내부구현부를 살펴볼수 밖에 없고 클래스 정의된 긴 메서드를 코드파악하는 건 어렵다. 그러므로 의존성은 밝은 곳으로 드러내서 널리 알리고 사용해야 유연하고 재사용이 가능해 진다.



### New 해롭다.

new연산자를 사용하기 위해서는 구체 클래스의 구체 클래스의 이름을 직접 기술해야한다. 

- 클래스에 의존해 결합도가 높아지기 때문에

어떤 인자를 이용해 클래스의 생성자를 호출하는지 알아야한다.

- 클라이언트 지식양이 늘어나 결합도가 높이지기 때문



정리

올바른 객체가 올바른 책임을 수행하게 하는것

- 사용과 생성의 책임을 분리
- 의존성을 생성자에 명시적으로 드러냄
- 구체 클래스가 아닌 추상 클래스에 의존하게 함으로써 설계를 유연하게 만든다.



### 조합가능한 행동

어떤 객체와 협력하는냐에 따라 객체의 행동이 달라지는 것은 유연하고 재사용 가능 설계의 특징

훌륭한 객체지향 설계란?

- 객체가 어떻게 하는지를 표현하는 것이 아니라 객체들의 조합을 선언적으로 표현함으로써 객체들이 무엇을 하는지를 표현하는 설계다.

핵심! - 의존성 관리
