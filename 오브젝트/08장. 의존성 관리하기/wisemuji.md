# 의존성 관리하기

객체지향 설계의 핵심은 협력을 위해 필요한 의존성은 유지하면서도 변경을 방해하는 의존성은 제거하는 것이다.

### 변경과 의존성

어떤 객체가 협력하기 위해 다른 객체를 필요로 할 때 두 객체 사이에 의존성이 존재하게 된다.

* 실행 시점: 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 함
* 구현 시점: 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경됨

### 의존성 전이

의존성은 전이될 수 있다. (모든 경우는 아님) A -> B 의존 관계일 때 B가 의존하는 것에 대해 A도 의존할 수 있다.

의존성의 종류를 직접 의존성과 간접 의존성으로 나눌 수 있는데 의존성 정의는 후자에 속한다.

### 런타임 의존성과 컴파일 타임 의존성

어느 클래스의 인스턴스가 다양한 클래스의 인스턴스와 협력하기 위해서는 협력할 인스턴스의 구체적인 클래스를 알아서는 안된다. -> 런타임에 알아야 한다.

런타임 구조와 컴파일 타임 구조가 멀수록 설계가 유연해지고 재사용 가능해진다

### 컨텍스트 독립성

컨텍스트 독립성: 클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이루어져 있다면 다른 문맥에서 재사용하기가 더 수월해진다.

설계가 더 유연해지기 위해서는 컨텍스트에 대한 구체적인 정보를 최대한 적게 알아야 함

> 시스템을 구성하는 객체가 컨텍스트 독립적이라면 시스템은 변경하기 쉽다

### 의존성 해결하기

의존성 해결: 컴파일 타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것

* 객체를 실행하는 시점에 생성자를 통해 의존성 해결
* 객체 생성 후 setter 메소드를 이용해 의존성 해결
* 메서드 실행 시 인자를 이용해 의존성 해결

## 유연한 설계

### 의존성과 결합도

의존성이 바람직한지 확인할 수 있는 방법: 어떤 의존성이 다양한 환경에서 클래스를 재사용할 수 없도록 제한한다면 그 의존성은 바람직하지 못하다. 

== 즉, 컨텍스트에 독립적인 의존성은 바람직하다.

어떤 두 요소 사이에 존재하는 의존성이 바람직할 때 두 요소가 느슨한 결합도를 가진다고 말한다. (반대로 바람직하지 못하면 강한 결합도)

### 지식이 결합을 낳는다

서로에 대해 알고 있는 지식의 양이 결합도를 결정한다. 더 많이 알고 있다는 것은 더 적은 컨텍스트에서 재사용 가능하다는 것을 의미한다.

결합도를 느슨하게 유지하고 싶으면 협력하는 대상에 대해 필요한 정보 외에는 감추자

### 추상화에 의존하라

추상화와 결합도의 관점에서 의존 대상을 다음과 같이 분리하자

* 구체 클래스 의존성
* 추상 클래스 의존성
* 인터페이스 의존성

### 명시적인 의존성

의존성은 명시적으로 표현되어야 한다. (퍼블릭 인터페이스를 통해)

### new는 해롭다

* new 연산자를 사용하기 위해서는 구체 클래스의 이름을 직접 기술해야 함 -> 결합도가 높아짐
* new 연산자는 생성하려는 구체 클래스뿐만 아니라 어떤 인자를 이용해 생성자를 호출해야 하는지도 알아야 함 -> 결합도가 높아짐

사용과 생성의 책임을 분리하고 의존성을 생성자에 명시적으로 드러내고 구체 클래스가 아닌 추상 클래스에 의존하기 하자.

### 가끔은 생성해도 무방하다

주로 협력하는 기본 객체를 설정하고 싶을 때

### 표준 클래스에 대한 의존은 해롭지 않다.

### 컨텍스트 확장하기

### 조합 가능한 행동

유연하고 재사용 가능한 객체는 작은 객체들의 행동을 조합하므로써 새로운 행동을 이끌어낼 수 있는 설계다. 

객체가 어떻게 하는지를 표현하는 것이 아니라 객체들의 조합을 선언적으로 표현하므로써 객체들이 무엇을 하는지를 표현하는 설계가 훌륭한 객체지향 설계다. -> 의존성 관리가 핵심

