# 08장. 의존성 관리하기

# 의존성 이해하기

## 변경과 의존성

한 객체가 협력을 위해 다른 객체를 필요로 할 때, **의존성**이 생긴다.

- 실행 시점 : 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다.
- 구현 시점 : 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다.

의존성은 항상 단방향이다.

의존성은 변경에 의한 영향의 전파 가능성을 암시한다.

## 의존성 전이

- PeriodCondition이 Screening에게 의존한다.
    - 직접 의존성
- Screening은 Movie에게 의존한다.
    - 직접 의존성
- PeriodCondition은 Movie에게 의존하게 된다.
    - **의존성 전이**
    - 간접 의존성

## 런타임 의존성과 컴파일타임 의존성

- 런타임 의존성
    - 애플리케이션이 실행되는 시점의 의존성
    - **객체**가 주인공이다.
- 컴파일 타임 의존성
    - 컴파일하는 시점의 의존성
    - 우리가 작성한 코드를 중요하게 생각함 (시간이 아니라!)
- **클래스**가 주인공이다.

런타임 의존성과 컴파일 의존성이 달라질 수도 있음

- Movie → DiscountPolicy (컴파일)
- Movie → PercentDisountPolicy extends DiscountPolicy (런타임)

협력할 인스턴스의 구체적인 클래스는 컴파일 타임에 모르는 것이 좋다. 실제로 협력할 객체는 런타임 때 아는것이 좋다. → **컴파일타임 구조와 런타임 구조 사이의 거리가 멀면 멀수록 좋다.**

## 컨텍스트 독립성

걱각 객체가 해당 객체를 실행하는 시스템에 관해 아무것도 알지 못한다는 의미

→ 다양한 컨텍스트에 적용할 수 있는 응집력 있는 객체를 만들고 객체 구성 방법을 재설정해서 변경 가능한 시스템으로 나아갈 수 있다.

## 의존성 해결

컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것

- 객체를 생성하는 시점에 생성자를 통한 의존성 해결
- 객체 생성 후 setter 메서드를 통한 의존성 해결
    - 객체를 생성한 이후에도 의존할 수 있는 대상을 변경할 때 유용하다.
    - 단, 객체 상태가 불완전해질 수 있다.
- 메서드 실행 시 인자를 이용한 의존성 해결
    - 지속적으로 의존 관계를 맺을 필요가 없을 때 유용하다. (일시적으로만 사용할 때)

→ 생성자를 통해 의존성을 해결하고, 필요에 따라 setter를 사용하면 좋다.

# 유연한 설계

## 의존성과 결합도

바람직한 의존성은 **재사용성**에 관련이 있다.

다양한 환경에서 재사용이 가능하다면 그 의존성은 바람직한 것이다.

= 컨텍스트에 독립적인 의존성은 바람직한 의존성이다.

= 느슨한 결합도, 약한 결합도를 가진다.

특정 컨텍스트에 강하게 결합된 의존성은 바람직하지 않은 의존성이다.

= 단단한 결합도, 강한 결합도를 가진다.

## 지식이 결합을 낳는다

한 요소가 다른 요소에 대해 더 많은 정보를 알고 있을 수록 두 요소는 강하게 결합된다.

한 요소가 다른 요소에 대해 더 적은 정보를 알고 있을 수록 두 요소는 약하게 결합된다.

= 서로에 대해 알고 있는 지식의 양이 결합도를 결정한다.

## 추상화에 의존하라

특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법

다루고 있는 문제를 해결하는 데 불필요한 정보를 감출 수 있다.

목록에서 아래로 갈수록 클라이언트가 알아야 하는 지식의 양이 적어진다.

- 구체 클래스 의존성
- 추상 클래스 의존성
- 인터페이스 의존성

😯 추상 클래스 의존성보다 인터페이스 의존성이 더 알아야 하는 양이 많은 이유?

→ 추상 클래스는 클라이언트가  협력하는 대상이 속한 클래스 상속 계층이 무엇인지 알고 있어야해서

의존하는 대상이 더 추상적일수록 결합도는 더 낮아진다.

## 명시적인 의존성

```java
class Movie {
	public Movie(String title, Money fee) {
		...
		this.discountPolicy = new AmountDiscountPolicy();
	}
}
```

추상 클래스(DiscountPolicy)와 구체 클래스(AmountDiscountPolicy) 모두에게 의존하고 있다. 

→ 의존성이 숨겨져있다. 이를 **숨겨진 의존성**이라고 한다. (반대 - 명시적인 의존성)

숨겨진 의존성의 단점

1. 내부 구현을 살펴봐야 한다.
2. 다른 컨텍스트에서 재사용하기 위해 내부 구현을 직접 변경해야 한다.

숨겨져 있는 의존성을 밝은 곳으로 드러내서 널리 알려라, 그렇게 하면 설계가 유연해지고 재사용 가능해 질 것이다.

## new는 해롭다

- new 연산자를 사용하기 위해서는 구체 클래스의 이름을 직접 기술해야한다.

    → 결합도가 높아진다.

- 또한 어떤 인자를 이용해 클래스의 생성자를 호출해야 하는지도 알아야한다.

    → 결합도가 높아진다.

인스턴스를 생성하는 로직과 생성된 인스턴스를 사용하는 로직을 분리하자

```java
// X
public Movie(String title, Duration runningTime, Money fee) {
	...
	thos.discountPolicy = new AmountDiscountPolicy(...);
}

// O
public Movie(String title, Duration runningTime, Money fee, DiscountPolicy discountPolicy) {
	...
	this.discountPolicy = discountPolicy;
} // AmountDiscountPolicy를 호출하는 책임은 Movie의 클라이언트로!

```

- 사용과 생성의 책임을 분리한다.
- 의존성을 생성자에 명시적으로 드러낸다.
- 구체 클래스가 아닌 추상 클래스에 의존하게 함으로써 설계를 유연하게 만든다.

## 가끔은 생성해도 무방하다

주로 협력하는 기본 객체를 설정하고 싶은 경우!

## 표준 클래스에 대한 의존은 해롭지 않다

변경될 확률이 거의 없는 클래스는 의존성이 문제가 되지 않는다. (ex. ArrayList)

## 컨텍스트 확장하기

설계를 유연하게 만들 수 있었던 이유

- Movie가 DiscountPolicy라는 추상화에 의존하고,
- 생성자를 통해 DiscountPolicy에 대한 의존성을 명시적으로 드러냈으며,
- new와 같이 구체 클래스를 직접적으로 다뤄야 하는 책임을 Movie 외부로 옮겼기 때문에

→ 결합도가 낮아짐

## 조합 가능한 행동

유연하고 재사용 가능한 설계는 작은 객체들의 행동을 조합하으로써 새로운 행동을 이끌어낼 수 있는 설계다.

훌륭한 객체지향 설계란 객체가 어떻게 하는지를 표현하는 것이 아니라 객체들의 조합을 선언적으로 표현함으로써 객체들이 무엇을 하는지를 표현하는 설계다.

설계를 창조하는 데 있어서 핵심은 의존성 관리이다.