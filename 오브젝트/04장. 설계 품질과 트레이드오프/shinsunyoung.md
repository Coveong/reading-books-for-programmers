# 04장. 설계 품질과 트레이드오프

# **설계 품질과 트레이드 오프**

객체지향 애플리케이션의 전체 품질을 결정하는 것은 **책임**이다.

객체지향 설계란 올바른 객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동이다.

1. 객체지향의 설계의 핵심은 책임이다.
2. 책임을 할당하는 작업이 응집도와 결합도 같으 설계 품질과 깊게 연관되어 있다.

### **훌륭한 설계**

합리적인 비용 안에서 변경을 수용할 수 있는 구조를 만드는 것 -> 객체의 책임과 행동에 초점을 맞추면 좋다.

# **데이터 중심의 영화 예매 시스템**

시스템을 객체로 분할하는 방법

1. 상태를 분할의 중심축으로 삼는 방법
2. 책임을 분할의 중심축으로 삼는 방법

상태 == 데이터

데이터 중심의 관점 : 객체의 상태에 초점을 맞춘다. (객체를 **독립된 데이터 덩어리**로 바라본다.)

- 구현에 관한 세부사항이 객체의 인터페이스에 스며들게 되어 캡슐화의 원칙이 무너진다.

책임 중심의 관점 : 객체의 행동에 초점을 맞춘다. (객체를 **협력하는 공동체의 일원**으로 바라본다.)

- 책임을 드러내는 한정적인 인터페이스 뒤로 책임을 수행하는 데 필요한 상태를 캡슐화함으로써 구현 변경에 대한 파장이 외부로 퍼져나가는 것을 방지한다.

## **데이터 준비**

변수(movieType)과 인스턴스 종류에 따라 배타적으로 사용될 인스턴스 변수(discountAmount, discountPercent)를 하나의 클래스 안에 함께 포함시키는 방식은 데이터 중심의 설계 안에서 흔히 볼 수 있는 패턴이다.

# 설계 트레이드 오프

## 캡슐화

- 구현
    - 변경될 가능성이 높은 부분
- 인터페이스
    - 상대적으로 변경될 가능성이 낮은 부분

→ 객체 설계의 가장 기본적인 아이디어는 변경의 정도에 따라 구현과 인터페이스를 분리하고, 외부에서는 인터페이스에만 의존하도록 관계를 조절하는 것

- 캡슐화
    - 변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기법
        - 변경될 수 있는 어떤 것이라도 캡슐화해야한다.
    - 불안정한 부분과 안정적인 부분을 분리해서 변경의 영향을 통제할 수 있다.

## 응집도와 결합도

- 응집도
    - 모듈에 포함된 내부 요소들이 연관되어 있는 정도
    - 모듈의 요소들이 하나의 목표를 위해 긴밀하게 협력하고, 하나의 변경을 수용하기 위해 모듈 전체가 함께 변경된다면?  → **높은 응집도**
    - 모듈의 요소들이 각각 다른 목표를 추구하고, 하나의 변경에 대해 모듈의 일부분만 변경된다면? → **낮은 응집도**
- 결합도
    - 다른 모듈에 대해 얼마나 많은 지식을 가지고 있는지를 나타내는 정도
    - 하나의 변경에 대해 많은 모듈이 변경된다면? → **높은 결합도**
        - 변경 확률이 매우 낮은 안정적 모듈에 의존하는 것은 괜찮다. (ex. String, ArrayList) 직접 작성한 코드는 해당 X
    - 하나의 변경에 하나의 모듈만 영향을 받는다면? → **낮은 결합도**
        - 구현이 아닌 인터페이스에 의존해야 얻을 수 있다.

→ 우리는 **높은 응집도, 낮은 결합도**를 추구해야한다.

캡슐화를 지키면 모듈 안의 응집도는 높아지고, 모듈 사이의 결합도는 낮아진다.

캡슐화를 위반하면 모듈 안의 응집도는 낮아지고, 모듈 사이의 결합도는 높아진다.

# 데이터 중심의 영화 예매 시스템의 문제점

- 캡슐화 위반
- 높은 결합도
- 낮은 응집도

## 캡슐화 위반

```java
public class Movie {
	private Money fee;
	
	public Money getFee() {
		return fee;	
	}

	public Money setFee(Money fee) {
		this.fee = fee	
	}
}
```

🧐  직접 객체 내부에 접근할 수 없는 것이기 때문에 캡슐화를 지킨게 맞지 않나요?

🤓 접근자, 수정자 메서드는 캡슐화라고 볼 수 없다. `Money` 타입의 `fee`라는 변수가 안에 존재한다는 것을 나타내고 있기 때문이다.

이러한 **추측에 의한 설계 전략**은 피하는 것이 좋다.

## 높은 결합도

객체의 내부 구현을 변경하면 인터페이스에 의존하는 클라이언트도 함께 변경해야 한다.

(ex. `fee`의 타입을 변경하게 되면 이를 호출하고 있는 클라이언트의 변경도 함께 일어난다.)

시스템이 **거대한 의존성 덩어리**가 되어, 조금의 변경이 일어나도 시스템 전체가 요동치게 된다.

## 낮은 응집도

- 변경과 아무 상관 없는 코드들이 영향을 받는다.
    - ex. ReservationAgency 안에 할인 정책을 선택하는 코드, 할인 정책을 판단하는 코드가 함께 존재하기 때문에 새로운 할인 정책을 추가하면 코드에 영향을 미친다.
- 하나의 요구사항 변경을 반영하기 위해 동시에 여러 모듈을 수정해야 한다.
    - ex. 새로운 할인 정책을 추가해야한다면?
        1. MovieType에 새로운 할인 정책을 추가
        2. ReservationAgency `reserve()`의 switch문에 case를 추가해야한다. 
        3. Movie에 새로운 할인 정책에 따라 할인 요금을 계산하기 위해 필요한 데이터를 추가해야한다.

→ 어떤 요구사항의 변경을 수용하기 위해 하나 이상의 클래스를 수정해야한다는 것은 응집도가 낮다는 것이다.

```java
<단일 책임 원칙>
SRP의 '책임'은 '변경의 이유'라는 의미로 사용된다.
즉, 이 책에서 말하는 '책임'과는 다르다. 
```

# 자율적인 객체를 향해

## 캡슐화를 지켜라

객체는 스스로의 상태를 책임져야 하며, 외부에서는 인터페이스에 정의된 메서드(접근자, 수정자X)를 통해서만 상태에 접근할 수 있어야 한다.

### 약한 캡슐화의 문제

1. 코드 중복의 가능성 O
2. 변경에 취약함

## 스스로 자신의 데이터를 책임지는 객체

- 이 객체가 어떤 데이터를 포함해야 하는가?
    1. 이 객체가 어떤 데이터를 포함해야 하는가?
    2. 이 객체가 데이터에 대해 수행해야하는 오퍼레이션은 무엇인가?

# 하지만 여전히 부족하다

## 캡슐화 위반

```java
public class DiscountCondition {
	private DiscountConditionType type;
	private int sequence;
	private DatOfWeek dayOfWeek;
	private LocalTime startTime;
	private LocalTime endTime;

	public DiscountCondiationType getType() {...}
	public boolean isDiscountable(DayOfWeek dayOfWeek, LocalTime time) {...}
	public boolean isDiscountable(int sequence) {...}
}
```

- isDiscountable(DayOfWeek dayOfWeek, LocalTime time)
    - 객체가 DayOfWeek, LocalTime 타입의 변수를 가지고 있다는 것을 드러내고 있다.
- isDiscountable(int sequence)
    - 객체가 int 타입의 변수를 포함하고 있다는 것을 드러내고 있다.

→ 만약 자료형이 DayOfWeek에서 다른것으로 변경되면? 다른 곳에도 영향을 끼치게 된다. (파급 효과)

```java
public class Movie {
	// 생략
	
	public Money calculateAmountDiscountedFee() {...}
	public Money calculatePercentDiscountedFee() {...}
	public Money calculateNoneDiscountedFee() {...}
}
```

- 할인 정책의 종류에 금액 할인 정책, 비율 할인 정책, 미적용의 세 가지가 존재한다는 사실을 드러내고 있다.
    - 할인 정책 추가? → 클라이언트가 영향을 받음

### 캡슐화의 진정한 의미

- 변할 수 있는 것은 어떤 것이라도 감추는 것이다.

## 높은 결합도, 낮은 응집도

한 파일에서 변경이 일어나면(Movie), 다른 파일에서도 변경이 일어난다.(DiscountCondition)

# 데이터 중심 설계의 문제점

- 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요한다.
- 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.

## 데이터 중심 설계는 객체의 행동보다는 상태에  초점을 맞춘다

너무 이른 시기에 데이터에 대해 고민하기 때문에 **캡슐화에 실패하며,**

객체의 내부 구현이 객체의 인터페이스를 어지럽히고 객체의 응집도와 결합도에 나쁜 영향을 미치기 때문에 **변경에 취약한 코드를 낳게된다.**

## 데이터 중심 설계는 객체를 고립시킨 채 오퍼레이션을 정의하도록 만든다

올바른 객체지향 설계의 무게 중심은 객체 내부가 아닌 외부에 맞춰져있어야한다.

객체 내부 상태, 상태 관리보다는 **다른 객체와 협력하는 방법이 더 중요하다.**

객체의 인터페이스에 구현이 노출되어있으면 협력이 구현 세부사항에 종속되게 된다.