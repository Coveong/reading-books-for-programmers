# 설계 품질과 트레이드오프

역할, 책임 협력 중 가장 중요한 것은 '책임'

책임은 객체의 상태에서 행동으로, 나아가 객체와 객체 사이의 상호작용으로 설계 중심을 이동시키고 결합도가 낮고 응집도가 높으며 구현을 효과적으로 캡슐화하는 객체들을 창조할 수 있는 기반을 제공한다.

## 데이터 중심 vs 책임 중심

객체지향 설계에서 시스템을 객체로 분할하는 두 가지 방법
* 상태(데이터)를 분할의 중심축으로 삼는 방법
* 책임을 분할의 중심축으로 삼는 방법

훌륭한 객체지향 설계는 데이터가 아니라 책임에 초점을 맞춰야 한다.

데이터에 초점을 맞추면 변경에 취약해지기 때문.

### 데이터 중심의 설계

객체가 포함해야하는 데이터에 집중한다. 구현하는 데에 필요한 데이터는 무엇일까를 고민한다.

### 캡슐화

캡슐화: 변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기번. 변경될 수 있는 어떤 것이라도 캡슐화해야 한다.

### 응집도와 결합도

* 응집도: 모듈에 포함된 내부 요소들이 연관돼있는 정도. 
  * 변경의 관점에서: 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도

* 결합도: 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타낸다
  * 변경의 관점에서: 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도

## 데이터 중심의 설계의 문제점(캡슐화, 응집도와 결합도 측면에서)

### 캡슐화 위반

접근자와 수정자에 과도하게 의존하게 된다. (추측에 의한 설계 전략이라고도 부름)

객체가 사용될 협력을 고려하지 않고 객체가 다양한 상황에서 사용될 수 있을 것이라는 막연한 추측을 기반으로 설계를 진행함

### 높은 결합도

객체 내부의 구현이 객체의 인터페이스에 드러나게 되고 클라이언트가 구현에 강하게 결합된다.

시스템을 하나의 거대한 의존성 덩어리로 만들어버리기 때문에 어떤 변경이라도 발생하면 시스템 전체가 요동친다.

### 낮은 응집도

변경의 이유가 서로 다른 코드들을 하나의 모둘 안에 뭉쳐높았기 때문에 변경과 상관 없는 코드들이 영향을 받게 된다.

하나의 요구사항 변경을 반영하기 위해 동시에 여러 모듈을 수정해야 한다.

## 자율적인 객체를 향해

### 캡술화를 지켜라

캡슐화를 강화시켜서 코드 중복을 제거하고 변경에 취약한 점을 해결하자.

내부 구현의 변경이 외부로 퍼져나가는 파급효과(ripple effect)는 캡슐화가 부족하다는 증거다.

### 스스로 자신의 데이터를 책임지는 객체

객체를 설계할 때 
* 이 객체가 어떤 데이터를 포함해야 하는지
* 이 객체가 데이터에 대해 수행해야 하는 오퍼레이션이 무엇인지

이 두 가지를 생각해보자

### 결론: 데이터 중심 설계의 문제점

* 데이터 중심의 설계는 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요한다.
  * 객체의 내부 구현이 객체의 인터페이스를 어지럽히고 객체의 응집도와 결합도에 나쁜 영향을 미치기 때문에 변경이 취약한 코드를 낳게 된다.
* 데이터 중심의 설계에서는 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.
  * 객체 내부 구현이 변경되었을 때 협력하는 객체 모두가 영향을 받았다.
























