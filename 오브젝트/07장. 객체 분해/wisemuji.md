# 객체 분해

인지 과부하: 문제 해결에 필요한 요소의 수가 단기 기억의 용량을 초과하는 순간 문제 해결 능력은 떨어짐
추상화: 불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만 남기는 작업

## 프로시저 추상화와 데이터 추상화

프로시저 추상화: 소프트웨어가 무엇을 해야 하는지를 추상화함 -> 객체지향
데이터 추상화: 소프트웨어가 무엇을 알아야 하는지를 추상화함 -> 추상 데이터 타입

## 프로시저 추상화와 기능 분해

### 메인 함수로서의 시스템

하향식 기능 분해의 특징:
* 논리적이고 체계적인 시스템 개발 절차를 제시함

단점:
* 시스템은 하나의 메인 함수로 구성되어있지 않다
* 기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정해야 함
* 비즈니스 로직이 사용자 인터페이스와 강하게 결합됨
* 유연성과 재사용성이 저하됨
* 데이터 형식이 변경될 경우 파급효과를 예측할 수 없음

즉, 변경에 취약한 설계를 낳는다

### 하향식 분해가 유용할 때

* 완전히 이해된 사실을 서술하기에는 적합함 (+ 작음 프로그램과 개별 알고리즘)
* 새로운 것을 개발하고 설계하고 발견하는 데에는 유용하지 않음

## 모듈

### 정보 은닉과 모듈

정보 은닉: 시스템을 모듈 단위로 분해하기 위한 기본 원리. 시스템에서 자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 감춰야 하는 것이 핵심임.

모듈은 다음 두 가지 비밀을 감춰야 한다:
* 복잡성: 외부에 모듈을 추상화할 수 있는 간단한 인터페이스를 제공해서 복잡도를 낮춤
* 변경 가능성: 변경 가능한 설계 결정을 모듈 내부로 감춤

### 모듈의 장점과 한계:

장점:
* 모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미침
* 비즈니스 로직과 사용자 인터페이스 관심사 분리
* 전역 변수와 전역 함수를 제거해서 네임스페이스 오염을 방지함

단점:
* 인스턴스의 개념을 제공하지 않음 -> 추상 데이터 타입으로 극복 가능

## 데이터 추상화와 추상 데이터 타입

### 추상 데이터 타입

> 추상 데이터 객체를 사용할 때 프로그래머는 오직 객체가 외부에 제공하는 행위에만 관심을 가지며 세부적인 구현 사항에 대해서는 무시한다.

구현하기 위해 프로그래밍 언어에서 제공해줘야하는 것:
* 타입 정의 선언
* 오퍼레이션 집합 정의
* 데이터를 외부로부터 보호
* 타입에 대한 여러 개의 인스턴스 생성 가능

## 클래스

### 클래스는 추상 데이터 타입인가?

아니다. 추상 데이터 타입을 사용하는 것을 객체기반 프로그래밍이라고 부르기도 한다. (상속과 다형성을 지원하지 않음)

추상 데이터 타입은 오퍼레이션을 기준으로 타입을 추상화한다. 클래스는 타입을 기준으로 절차를 추상화한다.

## 객체 지향 vs 추상 데이터 타입

새로운 타입을 빈번하게 추가해야 한다면? 객체 지향의 클래스 구조
새로운 오퍼레이션을 빈번하게 추가해야 한다면? 추상 데이터 타이

### 협력이 중요하다

협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션의 구현 방식을 타입별로 분배하는 것은 올바른 접근법이 아님
