# 13장. 서브클래싱과 서브타이핑

### 상속의 용도

1. 타입 계층 구현
    - 부모 클래스는 자식 클래스의 **일반화**
    - 자식 클래스는 부모 클래스의 **특수화**
2. 코드 재사용
    - 재사용을 위해 상속을 사용하면 변경하기 어려운 코드를 얻을 확률이 높다.

→ 동일한 메시지에 대해 서로 다르게 행동할 수 있는 다형적인 객체를 구현하기 위해서는 객체의 행동을 기반으로 타입 계층을 구성해야 한다.

# 타입

## 개념 관점의 타입

- 인스턴스
    - 어떤 대상이 타입으로 분류되는 것
    - 자바, 루비, 자바스크립트, C는 프로그래밍 언어의 인스턴스다.
- 객체
    - 타입의 인스턴스

### 타입의 세가지 요소

- 심볼
    - 타입에 이름을 붙인 것
    - ex. 프로그래밍 언어
- 내연
    - 타입이 속하는 객체들이 가지는 공통적인 속성이나 행동
    - 일반적으로 타입에 속하는 객체들이 공유하는 속성과 행동의 집합이 내연을 구성한다.
    - ex. 프로그래밍 언어는 '컴퓨터에게 특정한 작업을 지시하기 위한 어휘와 문법적 규칙의 집합'이라는 내연에 속한다.
- 외연
    - 타입에 속하는 객체들의 집합
    - ex. 자바, 루비, 자바스크립트, C가 속한 집합이 외연을 구성한다.

## 프로그래밍 언어 관점의 타입

- 타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의한다.
- 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공한다.

→ 타입은 적용 가능한 오퍼레이션의 종류와 의미를 정의함으로써 **코드의 의미를 명확하게 전달**하고, 개발자의 실수를 방지하기 위해 사용된다.

## 객체지향 패러다임 관점의 타입

- 개념 관점에서 타입이란 공통의 특징을 공유하는 대상들의 분류
- 프로그래밍 언어 관점에서 타입이란 동일한 오퍼레이션을 적용할 수 있는 인스턴스들의 집합
- **객체의 타입이란 객체가 수신할 수 있는 메시지의 종류를 정의하는 것**
    - 메시지의 집합 → 퍼블릭 인터페이스

즉,

객체의 퍼블릭 인터페이스가 객체의 타입을 결정한다. 따라서 동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류된다.

# 타입 계층

## 타입 사이의 포함관계

타입은 공통적인 특성을 가진 객체들을 포함하는 집합이다

타입 계층을 구성할 때에는 두 타입 간의 관계에서 

- 슈퍼타입
    - 더 일반적인 타입
    - ex. 프로그래밍 언어는 객체지향 언어 타입과 절차적 언어 타입의 슈퍼타입이다.
- 서브타입
    - 더 특수한 타입
    - ex. 객체지향 언어 타입은 프로그래밍 언어의 서브타입이다.

### 일반화

다른 타입을 완전히 포함하거나 내포하는 타입을 식별하는 행위 또는 행위의 결과

### 특수화

다른 타입 안에 전체적으로 포함되거나 완전히 내포되는 타입을 식별하는 행위 또는 그 행위의 결과

### 슈퍼타입

- 집합이 다른 집합의 모든 멤버를 포함한다.
- 타입 정의가 다른 타입보다 좀 더 일반적이다.

### 서브타입

- 집합에 포함되는 인스턴스들이 더 큰 집합에 포함된다.
- 타입 정의가 다른 타입보다 좀 더 구체적이다.

## 객체지향 프로그래밍과 타입 계층

일반적 타입과 구체적 타입간의 관계 형성 기준은 **퍼블릭 인터페이스**이다.

### 슈퍼타입

서브타입이 정의한 퍼블릭 인터페이스를 일반화시켜 상대적으로 범용적이고 넓은 의미로 정의한 것

### 서브타입

슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정의한 것

# 서브클래싱과 서브타이핑

## 언제 상속을 사용해야 하는가?

상속의 올바른 용도 → 타입 계층 구현

아래의 상황을 다 만족할때만 사용하자

1. 상속 관계까 is-a 관계를 모델링하는가?
    - 자식클래스는 부모클래스다라고 말해도 이상하지 않을 때
2. 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?
    - 클라이언트 입장에서는 부모 클래스와 자식 클래스의 차이점을 몰라야한다. (행동 호환성)
    - 여기에 초점을 맞추자!

## is-a 관계

어떤 타입 S가 다른 타입 T의 일종이라면 당연히 타입 S는 타입 T다(S is-a T)

→ 객체지향 언어는 프로그래밍 언어다 

→ 클래스 기반 언어는 객체 지향 언어다

그렇지만 그렇게 직관적이진 않다.

- 펭귄은 새다
- 새는 날 수 있다
- 하지만 펭귄은 날 수 없다!

→ 어휘적인 정의가 아니라, **기대되는 행동에 따라 타입 계층을 구성**해야 한다.

    즉, is-a로 표현할 수 있어도 상속을 사용할 예비 후보 정도로만 생각하자

## 행동 호환성

두 타입 사이에 행동이 호환될 경우에만 타입 계층을 묶어야한다.

행동의 호환 여부를 판단하는 기준은 클라이언트의 관점이다.

클라이언트가 두 타입이 동일하게 행동할 것이라고 기대할 때만 타입 계층으로 묶을 수 있다.

하지만...

1. 펭귄에게 나는 메서드를 오버라이드 하고 구현을 비워놓으면 되지 않나?
    - 모든 새가 날 수 있다는 클라이언트의 기대를 만족시키지 못한다.
2. 나는 메서드를 호출할 때 예외를 발생시키게 하면?
    - 클라이언트는 메시지 전송 결과로 예외를 기대하지 않았을 것이다.
3. 펭귄 타입이 아닐 때만 날게 하는건?
    - 또 다른 날 수 없는 새가 상속 계층에 추가되면 그때마다 코드를 바꿔야하는건가? → OCP 위반

## 클라이언트의 기대에 따라 계층 분리하기

날 수 있는 새와 날 수 없는 새를 명확히 분류하자

```java
public class Bird {

}

public class FlyingBird extend Bird {
	public void fly() { ... }
}

public class Penguin extends Bird {
	...
}
```

![Untitled](https://user-images.githubusercontent.com/42836576/115153239-d5b40d80-a0af-11eb-9b6b-e1e7ea9ff0e6.png)

만약 인터페이스로 분리한다면, 클라이언트가 기대하는 바에 따라 분리되어야한다.

즉,

클라이언트가 fly 메시지만 전송하기 원하면 → fly 메시지만 보여아 한다.

walk 메시지만 전송하기를 원한다면 → walk 메시지만 보여야 한다.

![Untitled 1](https://user-images.githubusercontent.com/42836576/115153233-d351b380-a0af-11eb-991e-1a3a511aa7a3.png)

따라서 Flyer과 Walker 인터페이스를 분리하고, 펭귄과 새는 이를 각각 조합해서 사용하면 된다.

더 좋은 방법은 합성을 사용하는 것이다. (Bird ← Penguin)

여기서 Client1의 기대가 바뀌어서 Flyer의 인터페이스가 변경되어도, Bird만 영향을 받을 뿐, Client2는 영향을 받지 않는다. → **인터페이스를 클라이언트의 기대에 따라 분리하는 설계 원칙, 즉 인터페이스 분리 원칙(ISP)**라고 한다. 이 원칙에 의해 '비대한' 인터페이스의 단점을 해결한다.

## 서브클래싱과 서브타이핑

상속을 하는 이유

1. 코드 재사용 (**서브클래싱**)
2. 타입 계층 (**서브타이핑**)

상속은 서브타이핑을 목적으로 사용되어야한다.

= 서브타입이 슈퍼타입이 하는 모든 행동을 동일하게 할 수 있어야 한다.

= **행동 호환성**을 만족시켜야한다.

= 자식 클래스와 부모 클래스 사이의 행동 호환성은 부모 클래스에 대한 자식 클래스의 **대체 가능성**을 포함한다

= **리스코프 치환 원칙**

# 리스코프 치환 원칙

> 자식 클래스는 부모 클래스를 대체할 수 있어야한다.
즉, 클라이언트가 차이점을 인식하지 못한 채 기반 클래스의 인터페이스를 통해 서브클래스를 사용할 수 있어야 한다.

정사각형은 직사각형이다?

→ 클라이언트는 직사각형은 너비와 높이가 다를 수 있다는 가정하에 코드를 개발하고, 정사각형은 너비와 높이가 항상 같다는 가정 하에 코드를 개발한다. 둘의 가정이 다르기 때문에 정사각형은 직사각형을 대체할 수 없다.

Stack와 Vector

→ Stack은 임의의 위치에서의 조회나 추가를 금지할 것이라고 예상하지만, Vector는 임의의 위치에서 조회나 추가가 가능하다. 즉, 둘의 가정이 다르다.

대체 가능성을 결정하는 것은 클라이언트다.

## is-a 관계 다시 살펴보기

- 정사각형과 직사각형
- 새와 펭귄

둘 다 **클라이언트가 동일하게 취급**할 때에만 성립한다.

is-a 관계는 객체지향에서 중요한 것은 객체의 속성이 아니라 행동이라는 점을 강조한다.

상속이 서브타이핑을 위해 사용될 경우에만 is-a 관계다. 서브클래싱을 구현하기 위해 상속을 사용했다면 is-a 관계라고 말할 수 없다.

## 리스코프 치환 원칙은 유연한 설계의 기반이다

리스코프 치환원칙은 개방-폐쇄 원칙을 만족하는 설계를 위한 전제 조건이다.

## 타입 계층과 리스코프 치환 원칙

구현방법과 무관하게 클라이언트의 관점에서 슈퍼타입에 대해 기대하는 모든 것이 서브타입에게도 적용되어야 한다.

# 계약에 의한 설계와 서브타이핑

서브타입이 리스코프 치환 원칙을 만족시키기 위해서는 클라이언트와 슈퍼타입 간에 체결된 '계약'을 준수해야한다. (부록 A. 계약에 의한 설계)

screening을 받기 전 사전조건

```java
assert acreening != null && screening.getStartTime().isAfter(LocalDateTime.now());
```

반환값은 null이면 안되기 때문에 사후조건은

```java
assert amount != null && amount.isGreaterThanOrEqual(Money.ZERO);
```

## 서브타입과 계약

- 서브타입에 더 강력한 사전 조건을 정의할 수 없다.
- 서브타입에 슈퍼타입과 같거나 더 약한 사전조건을 정의할 수 있다.
- 서브타입에 슈퍼타입과 같거나 더 강한 사후조건을 정의할 수 있다.
- 서브타입에 더 약한 사후조건을 정의할 수 없다.