# 2장. 객체지향 프로그래밍

# 객체지향 프로그래밍을 향해

## 협력, 객체, 클래스

1. 어떤 클래스가 필요한지 고민하기 전에 어떤 객체가 필요할지 고민하라
2. 객체를 독립적인 존재가 아닌 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐라

## 도메인의 구조를 따르는 프로그램 구조

- 도메인
    - 사용자가 프로그램을 사용하는 분야

## 클래스 구현하기

- 클래스 내부와 외부를 구분해야 하는 이유
    - 경계의 명확성이 객체의 자율성을 보장하기 때문이다.
    - 외부 : 퍼블릭 인터페이스
    - 내부 : 구현

## 협력하는 객체들의 공동체

- 금액을 구현할 때에는 Long → 객체(Money)를 사용하자
    - 금액과 관련된 로직을 한 곳에 모을 수 있다.
    - 의미를 명시적이고 분명하게 표현할 수 있다.
    - 하나의 인스턴스만을 포함하더라도 개념을 명시적으로 구현하면 설계의 명확성과 유연성을 높일 수 있다,
- 협력
    - 어떤 기능을 구현하기 위해 객체들 사이에서 이뤄지는 상호작용

## 협력에 관한 짧은 이야기

- 메시지
    - 객체가 다른 객체와 상호작용할 수 있는 유일한 방법
- 메서드
    - 메시지를 처리하기 위한 자신만의 방법

# 할인 요금 구하기

## 할인 요금 계산을 위한 협력 시작하기

- 메서드 템플릿 패턴
    - 부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴

# 상속과 다형성

## 컴파일 시간 의존성과 실행 시간 의존성

- 코드의 의존성과 실행 시점의 의존성이 다를 수 있다.
    - = 클래스 사이의 의존성과 객체 사이의 의존성을 다를 수 있다.
    - 확장 가능한 객체지향 설계가 가지는 특징

## 차이에 의한 프로그래밍

- 부모 클래스와 다른 부분만 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법

## 상속과 인터페이스

- 일반적인 사람들이 생각하는 상속
    - 메서드나 인스턴스 변수 재사용
- 사실은
    - 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있기 때문
    - AmountDiscountPolicy, PercentDiscountPolicy 모두 DiscountPolicy의 역할을 대신할 수 있음
- 업캐스팅
    - 자식 클래스가 부모 클레스를 대신하는 것

## 다형성

- 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력
    - 같은 메시지를 이해할 수 있어야함 → 인터페이스가 동일해야함 → 상속을 이용해 구현
    - 꼭 상속만이 방법은 아님
    - 구현 상속
        - 순수하게 코드 재사용을 목적으로 사용하는 상속
    - 인터페이스 상속
        - 다형적인 협력을 위해 자식 클래스가 인터페이스를 공유할 수 있도록 상속을 이용하는 것
- 메시지와 메서드를 실행 시점에 바인딩한다
    - 지연 바인딩 또는 동적 바인딩이라고 부름
- 전통적인 함수 호출처럼 컴파일 시점에 실행될 함수나 프로시저를 결정하는 것
    - 초기 바인딩 또는 정적 바인딩

# 추상화와 유연성

## 추상화의 힘

1. 세부적인 내용을 무시한 채 상위 정책을 쉽고 간단하게 표현할 수 있다.
2. 기존 구조를 수정하지 않고도 새로운 기능을 쉽게 추가하고 확장할 수 있다.

## 유연한 설계

- 유연성이 필요한 곳에 추상화를 사용하라

## 추상 클래스와 인터페이스 트레이드 오프

![img](https://blog.kakaocdn.net/dn/co74b4/btqCRzsGilo/VUyVmYYZEvFX8kNNrnH5vK/img.png)

## 상속의 단점

1. 캡슐화를 위반한다.
    - 자식이 부모 클래스의 구조를 알고 있어야 한다.
2. 설계를 유연하지 못하게 만든다.

## 합성

- 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법
- 코드 재사용할 경우
    - 합성을 사용하자
- 다형성을 위해 인터페이스를 재사용하는 경우
    - 합성과 상속을 조합해서 사용하자