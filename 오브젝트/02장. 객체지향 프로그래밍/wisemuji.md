# 객체지향 프로그래밍

이번 장의 목표는 이 책을 읽으면서 이해하게 될 다양한 주제들을 가벼운 마음가짐으로 얕게 살펴보는 것이다.

## 객체지향 프로그래밍을 향해

### 협력, 객체, 클래스

진정한 객체지향 패러다임으로의 전환은 클래스가 아닌 객체에 초점을 맞출 때에만 얻을 수 있다.

* 어떤 클래스가 필요하기를 고민하기 전에 어떤 객체들이 필요한지 고민하라.
* 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야 한다.

### 도메인의 구조를 따르는 프로그램 구조

**도메인**: 사용자가 문제를 해결하기 위해 프로그램을 사용하는 분야

* 클래스 사이의 관계도 최대한 도메인 개념 사이에 맺어진 관계와 유사하게 만들어서 프로그램의 구조를 이해하고 예상하기 쉽게 만들어야 한다.
* 도메인의 개념과 관계를 반영하도록 프로그램을 구조화해야 하기 떄문에 클래스의 구조는 도메인의 구조와 유사한 형태를 띄어야 한다.

### 클래스 구현하기

클래스의 경계 구분 짓기: 어떤 부분을 외부에 공개하고 어떤 부분을 내부에 감출지 결정해야 한다.

그 이유는: 
* 경계의 명확성이 객체의 자율성을 보장한다.
  * 객체가 자율적인 존재로 서기 위해서는 외부의 간섭을 최소화해야 한다(인터페이스와 구현의 분리).
  * 일반적으로 객체의 상태를 숨기고 행동만 외부에 공개해야 한다.
* 프로그래머에게 구현의 자유를 제공한다.
  * 구현 은닉: 클라이언트 프로그래머에 대한 영향을 걱정하지 않고도 내부 구현을 마음대로 변경할 수 있다.

**설계가 필요한 이유는 변경을 관리하기 위해서**임을 잊지 않아야 한다. 접근 제어를 통해 변경으로 인한 혼란을 최소화할 수 있다.

### 협력하는 객체들의 공동체

객체지향 프로그램을 작성할 땐 먼저 협력의 관점에서 어떤 객체가 필요지를 결정한다.

* 객체는 다른 객체의 인터페이스에 공개된 행동을 수행하도록 **요청**할 수 있다.
* 요청을 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 **응답**한다.
* 객체와 객체는 오직 **메세지**를 통해서만 상호작용할 수 있고 메시지를 처리하기 위한 자신만의 방법을 **메서드**라고 부른다.

### 템플릿 메소드 패턴

부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴. (abstract을 이용할 수 있음)

## 상속과 다형성

### 컴파일 시간 의존성과 런타임 의존성 

클래스 사이의 의존성과 객체 사이의 의존성은 다를 수 있다.

* 클래스 사이의 의존성과 객체 사이의 의존성이 다를수록 코드를 이해하기 어려워지고 디버깅하기 어려워진다.
* 반면에 코드는 더 유연해지고 확장 가능성이 높아진다. -> 설계가 트레이드오프의 산물

### 상속

코드를 재사용하기 위해 가장 널리 사용되는 방법이다.

부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법을 **차이에 의한 프로그래밍**이라고 한다.

### 상속과 인터페이스

자식 클래스는 상속을 통해 부모 클래스의 인터페이스를 물려받기 때문에 부모 클래스 대신 사용될 수 있다.

이를 **업캐스팅**이라고 한다.

### 다형성

동일한 메시지를 전송하더라도 실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라진다.(컴파일 시간 의존성과 런타임 의존성 참고)

이를 **다형성**이라고 한다. 즉 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력이다.

* 메시지와 메서드를 컴파일 시점에 바인딩: 초기 바인딩(early binding), 정적 바인딩(static binding)
* 메시지와 메서드를 런타임 시점에 바인딩: 지연 바인딩(lazy binding), 동적 바인딩(dynamic binding)

## 추상화와 유연성

추상화를 이용한 설계는:
* 필요에 따라 표현의 수준을 조정할 수 있게 해준다.
* 세부적인 내용을 무시한 채 상위 정책을 쉽고 간단하게 표현할 수 있고 기본적인 애플리케이션의 협력 흐름을 기술할 수 있게 된다.
  * 재사용 가능한 설계의 기본을 이루는 디자인 패턴이나 프레임워크 모두 추상화를 이용해 상위 정책을 정의하는 객체지향의 메커니즘을 활용하고 있다.
* 기존 구조를 수정하지 않고도 새로운 기능을 쉽게 추가하고 확장할 수 있다(유연한 설계).

유연성이 필요한 곳에 추상화를 사용하라.

### 상속과 합성(컴포지션)

합성(컴포지션): 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법

상속은 객체지향에서 코드를 재사용하기 위해 널리 사용되는 기법이지만 다음 문제점이 있다:
* 캡슐화를 위반한다.
* 설계를 유연하지 못하게 만든다. (컴파일 시점에 관계 결정)

반면에 합성(컴포지션)은
* 인터페이스에 정의된 메시지를 통해서만 재사용이 가능하기 때문에 구현을 효과적으로 캡슐화할 수 있다.
* 의존하는 인스턴스를 교체하는 것이 비교적 쉽기 때문에 설계를 유연하기 만든다.
  * 상속은 클래스를 통해 강하게 결합되는 반면 합성은 메시지를 통해 느슨하게 결합된다.

## 결론

프로그래밍의 관점에서 클래스와 상속은 중요하지만 프로그래밍의 관점에 너무 치우쳐서 객체지향을 바라볼 경우 객체지향의 본질을 놓치기 쉽다.

객체지향의 핵심은 적절한 협력을 식별하고 협력에 필요한 역할을 정의한 후에 역할을 수행할 수 있는 적절한 객체에게 적절한 책임을 할당하는 것이다.
















