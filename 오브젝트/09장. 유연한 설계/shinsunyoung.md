# 09장. 유연한 설계

# 개방-폐쇄 원칙

소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 열려 있어야 하고, 수정에는 닫혀 있어야 한다.

- 확장에 열려 있다.
    - 애플리케이션의 요구사항이 변경될 때 이 변경에 맞게 새로운 '동작'을 추가해서 애플리케이션의 기능을 확장할 수 있다.
- 수정에 대해 닫혀 있다.
    - 기존의 '코드'를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있다.

## 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라

할인 정책을 추가할 때 → 기존 할인정책 코드들을 변경하지 않았음!

개방-폐쇄 원칙을 따르는 설계란?

→ 컴파일타임 의존성은 유지하면서 런타임 의존성의 가능성을 확장하고 수정할 수 있는 구조

## 추상화가 핵심이다

개방-폐쇄 원칙의 핵심은 추상화에 의존하는 것!

추상화 부분은 수정에 대해 닫혀 있다. 추상화를 통해 생략된 부분은 확장의 여지를 남긴다.

# 생성 사용 분리

객체에 대한 생성과 사용을 분리해야 한다.

## FACTORY 추가하기

생성과 사용을 분리하기 위해 객체 생성에 특화된 객체

```java
public class Factory {
	public Movie createAvatarMovie() {
		return new Movie("아바타",
										Duration.ofMinus(120) ...
	}
}
```

→ 클라이언트는 인스턴스를 반환받아 사용

클라이언트는 사용과 관련된 책임만 지고 생성과 관련된 어떤 지식도 가지지 않을 수 있음

## 순수한 가공물에게 책임 할당하기

- 표현적 분해
    - 도메인에 존재하는 사물 또는 개념을 표현하는 객체들을 이용해 시스템을 분해하는 것
    - 객체지향 설계를 위한 가장 기본적인 접근법
- 행위적 분해
    - 도메인 개념을 표현한 객체가 아닌 설계자가 편의를 위해 임의로 만들어낸 가공의 객체에게 책임을 할동하기 위해 창조되는 인공적인 객체
        - 순수한 가공물(Pure Fabrication)

1. 도메인의 본질적인 개념을 표현하는 추상화를 이용해 애플리케이션을 구축하기 시작하라
2. 도메인 개념이 만족스럽지 못하다면 주저말고 인공적인 객체를 창조하라
    - 객체지향이 실세계를 모방하는건 아니기 때문이지롱삥뽕

# 의존성 주입

사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법

- 생성자 주입
- setter 주입
- 메서드 주입

## 숨겨진 의존성은 나쁘다

SERVICE LOCATOR

- 의존성을 감춘다.
- 퍼블릭 인터페이스의 어디에도 의존성에 대한 정보가 표시되지 않는다.
- 단위 테스트 작성도 어렵다.
- 코드 내부 구현을 이해할 것을 강요한다.
    - 캡슐화를 위반하게 된다.

명시적인 의존성이 숨겨진 의존성보다 좋다.

단, 깊은 호출 계층에 걸쳐 동일한 객체를 계속해서 전달해야 하는 경우에는 고려해볼만하다.

# 의존성 역전 원칙

## 추상화와 의존성 역전

1. 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다. 둘 모두 추상화에 의존해야 한다.
2. 추상화는 구체적인 사항에 의존해서는 안 된다. 구체적인 사항은 추상화에 의존해야 한다.

→ 의존성 역전의 원칙(DIP)

## 의존성 역전 원칙과 패키지

패키지에도 적용된다.

추상화를 별도의 독립적인 패키지가 아닌, 클라이언트가 속한 패키지에 포함시켜야 한다.

함께 재사용될 필요가 없는 클래스들은 별도의 독립적인 패키지에 모아야 한다.

Movie & DiscountPolicy ⇒ 한 패키지

AmountDiscountPolicy & PercentDiscountPolicy ⇒ 한 패키지

훌륭한 객체지향 설계를 위해서는 의존성을 역전시켜야 한다. 그리고 의존성을 역전시켜야만 유연하고 재사용 가능한 설계를 얻을 수 있다.

# 유연성에 대한 조언

## 유연한 설계는 유연성이 필요할 때만 옳다

유연성은 항상 복잡성을 수반한다.

유연하지 않은 설계는 단순하고 명확하다.

## 협력과 책임이 중요하다

설계를 유연하게 만들기 위해서는 역할, 책임, 협력에 초점을 맞춰야 한다. 

객체를 생성하는 방법에 대한 결정은 모든 책임이 자리 잡은 후 마지막 시점에 내리는 것이 적절하다.