# 디자인 패턴과 프레임워크

* 디자인 패턴: 소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 이쓴ㄴ 해결 방법(설계를 재사용)
* 프레임워크: 애플리케이션의 아키텍처를 구현 코드의 형태로 적용(설계와 코드를 함께 재사용)

## 디자인 패턴과 설계 재사용

### 소프트웨어 패턴

패턴은 공통으로 사용할 수 있는 역할, 책임, 협력의 템플릿이다.
  * 패턴을 구성하는 요소는 클래스가 아니라 역할이다
  * 단지 역할과 책임, 협력의 템플릿을 제안할 뿐 구체적인 구현 방법에 대해서는 제한을 두지 않는다.

패턴을 적용하기 위해서는 패턴에서 제시하는 구조를 그대로 표현하는 것이 아니라 패턴의 기본 구조로부터 출발해서 현재의 요구에 맞게 구조를 수정해야 한다.

### 캡슐화와 디자인 패턴

* STRATEGY 패턴: 알고리즘의 변경을 캡슐화하는게 목적, 객체 합성을 이용해서 해당 목적을 달성함.
* TEMPLATE 패턴: 알고리즘을 캡슐화하기 위해 합성 관계가 아닌 상속 관게를 사용하는 것
* DECORATOR 패턴: 객체의 행동을 동적으로 추가할 수 있게 해주는 패턴, 객체의 행동을 결합하기 위해서 객체 합성을 사용함.

### 패턴은 출발점이다

패턴은 출발점이지 목적지가 아니다. -> 공통적인 문제에 적절한 해법을 제공하지만 그게 우리가 직면한 문제에 적합하지 않을 수도 있다.

디자인 패턴이 현재의 요구사항이나 적용 기술, 프레임워크에 적합하지 않다면 패턴을 그대로 따르지 말고 목적에 맞게 패턴을 수정하라.

정당한 이유 없이 사용된 모든 패턴은 설계를 복잡하게 만드는 장애물이고, 패턴은 복잡성의 가치가 단순성을 넘어설 때만 정당화되어야 한다.

## 프레임워크와 코드 재사용

### 코드 재사용 VS 설계 재사용

재사용 관점에서 설계 재사용보다 더 좋은 방법은 코드 재사용이다.

프레임워크는 코드를 재사용함으로써 설계 아이디어를 재사용한다. 애플리케이션의 아키텍처를 제공하며 문제 해결에 필요한 설계 결정과 기반 코드를 함께 포함한다.

### 상위 정책과 하위 정책으로 패키지 분리하기

동일한 역할을 수행하는 객체들 사이의 협력 구조를 다양한 애플리케이션 안에서 재사용하기 위해선 변하는 것과 변하지 않는 것을 서로 분리해야 한다:
* 변하는 것: 상위 정책에 속하는 역할들의 협력 구조
* 변하지 않는 것: 구체적인 세부 사항

### 제어 역전 원리

* 전통적인 구조: 상위 정책의 코드가 하부의 구체적인 코드를 호출함. 즉, 애플리케이션의 코드가 재사용 가능한 라이브러리나 툴킷의 코드를 호출함.
* 의존성을 역전시킨 객체지향 구조: 프레임워크가 애플리케이션에 속하는 서브클래스의 메서드를 호출함. 
  * 즉, 개별 애플리케이션에서 프레임워크로 제어 흐름의 주체가 이동한다. (이를 제어 역전 원리라고 함)
  * 협력을 제어하는 것은 프레임워크라는 사실을 주목하자. 우리의 코드는 수동적인 존재다.
