# 10. 상속과 코드 재사용



객체지향의 코드를 효과적으로 재사용 시키는 방법

- 상속 : 클래스 안에 정의된 인스턴스 변수와 메서드를 자동으로 새로운 클래스에 추가하는 기법
- 합성 : 새로운 클래스의 인스턴스 안에 기존 클래스의 인스턴스를 포함시키는 방법
- 

## 01. 상속과 중복 코드

중복 여부를 판단하는 기준은 변경

중복 여부를 결정하는 기준은 코드가 변경하는 반응



DRY 원칙 : Don't Repea Yourself  동일 지식을 중복하지 마라.

- 모든 지식은 시스템 내에서 단일하고, 애매하지 않고, 정말로 믿을 만한 표현 양식을 가져야 한다.

- 한 번, 단 한번 원칙(Once and Only Once) , 단일 지점 제어 원칙(Single-Point Control)이라고도 부른다.



 ##### **상속을 위한 경고1**

```
자식 클래스의 메서드 안에서 super 참조를 이용해 부모 클래스의 메서드를 직접 호출할 경우 두 클래스는 강하게 결합된다. super 호출을 제거할 수 있는 방법을 찾아 결합도를 제거하라.
```



취약기반 클래스 문제란?

- 상속 관계로 연결된 자식 클래스가 부모 클래스의 변경에 취약해 지는 현상 
- 주로 코드 재사용을 목적으로 상속할때 발생하는 문제이다.
- 

## 02. 취약한 기반 클래스 문제

취약한 기반 클래스 문제 : 부모 클래스의 변경에 의해 자식 클래스가 영향을 받는 현상



상속관계 추가 ->결합도가 높아짐



문제 

취약한 기반 클래스 문제는 캡슐화를 약화시키고 결합도를 높인다.

상속은 자식 클래스가 부모 클래스의 구현 세부사항에 의존하도록 만들어야 하기 때문에..



객체를 사용하는 이유

- 구현과 관련된 세부사항을 퍼블릭 인터페이스 뒤로 캡슐화 할수 있기 때문에
- 파급효과를 제어할 수 있기 때문에



#### 불필요한 인터페이스 상속 

불필요한 상속의 사례 : STACK 

![image-20210411011055267](C:\Users\user.DESKTOP-MH5KDIR.000\AppData\Roaming\Typora\typora-user-images\image-20210411011055267.png)


Stack이 Vector를 상속받기 때문에 Stack 의 규칙의 Vector의 인터페이스 요소를 통해 추가 삭제될수 있다.



##### 상속을 위한 경고 2

```
상속받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 꺠트릴 수 있다.
```



#### 메서드의 오버라이딩 문제



##### 상속을 위한 경고 3

```
자식 클래스가 부모 클래스의 메서드를 오버라이딩 할 경우 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다.
```

클래스가 상속되기를 원하면 클래스를 설계하고 문서화 하고 그렇지 못할 경우에는 상속을 금지시켜야한다.

**설계는 트레이드 오프라는 사실을 기억해야한다.!**



#### 부모 클래스와 자식 클래스의 동시 수정 문제



자식클래스가 부모 클래스를 상속받지 않았음에도 부모  클래스가 수정되면 자식도 수정할수도 있다라는 점



##### 상속을 위한 경고 4

```
클래스를 상속하면 결합도로 인해 자식 크랠스와 부모 클래스의 구현을 영원히 변경하지 않거나, 자식 크랠스와 부모 클래스를 동시에 변경하거나 둘 중 하나를 선택할 수 밖에 없다.
```



## 03. phone 다시 살펴보기

피해를 최소하는 방법을 살펴 본다. (phone이라는 목차는 책의 코드로  설명이 되어있기 때문이다.)



문제 해결의 열쇠 : **추상화**



#### 추상화에 의존하자



상속을 도입할 때 따르는 두가지 원칙

- 두 메서드가 유사하게 보인다면 차이점을 메서드로 추출하라. 메서드 추출을 통해 두 메서드를 동일한 형태로 보이도록 만들 수 있다.
- 부모 클래스의 코드를 하위로 내리지 말고 자식 클래스의 코드를 상위로 올려라. 
  - 재사용성과 응집도 측면에서 더 뛰어난 결과를 얻을 수 있다.



#### 차이를 메서드로 추출하라



변하는 것으로 부터 변하지 않는 것을 분리하라.  변하는 부분을 찾고 이를 캡슐화하라.



#### 추상화가 핵심이다.



상속 계층이 코드를 진화시키는 데 걸림돌이 된다면 추상화를 찾아내고 상속 계층 안의 클래스들이 그 추상화에 의존하도록 코드를 리팩터링!

차이점을 메서드로 추출하고 공통적인 부분은 부모 클래스로 이동하라.

- 참고사항으로 책의 코드 

> 차이를 메서드로 추출하라 333 p 부터339p 중복 코드를 부모 클래스로 올려라. 까지 의 코드 문맥을 파악해 보는것이 좋겠다.



#### 의도를 드러내는 이름 선택하기

![image-20210411013319440](C:\Users\user.DESKTOP-MH5KDIR.000\AppData\Roaming\Typora\typora-user-images\image-20210411013319440.png)

상속 게층을 구성하기 위해서 상속 계층안에 속한 클래스들이 구현이 아닌 추상화에 의존해야 한다!



#### 세금 추가하기

Now

- 상속은 어떤 방식이든 부모 클래스와 자식 클래스를 결합시킨다.



Want 

- 해옹을 변경하기 위해 인스턴스 변수를 추가하더라고 상속 계층 전체에 걸쳐 부작용이 퍼지지 않게 막는것!



## 04. 차이에 의한 프로그래밍

차이에 의한 프로그래밍이란?

- 기존 코드와 다른 부분만을 추가함으로써 애플리케이션의 기능을 확장하는 방법



목표

- 중복 코드를 제거하고 코드를 재사용하는 것이다.

 중복을 제거하기 위해서는 코드를 재사용 가능한 단위로 분해하고 재궁성해야한다. -> 코드를 재사용하기 위해서는  중복 코드를 제거해 모듈화 한다.

- 상속은 정말 필요할 경우에만 사용하라





