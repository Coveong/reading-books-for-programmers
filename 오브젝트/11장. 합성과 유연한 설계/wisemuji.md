# 합성과 유연한 설계

* 상속: 컴파일 타임 의존성, is-a 관계
* 합성: 런타임 의존성, has-a 관계

합성은 구현에 의존하지 않는다. 내부에 포함되는 객체의 구현이 아닌 퍼블릭 인터페이스에 의존하므로 구현이 변경되더라도 영향을 최소화할 수 있다.

* 코드 작성 시점에 결정한 상속 관계는 변경이 불가능하지만 실행 시점에 동적으로 변경할 수 있다.
* 상속은 부모 클래스 안에 구현된 코드 자체를 재사용하지만 합성은 포함되는 객체의 퍼블릭 인터페이스를 재사용한다.

## 상속을 합성으로 변경하기

상속을 남용했을 때 생길 수 있는 세 가지 문제:

* 불필요한 인터페이스 상속 문제
* 메서드 오버라이딩의 오작용 문제
* 부모 자식 클래스의 동시 수정 문제

합성으로 변경하면 모두 해결할 수 있다.

## 상속으로 인한 조합의 폭발적인 증가

상속으로 결합도가 높아졌을 때 생길 수 있는 문제:

* 하나의 기능을 추가하거나 수정하기 위해 불필요하게 많은 수의 클래스를 추가하거나 수정해야 한다.
* 단일 상속만 지원하는 언어에서는 오히려 중복 코드의 양이 늘어날 수 있다.

합성으로 변경하면 모두 해결할 수 있다.

## 객체 합성이 클래스 상속보다 더 좋은 방법이다

코드를 재사용하면서도 건전한 결합도를 유지할 수 있는 더 좋은 방법은 합성을 이용하는 것이다. 하지만 상속이 무조건적으로 나쁜건 아니다.

## 믹스인

구체적인 코드를 재사용하면서도 낮은 결합도를 유지할 수 있는 유일한 방법은 재사용에 적합한 추상화를 도입하는 것이다.

믹스인: 객체를 생성할 때 코드 일부를 클래스 안에 섞어 넣어 재사용하는 기법. 런타임 시점에 객체를 조합하는 합성과 달리 컴파일 시점에 필요한 코드 조각을 조합하는 새로운 재사용 방법이다.

### 상속과 다른 점

상속은 정적이지만 믹스인은 동적이다. 상속은 부모 클래스와 자식 클래스의 관계를 작성하는 시점에 고정시켜 버리지만 믹스인은 제약을 둘 뿐 실제로 어떤 코드에 믹스인될 것인지를 결정하지 않는다.

### 믹스인을 사용하는 이유

특정한 클래스에 대한 변경 또는 확장을 독립적으로 구현한 후 필요한 시점에 차례대로 추가할 수 있다. (쌓을 수 있는 변경)

하나의 믹스인은 매우 다양한 클래스를 도출하면서 서로 다른 서브클래스를 이용해 인스턴스화될 수 있다. -> 다중 클래스를 위한 단일의 점신적인 확장을 정의하는데 적절하게 만든다.









