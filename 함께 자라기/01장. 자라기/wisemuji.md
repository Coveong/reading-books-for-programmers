# 자라기

## 들어가는 말

야생 학습의 특징(학교 학습과 반대):

* 대부분 협력적이다 (학교 학습은 대부분 개별적이다)
* 대부분 비순차적이다 (학교 학습은 대부분 공부 순서가 정해져있다)
* 대부분 자료에 한정이 없다 (학교 학습은 대부분 범위가 정해져있다)
* 대부분 명확한 평가가 없다 (학교 학습은 시험이라는 명확한 평가 기준이 있다)
* 대부분 정답이 없다 (학교 학습은 정답이 명확하다)
* 대부분 목표가 불분명하고 바뀌기도 한다 (학교 학습은 대부분 목표가 분명하다)

이 책에서 언급하는 학습은 대부분 야생학습을 뜻함.

수파리: 

1. 우선 규칙을 지키고
2. 나중에 그 규칙을 깨트리고
3. 다음에는 규칙 자체를 넘어선다

## 당신은 몇 년 차?

### 경력, 그 견딜 수 없는 무거움

보통 사람들은 경력을 소프트웨어 기술자의 등급이라고 여긴다. 하지만 저자는 다음과 같이 말한다.

1. 경력 연차라는 것으로부터 이 사람이 초급인지 아닌지 정도의 정보만 기대할수 있으며 
2. 초급이 아닌 사람들에 대해서는 경력 연차가 오히려 혼동을 불러일으키는 잘못된 정보로 작용할 수 있고
3. 고로 경력 연차로 채용 여부나 임금 수준을 결정하는 것은 판단 편의적이고 관료주의적이며 결과적으로 조직에 손해를 줄 수 있는 방식이다

## 직원을 뽑을 때 무엇이 그 사람의 실력을 가장 잘 예측할까?

실험을 통해 경력 연차와 학력이 직무 성과와 얼마나 많은 상관성을 갖고 있는지 측정해본 결과 각각 0.18, 0.10로 낮은 상관성을 보였다.

연차가 완전히 의미가 없진 않았지만 우리가 예상하는 것에 비해 큰 상관성을 가지지는 않는다.

### 소프트웨어 개발에서 경력과 실력

소프트웨어 개발뿐만 아니라 다른 여러 영역에서도 동일하게 최소한도의 경험치만 넘어가면 경력 연수와 실제 직무 성과의 상관성이 생각보다 낮다.

### 중요하다고 생각하는 것이 중요하지 않다.

대다수의 조직에서 직원을 뽑는 데 중요하다고 생각하는 요소가 많은 경우 별로 중요하지 않고, 중요하지 않다고 생각하는 요소가 중요한 경우가 많다.

대안: 구조화된 인터뷰, 작업 샘플 테스트, 실제 업무 수행, 실무자 인터뷰 등

### 잘 뽑는 것 이상으로 중요한 것

아무리 훌륭한 사람을 뽑아도 조직의 시스템과 문화에 문제가 있으면 그런 사람은 묻혀버리고,
반대로 평범한 사람일지라도 좋은 시스템 속에서 뛰어난 성과를 낼 수 있다.

품질 석학 에드워드 데밍은 직원들이 아니라 그 사람들이 속한 시스템, 그걸 만들고 책임지는 경영진이 중요하다고 했다.

### 개발자들이 할 수 있는 것

저자: 소프트웨어 개발에서 점차 경력 연수를 중시하는 문화가 사라질 것이고 개발자들은 자신의 경력 연차 외에 다른 것에도 신경을 써야 한다.

다음 두 요소가 학습에 좋은 영향을 미친다:
* 피드백을 짧은 주기로 얻는 것
* 실수를 교정할 기회가 있다는 것

## 자기계발은 복리로 돌아온다

자기가 습득한 지식이나 능력은 복리로 이자가 붙는다. 더 빨리 자라고 싶으면 다음을 고민해보자:

1. 어떻게 이율을 높일 것인가
2. 지속적으로 현명한 투자를 하려면 어떻게 할 것인가

### 복리의 비밀

A: 원래 해야 하는 것
B: A를 개선
C: B를 개선 (개선하는 능력을 개선)

복리 조직이 일하는 구조: 조직이 첫 주기에 만들어낸 결과물을 계단 삼아서 다음 주기에는 조금 더 높은 위치에서 다음 결과물을 만들어낸다. 
결과물이 다음 단계의 도구가 된다 -> "성장"

* **더하기적 사고**: 가용시간을 늘리고 쓸데없이 낭비되는 시간을 줄이고 잠자는 시간을 줄이는 것
* **곱하기적 사고**: 집단의 지능을 높이는 것

나의 A 작업을 개선하려면 다음 질문을 해봐야 한다.

1. 어떻게 하면 더하기보다 곱하기를 할 수 있을까?
2. 어떻게 해야 곱하는 비율을 높이거나 이자 적용 주기를 짧게 할 수 있을까?

저자의 힌트:
* 자신이 이미 갖고 있는 것들을 잘 활용하라
* 외부 물질을 체화하라
* 자신을 개선하는 프로세스에 대해 생각해 보라
* 피드백을 자주 받아라(애자일)
* 자신의 능력을 높여주는 도구와 환경을 점진적으로 만들어라

## 학습 프레임과 실행 프레임

두 그룹으로 아이들을 나누고 실험을 진행했다.

* **실행 프레임**: "여러분이 얼마나 그림을 잘 그리는지 확인해볼겁니다. 점수를 매길거예요" -> **잘하기**에 초점
* **학습 프레임**: "내가 안 그려 보았던 방식들을 실험해볼겁니다. 여러 가지 방법으로 실험해보세요" -> **자라기**에 초점

결과는 학습 프레임의 아이들이 훨씬 많이 성장한다. 실행 프레임은 나의 목표가 학습을 통한 성장이라면 불리한 선택이다.

또 동일한 자극/조건이 주어졌을 때 어떤 사람은 더 많은 학습과 성장의 기회를 찾고 오히려 그 조건을 자신에게 유리하게 만들기도 한다.

## 가장 학습하기 힘든 직업이 살아남는다.

### 학습에 유리한 조건, 불리한 조건

알파고 같은 인공지능 시대에 대비하려면 배우기 힘든 것에 집중해야 한다.

인공지능 시스템에 유리한 조건(= 인간이 학습하기 좋은 환경의 조건):
1. 목표가 분명하고 객관적으로 정해져 있으며 정적이다.
1. 매 순간 선택할 수 있는 행동/선택의 종류가 유한하게 정해져 있다.
1. 매 순간 자신이 목표에 얼마나 근접했는지를 알 수 있따.
1. 주로 닫힌(예상 밖의 외부 요소가 없는) 시스템 속에서 일한다.
1. 과거의 선택과 결과에 대한 구조화된 기록이 많다.

학습하기 힘든 환경과 조건:
1. 목표(Goal)가 모호하고 주관적일 수 있으며 동적이다.
1. 매 순간 선택할 수 있는 행동/선택의 종류(Move)가 불확실하다.
1. 매 순간 내가 목표에 얼마나 근접했는지를 알기 어렵다(내가 한 선택의 피드백을 빨리 얻기 어렵다).
1. 주로 열린 시스템(즉, 예상 못 한 외부 요소가 갑자기 들어오는 경우가 흔한) 속에서 일한다.
1. 과거의 선택과 결과에 대한 구조화된 기록이 별로 없다.

### 컴퓨터로 대체되기 힘든 일

* **독창성(Originality)**: 주어진 주제나 상황에 대해 특이하거나 독창적인 생각을 해내기, 혹은 문제를 해결하는 창의적인 방법들을 만들어내기
* **사회적 민감성(Social Perceptiveness)**: 타인의 반응을 알아차리고 그 사람들이 왜 그렇게 반응하는지 이해하기
* **협상(Negotiation)**: 사람들을 화해시키고 서로 간의 차이를 조정하려고 노력하기
* **설득(Persuasion)**: 다른 사람들이 마음이나 행동을 바꾸게 설득하기
* **타인을 돕고 돌보기(Assisting and Caring for Others)**: 개인적 도움, 치료, 감정적 지지, 혹은 동료, 고객 환자 같은 타인에 대한 기타의 개인적 도움 제공

컴퓨터 프로그래머는 다른 사람이 준 스펙대로 개발하는 것을 주 업무로 하며 그 과정에서 협상, 설득이 크게 필요하지 않는다.
반면에 소프트웨어 개발자는 소프트웨어를 뭘 만들지를 고민하고 설계하는 부분이 포함되며 그 과정에서 타인과 상호작용하는 업무가 많다.

연구에 따르면 컴퓨터 프로그래머는 소프트웨어 프로그래머에 비해 컴퓨터로 대체될 가능성이 높다. (컴퓨터 프로그래머: 43점, 소프트웨어 프로그래머: 13점)

### 무엇에 집중할 것인가

자신이 주로 남이 시킨 대로 혼자 프로그램을 만드는 일을 한다면 그런 스킬과 경력만 계속 쌓일 것이다 -> 자신의 커리어에 대해 진지하게 다시 생각해보기

미래에는 암묵지와 직관을 잘 학습하는 사람들이 높은 경쟁력을 갖는다

## 달인이 되는 비결 

자신이 10년 넘게 해온 것 중에(이를테면 양치질) 전문성이 실제로 높아진 역량과 거의 변화가 없는 것의 차이는 무엇일까?

꾸준한 반복으로 달인이 되려면 적어도

1. 실력을 개선하려는 동기가 있어야 하고
2. 구체적인 피드백을 적절한 시기에 받아야 한다.

> 특정 영역에서 개인이 성취할 수 있는 최고 수준의 퍼포먼스는 경험을 오래 한다고 해서 자동으로 얻을 수 있는건 아니다

by 에릭손

## 수십 년 동안 전문가가 안 되는 비결

### 전문성 형성에서 타당성과 피드백의 중요성

믿을 수 있는 직관이 형성되려면 특정 조건이 필요하다: 타당성과 피드백

즉, 직관이 허용되는 영역에 어느 정도 인과관계와 규칙성이 존재해야 한다.

소프트웨어 개발 분야는 타당성도 낮고 피드백도 낮은 편이라고 한다. -> 오래 일해도 전문성이 신장되지 않음

### 타당성과 피드백 높이기

일하는 방식을 개선하면 높일 수 있고 현재보다 좀 더 빨리 발전시킬 수 있다.

## 당신이 제자리걸음인 이유

실력을 높이기 위해서는 의도적 수련이 필요하다. -> 동기와 피드백, 적절한 난이도가 필요하다

### 적절한 난이도

의도적 수련이 되려면 나의 실력과 작업의 난이도가 비슷해야 한다.

자신이 업무 시간 중에 불안함이나 지루함을 느끼는 때가 대부분이라면, 실력이 도무지 늘지 않는 환경에 있는 것이다.

### 지루함을 느끼는 경우: a1 실력 낮추기

작업의 난이도는 그대로 두고 실력을 낮추는 전략.

예: 평상시 즐겨 쓰던 보조 도구를 일부러 안 쓰는 것.

### 지루함을 느끼는 경우: a2 난이도 높이기

실력은 그대로 두고 작업의 난이도를 높이는 전략.

예: 하루 만에 개발하는 업무인데 한 시간만에 할 수 있는 방법 고안해보기, 리팩터링을 하거나 자동화 테스트를 다는 등 자신의 업무 개선

### 불안함을 느끼는 경우: b2 실력 높이기

* 사회적 접근: 나보다 뛰어난 전문가의 도움 얻기
* 도구적 접근: 다른 도구의 도움을 받는 것
* 내관적 접근: 비슷한 일을 했던 경험을 머릿속에서 되살려 보고 비유적으로 문제를 해결한다

### 불안함을 느끼는 경우: b1 난이도 낮추기

간단하면서 효과적인 방법: 자신이 맡은 일의 가장 간단하면서 핵심적인 결과물을 첫 번째 목표로 삼는 것. -> 그 후에 원래 목표로 개선

### 동적인 균형

현재 자신의 업무 처리 속도가 외부적으로 문제가 되지 않는 범위 내에서 적절하게 난이도와 실력을 조정해나가야 한다.

### 팀장이 할 수 있는 일

팀원의 상태를 파악하고 그들이 몰입으로 가게 도와주는 것 자체가 고도의 의도적 수련이 될 수 있다.

## 프로그래밍 언어 배우기의 달인

프로그래밍 언어를 빠르게 배우는 분에게 인터뷰를 해서 얻은 팁:

* 튜토리얼을 읽을 때 뭘 만들지 생각하고 읽는다
* 공부할 때 표준 라이브러리 소스코드를 읽는다
* 공부 중 다른 사람의 코드에 내가 필요한 기능을 추가한다

### 전문성을 효과적으로 뽑아내는 전문가가 되기

뭔가 잘하고 싶다면 이미 잘하는 사람을 관찰하고 인터뷰하는 것부터 시작하는 것이 큰 도움이 된다. 전문가가 구체적인 사건에 대해 말하도록 유도하자.

## 실수는 예방하는 것이 아니라 관리하는 것이다.

전문가들도 실수를 많이 저지르지만 그들은 실수가 나쁜 결과로 되기 전에 일찍 발견하고 빨리 고친다.

실수 예방 문화와 달리 실수 관리 문화에서는 
* 실수가 나쁜 결과를 내기 전에 빨리 회복하도록 돕고 
* 실수를 공개하고 
* 실수에 대해 서로 이야기하고 
* 거기에서 배우는 분위기가 생긴다.

실수가 없으면 학습하지 못한다.

## 뛰어난 선생에 대한 미신

지식이 많은 사람이 꼭 좋은 선생이라고는 할 수 없고 지식이 많은 사람에게 배웠다고 해서 내가 실력이 꼭 느는 것은 아니다.

과연 아는 것을 온전하게 가르칠 수 있는가?

### 인지적 작업 분석으로 극복하기

* 선생 입장: 자신에 대한 메타인지를 높여본다. "내가 이 문제를 해결할 때 어떤 과정을 거치는가"
* 학생 입장: 선택권이 있다면 자신과 학생에 대한 분석을 잘하는 선생을 고른다.

## 나홀로 전문가에 대한 미신

1. 아무리 기술적인 실천법이라고 해도
2. 그 기술을 사회적 맥락 속에서 실천되어야 하며
3. 그 기술의 성공을 위해서는 사회적 자본과 사회적 기술이 함께 필요하다

### 사회적 자본과 기술

신뢰가 깨져있는 상태에서는 어떤 행동을 해도 악의적으로 보인다. -> 직장에서도 마찬가지

### 고독한 전문가라는 미신

전문가는 사회적 자본과 사회적 기술 또한 뛰어나다. 뛰어난 소프트웨어 개발자일수록 타인과 인터랙션에 더 많은 시간을 쓴다.






